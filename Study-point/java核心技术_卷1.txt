JAVA核心技术_卷一

#====================================================================
第二章 Java程序设计环境
#====================================================================
1 java 安装包
JDK 编写java程序的程序员使用的软件
JRE 运行java程序的用户使用的软件(包含虚拟机,但不包含编译器)
SE  用于桌面或简单服务器应用的Java平台
EE  用于复杂服务器应用的Java平台
ME  用于手机和其他小型设备的Java平台
 
#====================================================================
第三章 Java的基本程序设计结构
#====================================================================
1 &&和||运算符是按照"短路的方式来求值的",使用||的时候要注意,可能后面的表达式没有判断

#====================================================================
1 位运算符,应用在布尔值上时,&和|运算符也会得到一个布尔值

2 当使用两个数值进行二元操作时,例如n+f,n是整数,f是浮点数,先要将两个操作数转换为同一种类型,然后在进行计算
(1)如果两个操作数中有一个是double类型,另一个操作数就会转换为double类型
(2)否则,如果其中一个操作数是float类型,另一个操作数将会转换为float类型.
(3)否则,如果其中一个操作数是long类型,另一个操作数将会转换为long类型.
(4)否则,两个操作数都将被转换为int类型

#====================================================================

3.String类
在JVM中存在一个字符串池，其中存有很多String对象，并且可以被共享使用。当创建一个字符串常量时，例如String s="abc"，会首先在字符串常量池中查找是否存在相同的字符串定义，若已经定义，则直接引用其定义，此时不需要创建新的对象；如果没有定义，则首先创建对象，然后把他加入到字符串池中，再将他的引用返回。由于字符串是不可变类，一旦创建好了就不可修改，因此字符串对象可以被共享而且不会引起程序的混乱。
String a = "a";//创建新对象，值为"a"，丢到字符串池，返回此对象的引用给a

String b = "a";//在字符串池查找值为"a"的对象，找到，返回此对象的引用给b

b = "b";//在字符串池查找值为"b"的对象，没找到，然后创建新对象，值为"b"，丢到字符串池，返回此对象的引用给b

3.1 检测两个字符串是否相等,使用String.equal();
    不区分大小写,可以使用equalsIgnoreCase()
    一定不要使用==运算符检测连个字符串是否相等!这个运算符智能确定两个字符串是否放置在同一个位置上,当然,如果字符串放置在同一个位置上,它们必然相等.但是,完全有可能将内容相同的多个字符串的拷贝放置在不用的位置上
    如果虚拟机始终将相同的字符串共享,就可以使用==运算符检测是否相等.但实机上只有字符串常量是共享的,而+或substring等操作产生的结果并不是共享的,因此千万不要使用==运算符测试字符串的相等性

3.2 空串是一个java对象,有自己的串长度(0)和内容(空),String变量还可以存放一个特殊的值.名为null,这表示目前没有任何对象与该变量关联
    要检查一个字符串是否为null,要使用以下条件:
    if(str == null)
    有时要检查一个字符串即不是null也不是空串,这种情况下就需要使用一下条件:
    if(str != null && str.lenght() != 0)
    首先要检查str不为null,如果在一个null值上调用方法,会出现错误

     StringBuilder这个类的前身是StringBuffer,其效率稍有些低,但允许采用多线程的方式执行添加或删除字符的操作.如果所有字符串在一个单线程中编辑,则应该用StringBuilder替代它.这两个类的API是相同的
     注:String本身是不可改变的,它只能赋值一次,每一次内容发生改变,都会生成一个新的对象,然后原有的对象引用新的对象,而每一次生成新对象都会对系统性能产生影响,这会降低.NET编译器的工作效率.而StringBuilder类不同,每次操作都是对自身对象进行操作,而不是生成新的对象,其所占空间会随着内容的增加而扩充.这样,在做大量的修改操作时,不会因生成大量匿名对象而影响系统性能.

#====================================================================
4. Java还提供了一种带标签的break语句,用于跳出多重嵌套循环语句.
    example:
    read_data:
    while() {
        for() {
            if(true) {
                break read_data;
            }
        }
    }
    注:可以将标签应用到任何语句中,甚至可以应用到if语句或者块语句中,如下所示:
    label:
    {
        ...
        if(condition) break label; //exit block
        ...
    }
    //jump here when the break statement executes
    //只能跳出语句块,而不能跳入语句块
#====================================================================
5. 不要在boolean类型与任何数值类型之间进行强制类型转换,这样可以防止发生错误.只有极少数的情况才需要将布尔类型转换为数值类型,这时可以使用条件表达式   b ? 1 : 0

#====================================================================
6. 枚举类型 enum Size {ONE, TOW, THREE, FORE}
Size s = Size.ONE;
Size类型的变量只能存储这个类型声明中给定的某个枚举值,或者null值, null值表示这个变量没有设置任何值

#====================================================================
7.java读取标准输入,首先需要构造一个Scanner对象,并与"标准输入流"System.in关联
Scanner in = new Scanner(System.in);
因为输入是可见的,所以Scanner类不适用于从控制台读取密码.Java SE6特别引入了Console类实现这个目的.想要读取一个密码,可以采用下列代码
Consol cons = System.console();
String username = cons.readLine("User name: ");
char[] passwd = cons.readPasswod("Password: ");
注 1: 为了安全起见,返回密码存放在一维数组中,而不是字符串.在对密码进行处理后,应该马上用一个填充数值覆盖数组元素,采用Consol对象处理输入不如采用Scanner方便.每次只能读取一行输入,而没有能够读取一个单词或一个数值的方法.
注 2: 如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,就会发生异常

#====================================================================
8. 不能在嵌套的不同作用域中声明同名的变量
例: public static void main(Stringp[] args) {
    int n ;
    ...
    {
        int k;
        int n;//Error--can`t redefine n inner block
    }
}

#====================================================================
9.switch语句将从选项值相匹配的case标签处开始执行直到遇到break语句,或者执行到switch语句的结束位置.如果没有想匹配的case标签,而有default子句,就执行这个子句.有可能触发多个case分支.如果在case分支语句的末尾没有break语句,那么就会接着执行下一个case分支语句.这种情况非常危险,常常会引发错误.
case的标签可以是: char, byte, short,或int的常量表达式,枚举常量,从javaSE7开始,case标签还可以是字符串字面量
当在switch语句中使用枚举常量时,不必在每个标签中指明枚举名,可以由switch的表达式确定;
例:
Size sz = ...;
switch(sz) {
    case SMALL://no need to use Size.SMALL
        ...
        break;
        ...
}

#====================================================================
10. break可以跳出带有标签的语句块
例:
read_data:
while() {
    ...
    for(...) {
        break read_data;
    }
}
事实上,可以将标签应用到任何语句中,甚至可以应用到if语句或者块语句中
例:
label:
{
    ...
    if(condition) break label; //exits block
    ...
}
//jumps here when the break statement executes

#====================================================================
11. 如果将continue语句用于for循环中,就可以跳到for循环的"更新"部分
例:
for(int i = 0; i < 100; ++i) {
    ...
    if(n > 5) continue;
    ...
}
如果n > 5 ,则continue语句调到++i语句
#====================================================================
12. 创建一个数字数组时,所有元素都初始化为0.boolean数组的元素会初始化为false.对象数组的元素则初始化为一个特殊值null,这表示这些元素还未存放任何对象
注:有个更简单的方式打印数组中的所有值,即利用Arrays类的toString方法.调用Arrays.toString(a),返回一个包含数组元素的字符串.这些元素被放置在括号内,并用逗号分隔,例如,"[2,3,5,7,11,13]"

#====================================================================
13. 数组初始化以及匿名数组
在java中,提供了一种创建数组对象并同时赋予初始值的简化书写形式
例:
int[] smallPrimes = {2,3,5,7,11,13}; //在使用这种语句时,不需要调用new
甚至还可以初始化一个匿名数组:
new int[] {17,19,23,29,31,37};
这种表示法将创建一个新数组并利用括号中提供的值进行初始化,数组的大小就是初始值的个数.使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组
例:
smallPrime = new int[] {17,19,23,29,31,37};

#====================================================================
14. 数组拷贝
在Java中,允许将一个数组变量拷贝给另一个数组变量.这时,两个变量将引用同一个数组.
int[] luckNumbers = smallPrimes;
luckNumbers[5] = 12; //now smallPrimes[5] is also 12
如果希望将一个数组的所有值拷贝到一个新的数组中去,就要使用Arrays类的copyOf方法:
int[] copiedLuckyNumbers = Arrays.copyOf(luckNumbers,luckyNumbers.lenght);
第二个参数是新数组的长度.这个方法通常用来增加数组的大小.如果数组元素是数值型,那么多余的元素将被赋值为0;如果数组元素是布尔型,则将赋值为false.相反,如果长度小于原始数组的长度,则只拷贝最前面的数据元素

#====================================================================
第四章 对象与类
#====================================================================
1. 方法参数
(1)Java程序设计语言总是采用按值调用,也就是说.方法得到的是所有参数值的一个拷贝
(2)Java程序设计语言对对象采用的不是引用调用,实际上,对象引用是按值传递的.
下面总结一下Java中方法参数的使用情况
    (2.1)一个方法不能修改一个基本数据类型的参数(即数值型或布尔型)
    (2.2)一个方法可以改变一个对象参数的状态
    (2.3)一个方法不能让对象参数引用一个新的对象

#====================================================================
2. 调用另一个构造器
在Java中,this引用等价于C++的this指针.但是,在C++中,一个构造器不能调用另一个构造器.在C++中,必须将抽取出的公共初始化代码编写成一个独立的方法.

#====================================================================
3. 初始化块
前面已经讲过两种初始化数据域的方法
(1)在构造器中设置值
(2)在声明中赋值
(3)在初始化块中赋值
初始化顺序总结:
(1)父类静态属性
(2)父类静态代码块
(3)子类静态属性
(4)子类静态代码块
(5)父类普通的初始化块
(6)父类构造方法
(7)子类普通的初始化块
(8)子类构造方法

#====================================================================
4. 包的作用域
标记为public的部分可以被任意的类使用;标记为private的部分只能被定义它们的类使用.如果没有指定public或private,这个部分(类,方法或变量)可以被同一个包中的所有方法访问

#====================================================================
5. 文档注释
JDK包含一个很有用的工具,叫做javadoc,它可以由源文件生成一个HTML文档.

5.1 类注释
/**
 * A {@code Card} 注释内容...
 */
为类本身添加的说明

5.2 方法注释
每一个方法注释必须放在所描述的方法之前.除了通用标记之外,还可以使用下面的标记:
(1)@param变量描述
这个标记将对当前方法的"param"(参数)部分添加一个条目.这个描述可以占据多行,并可以使用HTML标记.一个方法的所有@param标记必须放在一起
(2)@return描述
这个标记将对当前方法添加"return"(返回)部分.这个描述可以跨越多行,并可以使用HTML标记
(3)@throws类描述
这个标记将添加一个注释,用于表示这个方法有可能跑出异常.
下面是一个方法注释的示例
/**
 * Raise the salary of an employee
 * @param byPercent the percentage by which
 * @return the amount of the raise
 */

5.3 域注释
只需要对公有域(通常指的是静态变量)建立文档.例如
/**
 * The "Hearts" card suit
 */
public static final int HEARTS = 1;

5.4 通用注释
下面的标记可以用在类文档的注释中
(1)@author姓名
这个标记将产生一个"author"(作者)条目.可以使用多个@author标记,每个@author标记对应一个作者
(2)@version文本
这个标记将产生一个"version"(版本)条目.这里的文本可以是对当前版本的任何描述
(3)@since文本
这个标记将产生一个"since"(始于)条目.这里的text可以是对引入特性的版本描述.例如@since version 1.7.1
(4)@deprecated文本
这个标记将对类,方法或变量添加一个不在使用的注释.文本中给出了取代的建议
例如.
@deprecated Use <code> setVisible(true) </code> instead
通过@see和@link标记,可以使用超级链接,连接到javadoc文档的相关部分或外部文档
(5)@see引用
这个标记将在"see also"部分增加一个超级链接.它可以用于类中,也可以用于方法中.这里的引用可以选择下列情形之一

5.5 包与概述注释
可以直接将类,方法和变量的注释放置在Java源文件中,只要用/**.. */文档注释界定就可以了.但是,要向产生包注释,就需要在每个名目录中添加一个单独的文件.可以有如下两个选择
(1)提供一个以package.html命名的HTML文件.在标记<body>...<body>之间的所有文本都会被抽取出来
(2)提供一个以package-info.java命名的Java文件.这个文件必须包含一个初始的以/** 和*/界定的Javadoc注释.跟随在一个包语句之后.它不应该包含更多的代码或注释

#====================================================================
第五章 继承
#====================================================================
1. 在Java中,子类数组的引用可以转换成超类数组的引用,而不需要采用强制类型转换.
Manager[] managers = new Manager[10];
将它转换成Employee[]数组完全是合法的
Employee[] staff = managers; //OK

staff[0] = new Employee("Harry Hacker...");//这里staff[0]与manager[0]引用的是同一个对象.当调用managers[0].setBonus(1000)的时候,将会导致调用一个不存在的实例域

#====================================================================
2. 前面曾经说过,方法的名字和参数列表成为方法的签名.例如.f(int)和f(String)是两个具有相同名字,不同签名的方法.如果在子类中定义了一个与超累签名相同的方法,那么子类中的这个方法就覆盖了超类中的这个相同签名的方法.不过,返回类型不是签名的一部分,因此,在覆盖方法时,一定要保证返回类型的兼容性.允许子类将覆盖方法的返回类型定义为原返回类型的子类型.
例如:假设Employee类有
public Employee getBuddy(){....}
在后面的子类Manager中,可以按照如下所示的方法覆盖这个方法
public Manager getBuddy(){....}

#====================================================================
3. 如果是private方法,static方法,final方法,我们将这中调用方式称为静态绑定
与此对应的是,调用的方法依赖于隐式参数的实际类型,并且在运行时实现动态绑定.

3.1 当程序运行时,并且采用动态绑定调用方法时,虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法.假设x的实际类型是D,它是C类的子类.如果D类定义了方法f(String),就直接调用它;否则,将在D类的超类中寻找f(String),以此类推
每次调用方法都要搜索,时间开销相当大.因此,虚拟机预先为每个类创建一个方法表(methond table),其中列出了所有方法的签名和实际调用的方法.这样一来,在真正调用方法的时候,虚拟机仅查找这个表就行了

3.2 在覆盖一个方法的时候,子类方法不能低于超类方法的可见性,

特别是如果超类方法是public,子类方法一定要声明为public

#====================================================================
4 阻止继承:final类和方法
有时候,可能希望组织人们利用某个类定义子类,不允许扩展的类被称为final类,使用final修饰符声明.声明格式如下:
public final class Executive extends Manager {....}
类中的特定方法也可以被声明为final.如果这样做,子类就不能覆盖这个方法(final类中的所有方法自动地成为final方法)
将方法或类声明为final主要目的是:确保它们不会在子类中改变语义

#====================================================================
5. 强制类型转换
将一个值存入变量时,编译器将检查是否允许该操作.将一个子类的引用赋给一个超类变量,编译器是允许的.但将一个超类的引用赋给一个子类变量,必须进行类型转换.这样才能通过运行时检查.如果试图在继承链上进行向下的类型转换,并且"谎报"有关对象包含的内容,会发生什么情况呢?
Employee staff = new Employee[3];
Manager boss = (Manager)staff[1];//error
运行这个程序时,Java运行时系统将报告这个错误,并产生一个ClassCastException异常,如果没有捕获这个异常,那么程序就会终止.因此应该养成这样一个良好的程序设计习惯;在进行类型转换之前,先查看一下是否能够成功地转换.这个过程简单地使用instanceof操作符就可以实现.
例如:
if(staff[1] instanceof Manager) {
    boss = (Manager)staff[1];
    ...
}
综上所述:
(1)只能在继承层次内进行类型转换
(2)在将超类转换成子类之前,应该使用instanceof进行检查
(3)请记住,只要没有捕获ClassCastException异常,程序就会终止执行.在一般情况下,应该尽量少用类型转换和instancenof运算符

补充:Java关键字——instanceof
https://www.cnblogs.com/ysocean/p/8486500.html

instanceof严格来说是Java中的一个双目运算符,用来测试一个对象是否为一个类的实例,用法为:
boolean result = obj instanceof class;
其中obj为一个对象,Class表示一个类或者一个接口,当obj为Class的对象,或者是其直接或间接子类,或者是其接口的实现类,结果result都返回true,否则返回false.
注意:编译器会检查obj是否能转换成右边的class类型,如果不能转换则直接报错,如果不能确定类型,则通过编译,具体看运行时定.
(1)obj必须为引用类型,不能是基本类型
int i = 0;
System.out.println(i instanceof Integer);//编译不通过
System.out.println(i instanceof Object);//编译不通过
instanceof运算符只能用作对象的判断
(2)obj为null
System.out.println(null instanceof Object);//false
一般我们知道Java分为两种数据类型,一种是基本数据类型,有八个分别是byte,short,int,long,float,double,char,boolean.一种是应用类型,包括类,接口,数组等等.而Java中还有一种特殊的null类型,null引用是null类型表达式唯一可能的值,null引用也可以转换为任意引用类型.
(3)obj为class类的实例对象
Integer integer = new Integer(1);
System.out.println(integer instanceof Integer);//true
(4)obj为class接口的实现类
了解Java集合的,我们知道集合中有个上层接口List,其中有个典型实现类ArrayList
public class ArrayList<E> extends AbstrackList<E>
        implements List<E>, RandomAccess,Cloneable,Java.io.Serializable{}
所以我们可以用instancenof运算符判断某个对象是否是List接口的实现类,如果是返回true,否则返回false
ArrayList arrayList = new ArrayList();
System.out.println(arrayList instanceof List);//true
或者反过来也是返回true
List list = new ArrayList();
System.out.println(list instanceof ArrayList);//true
(5)obj为class类的直接或间接子类
我们新建一个父类Person.class,然后在创建它的一个子类Man.class
public class Person{}
public class Man extends Person{}
测试:
Person p1 = new Person();
Person p2 = new Man();
Man m1 = new Man();
System.out.println(p1 instanceof Man);//false
System.out.println(p2 instanceof Man);//true
System.out.println(m1 instanceof Man);//true
(6)问题
前面我门说过编译器会检查obj是否能转换成右边的class类型.如果不能转换则直接报错,如果不能确定类型,则通过编译,具体看运行时定
看如下几个例子:
Person p1 = new Person();
 
System.out.println(p1 instanceof String);//编译报错
System.out.println(p1 instanceof List);//false
System.out.println(p1 instanceof List<?>);//false
System.out.println(p1 instanceof List<Person>);//编译报错

原理说明:
伪代码如下:
boolean result;
if (obj == null) {
  result = false;
} else {
  try {
      T temp = (T) obj; // checkcast
      result = true;
  } catch (ClassCastException e) {
      result = false;
  }
}
简单来说就是:如果obj不为null并且(T)obj不抛ClassCastException异常则该表达式值为true,否则值为false

#====================================================================
6. 抽象类
6.1 抽象方法
(1)从上面的例子中我们可以看到抽象方法跟普通方法是有区别的,它没有自己的主体(没有{}包起来的业务逻辑),跟接口中的方法有点类似.所以我们没法直接调用抽象方法
(2)抽象方法不能用private修饰,因为抽象方法必须被子类实现(覆写),而private权限对于子类来说是不能访问的,所以就会产生矛盾
(3)抽象方法也不能用static修饰,试想一下,如果用static修饰了,那么我们可以直接通过类名调用而抽象方法压根就没有主体,没有任何业务逻辑,这样就毫无意义了.
6.2 抽象类:
(1)用abstract关键字来表达的类,其表达式形式为:(public) abstract class类型{}
(2)抽象类不能被实例化,也就是说我们没办法直接new一个抽象类.抽象类本身就代表了一个类型,无法确定为一个具体的对象,所以不能实例化就合乎情理了,只能有它的继承类实例化
(3)抽象类虽然不能被实例化,但有自己的构造方法
(4)抽象类与接口(interface)有很大的不同之处,接口中不能有实例方法去实现业务逻辑.而抽象类中可以有实例方法,并实现业务逻辑,比如我们可以在抽象类中创建和销毁一个线程池
(5)抽象类不能使用final关键字修饰,因为final修饰的类是无法被继承,而对于抽象类来说就是需要通过继承去实现抽象方法
6.3 抽象类与抽象方法的关联:
(1)如果一个类中至少有一个抽象方法,那么这个类一定是抽象类,但反之则不然.也就是说一个抽象类中可以没有抽象方法.这样做的目的是为了此类不能被实例化
(2)如果一个类继承了一个抽象类,那么它必须全部复写抽象类中的抽象方法.当然也可以不全部覆写,如果不覆写全部抽象方法则这个类也必须是抽象类(这样就无意义了)

#====================================================================
7. 访问控制符
下面归纳一下Java用于控制可见性的4个访问修饰符:
(1)仅对本类可见---------------private
(2)对所有类可见---------------public
(3)对本包和所有子类可见---------protected
(4)对本包可见-----------------默认(很遗憾),不需要修饰符

#====================================================================
8. Object:所有类的超类
Object类是Java中所有类的始祖,在Java中每个类都是由它扩展而来的.如果没有明确地指出超类,Object就被认为是这个类的超类.
在Java中,只有基本类型不是对象,例如,数值,字符和布尔类型的值都不是对象.所有的数组类型,不管是对象数组还是基本类型的数组都扩展了Object类
C++注释:在C++中没有所有类的根类,不过,每个指针都可以转换成void*指针

#====================================================================
9. Java比较两个对象是否是同一个引用
9.1 euqlas方法
Object类中equals方法用于检测一个对象是否等于另外一个对象.在Object类中,这个方法将判断两个对象是否具有相同的引用.如果两个对象具有相同的引用,它们一定是相等的.

9.2 如果想重写Object对象的equals函数,给出以下方法的建议:
(1)显示参数命名为otherObject,稍后需要将它转换成另一个叫做other的变量
(2)检测this与otherObject是否引用同一个对象:
if(this == otherObject)return true;
这条语句只是一个优化.实际上,这是一种经常采用的形式.因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多
(3)检测otherObject是否为null,如果为null,返回false.这项检测是很必要的
(4)比较this与otherObject是否属于同一个类.如果equals的语义在每个子类中有所改变,就使用getClass检测:
if(getClass() != otherObject.getClass)return false;
如果所有的子类都拥有统一的语义,就使用instanceof检测:
if(!(otherObject instanceof ClassName)) return false;
(5)将otherObject转换为相应的类类型变量:
ClassName other = (ClassName)otherObject;
(6)现在开始对所有需要比较的域进行比较了.使用==比较基本类型域,使用equals比较对象域.如果所有的域都匹配,就返回true;否则返回false;
return filed1 == other.filed1 &&
Object,equals(filed2,other.filed2) &&
...;
(7)如果在子类中重新定义equals,就要在其中包含调用super.equals(other);
补充:对于数组类型的域,可以使用静态的Arrays.equals方法检测相应的数组元素是否相等

9.3 hashCode方法
散列码(hash code)是由对象导出的一个整型值.散列码是没有规律的.如x和y是两个不同的对象引用.x.hashCode()与y.hashCode()基本上不会相同.
由于hashCode方法定义在Object类中,因此每个对象都有一个默认的散列码,其值为对象的存储地址.
String s = "OK";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + "" + sb.hashCode());
String t = new String("OK");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + "" + tb.hashCode());
对象                散列码
s                   2556
sb                  20526976
t                   2556
tb                  20527144

注:如果重新定义equals方法,就必须重新定义hashCode方法,以便用户可以将对象插入到散列表中(有关散列表的内容将在第9章中讨论)
Equals与hashCode的定义必须一致:如果x.equals(y)返回true,那么x.hashCode()就必须与y.hashCode具有相同的值.

9.4 toString()
在Object中还有一个重要的方法,就是toString方法,它用于返回表示对象值的字符串.
Object类定义了toString方法,用来打印输出对象所属的类名和散列码

#====================================================================
10. 泛型数组列表ArrayList
一旦能够确定数组列表的大小不在发生变化,就可以调用trimToSize方法.这个方法将存储区域的大小调整为当前元素数量所需的存储空间数目.垃圾回收器将回收多余的存储空间.一旦整理了数组列表的大小,添加新元素就需要花时间再次移动存储快,所以应该在确认不会添加任何元素时,在调用trimToSize.
C++注释:ArrayList类似于C++的Vector模板.ArrayList与vector都是泛型类型.但是C++的vector模板为了便于访问元素重载了[]运算符.由于Java没有运算符重载,所以必须调用显示的方法.此外C++向量是值拷贝.如果a和b是两个向量,赋值操作a=b将会构造一个与b长度相同的新向量a,并将所有的元素由b拷贝到a,而在Java中,这条赋值语句的操作结果是让a和b引用同一个数组列表

10.1 访问数组列表元素
(1)void set(int index, E obj)
设置数组列表指定位置的元素值,这个操作将覆盖这个位置的原有内容.
(2)E get(int index)
获得指定位置的元素值
(3)void add(int index,E obj);
向后移动元素,以便插入元素
(4)E remove(int index)
删除一个元素,并将后面的元素向前移动.被删除的元素由返回值返回

10.2 类型化与原是数组列表的兼容性
public class EmployeeDB {
    public void update(ArrayList list) {...}
    public ArrayList fine(String query) {...}
}
可以将一个类型化的数组列表传递给update方法,而并不需要进行任何类型转换
ArrayList<EmployeeDB> staff = ...;
employeeDB.update(staff);
这种情况编译器没有给出任何错误信息或警告,但是这样调用并不太安全.在update方法中,添加到数组列表中的元素可能不是Employee类型,在对这些元素进行检索时就会出现异常.
相反的,将一个原始ArrayList赋给一个类型化ArrayList会得到一个警告.
ArrayList<Employee> result = employee.find(query); //yields warning
注释:为了能够看到警告性错误的文字信息,要将编译选项设置为-Xlint:unchecked
使用类型转换并不能避免出现警告
ArrayList<Employee> result = (ArrayList<EmployeeDB>employeeDB.find(query);//yileds another warning
这样,将会得到另外一个警告信息,指出类型转换有误
一旦确保不会造成严重的后果,可以使用@SupportWarnings("uncheked");标注来标记这个变量能够接受类型转换,如下所示:
@SuppressWarnings("unchecked");ArrayList<EmployeeDB> result = (ArrayList<Employee>)employee.find(query);//yeild another warning

#====================================================================
11. 对象包装器与自动装箱
有时,需要将int这样的基本类型转换为对象.所有的基本类型都有一个与之对应的类.例如,Integer类对应基本类型int.通常,这些类称为包装器(wrapper).这些对象包装器类拥有很明显的名字:Integer,Long,Float,Double,Short,Byte,Character,Void和Boolean(前六个派生于公共的超类Number).对象包装器类是不可变的,即一旦构造了包装器,就不允许更改包装在其中的值.同时,包装器类还是final,因此不能定义它们的子类.
幸运的是,有一个很有用的特性,从而更加便于添加int类型的元素到ArrayList<Integer>中,下面这个调用
list.add(3); 将自动地变换成 list.add(Integer.valueOf(3));
这种变换被称为自动装箱(autoboxing).相反的,当将一个Integer对象赋给一个int值时,将会自动地拆箱.也就是说,编辑器将下列语句:
int n = list.get(i);翻译成 int n = list.get(i).intValue();
注释:自动装箱规范要求boolean,byte,char小于等于127,介于-128 ~ 127之间的short和int被包装到固定的对象中.
Integer对象是不可变的:包含在包装器中的内容不会改变.不能使用这些包装器类纯碱修改数值参数的方法.
如果想编写一个修改数值参数值的方法,就需要使用在org.omg.CORBA包中定义的持有者(holder)类型,包括IntHolder,BooleanHolder等.每个持有者类型都包含一个公有(!)域值,通过它可以范文存储在其中的值.

#====================================================================
12 参数数量可变的方法
伪代码:
public Class PrintStream {
    public PrintStream printf(String fmt, Object... args){
        return format(fmt,args);
    }
}
这里的省略号...是Java代码的一部分,它表明这个方法可以接受任意数量的对象(除fmt参数之外)
用户自己也可以定义可变参数的方法,并将参数指定为任意类型,甚至是基本类型.下面是一个简单的示例:
public static double max(double... values) {
    double largest = Double.NEGATIVE_INFINITY;
    for(double v : values)if (v > largest) largest = v;
    return largest;
}
可以像下面这样调用这个方法:
double m = max(3.1,40.4,-5);
编译器将new double[] {3.1,40.4,-5}传递给max方法.

#====================================================================
13. 枚举类
示例:public enum Size{SMALL,MEDIUM,LARGE.EXTRA_LARGE};
实际上,这个声明定义的类型是一个类,它刚好有4个实例,再此尽量不要构造新对象.因此,在比较两个枚举类型的值时,永远不需要调用equals,而直接使用"=="就可以了.
如果需要的话,可以在枚举类型中添加一些构造器,方法和域.
public enum Size {
    SMALL("S"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL");

    private String abbreviation;

    private Size(String abbreviation){this.abbreviation = abbreviation}
    private String getAbbreviation() {return abbreviation}
}
所有的枚举类型都是Enum类的子类.它们继承了这个类的许多方法.其中最有用的一个是toString,这个方法能够返回枚举常量名.例如Size.SMALL.toString()将返回字符串"SMALL"
(1) static Enum valueof(Class enumClass,String name)
返回指定名字,给定类的枚举常量
(2)String toString()
返回枚举常量名
(3)int ordinal()
返回枚举常量在enum声明中的位置,位置从0开始计数.
(4)int compareTo(E other)
如果枚举常量出现在other之前,则返回一个负值;如果this == other,则返回一个负值;如果this==other,则返回0;否则,返回正值.枚举常量的出现次序在enum声明中给出.

#====================================================================
14. 反射
能够分析类能力的程序称为反射(reflective).反射机制可以用来:
(1)在运行时分析类的能力
(2)在运行时查看对象,例如,编写一个toString方法供所有类使用.
(3)实现通用的数组操作代码
(4)利用Method对象,这个对象很像C++中的函数指针

14.1 Class类
在程序运行期间,Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识.这个信息跟踪着每个对象所属的类.
一个Class对象实际上表示的是一个类型,而这个类型未必一定是一种类.
虚拟机为每个类型管理一个Class对象.因此,可以利用==运算符实现两个类对象比较的操作.例如
if(e.getClass() == Employee.class)....;
还有一个很有用的方法newInstance(),可以用来动态地创建一个类的实例.例如:
e.getClass().newInstance();
创建了一个与e具有相同类型的实例.newInstance方法调用默认的构造器(没有参数的构造器)初始化新创建的对象.如果这个类没有默认的构造器,就会抛一个异常.
将forName与newInstance配合起来使用,可以根据存储在字符串中的类名创建一个对象.
String s = "java.util.Random";
Object m = Class.froName(s).newInstance();
注:如果需要以这种方式向希望按名称创建的类的构造器提供参数,就不要使用上面那条语句,而必须使用Constructor类中的newInstance方法

14.2 利用反射分析类的能力
在java.lang.reflect包中有三个类Field,Method和Constructor分别用于描述类的域,方法和构造器.这三个类都有一个getModifiers的方法,它将返回一个整型数值,用不同的位开关描述public和static这样的修饰符使用状况.另外还可以使用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整型数值.
Class类中的getFields,getMethod和getConstructors方法将分别返回类提供的public域,方法和构造器数组,其中包括超类的公有成员.Class类的getDeclareFields.getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域,方法和构造器,其中包括私有成员和受保护成员,但不包括超类的成员

14.3 在运行时使用反射分析对象
查看对象域(成员变量)的关键方法是Field类中的get方法.示例如下:
Employee harry = new Employee("Harry Hacker", 35000,10,1,1989);
Class cl = harry.getClass();
Filed f = cl.getDeclaredField("name");
Object v = f.get(harry);
这段代码存在一个问题.由于name是一个私有域,所以get方法将会抛出一个IllegalAccessException.反射机制的默认行为受限于Java的访问控制.为了达到这个目的,需要调用Field,Method或Constructor对象的setAccessible方法.
setAccessible方法是AccessibleObject类中的一个方法,它是Field,Method和COnstructor类的公共超类.这个特性是为调试,持久存储和相似机制提供的

14.4 使用反射编写泛型数组代码
java.lang.reflect包中的Array类允许动态地创建数组.使用反射编写伪代码示例如下:
public static Object goodCopyOf(Object a, int lenghth) {
    Class cl = a.getClass();
    if(!cl.isArray()) return null;
    Class componenType = cl.getCompoentType();
    int lenght = Array.getLenght(a);
    Object newArray = Array.newInstance(componenType,newLenght);
    System.arraycopy(a,0,newArray,0,Math.min(lenght,newLenght));
    return newArray;
}
这个CopyOf方法可以用来扩展任意类型的数组,而不仅是对象数组.
int[] a = {1,2,3,4,5};
a = (int[])goodCopyOf(a,10);
为了能够实现上述操作,应该将goodCopyOf的参数声明为Object类型,而不要声明为对象数组(Object[]).整型数组类型int[]可以被转换成Object,但不能转换成对象数组.

14.5 调用任意方法
示例:
Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee,class.getMethod("raiseSalary",double.class);
String n = (String)m1.invoke(harry);
double s = (Double)m2.invoke(harry);

#====================================================================
15. 继承的设计技巧
(1).将公共操作和域放在超类
(2).不要使用受保护的域
(3).使用继承实现"is-a"关系
(4).除非所有继承的方法都有意义,否则不要使用继承
(5).在覆盖方法时,不要改变预期的行为
(6).使用多态,而非类型信息
(7).不要过多的使用反射.反射是很脆弱的,即编译器很难帮助人们发现程序中的错误,因此只有在运行时才发现错误并导致异常.

#====================================================================
第六章 接口,lambda表达式与内部类
#====================================================================
1. 接口
Arrays类中的sort方法承诺可以对对象数组进行排序,但要求满足下列前提:对象所属的类必须实现了Comparable接口
下面是Comparable接口代码:
public interface Comparable<T> {
    int cpmpareTo(T other);//parameter has type T
}
在接口声明中,没有将compareTo方法声明为public,这是因为在接口中的所有方法都自动地是public.不过,在实现接口时,必须把方法声明为public;否则,编辑器将认为这个方法的访问属性是包可见性,即类的默认访问属性,之后编译器就会给出试图提供更严格的方位权限的警告信息

1.1 接口的特性
(1)接口不是类,尤其不能使用new运算符实例化一个接口:
x = new Comparable{...}//ERROR
(2)如同使用instanceof检查一个对象是否属于某个特定类一样,也可以使用instance检查一个对象是否实现了某个特定的接口:
if(anObject instanceof Comparable){...}
(3)与可建立类的继承关系一样,接口也可以被扩展.这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链.例如:
public interface Moveable {
    void move(double x, double y);
}
然后,可以以它为基础扩展一个叫做Powered的接口:
public interface Powered extends Moveable {
    double milesPerGallon();
}
虽然接口中不能包含实例域或静态方法,但却可以包含常量.例如:
public interface Powered extends Moveable {
    double milesPerGallon();
    double SPEED_LIMIT = 95;//a public static final constant
}
与接口中的方法都自动地被设置为public一样,接口中的域将被自动设为 public static final.但Java语言规范却建议不要书写这些多余的关键字

注:如果希望自己设计的类拥有克隆和比较的能力,只要实现这两个接口就可以了.使用逗号将实现的各个接口分隔开.
class Employee implements Cloneable,Comarable {}

1.2 默认方法
可以为接口方法提供一个默认实现.必须用default修饰符标记这样一个方法
public interface Comparable<T> {
    default int compareTo(T other){ return 0; }
    //By default,all elements are the same
}
默认方法的一个重要的用法是"接口演化"详情见书P220页

1.3 解决默认方法冲突
如果现在一个接口中将一个方法定义为默认方法,然后又在超类或另一个接口中定义了同样的方法,会发生什么情况呢?
规则如下:
(1)超类优先.如果超类提供了一个具体方法,同名而且有相同参数类型的默认方法会被忽略
(2)接口冲突.如果一个超接口提供了一个默认方法,另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法,必须覆盖这个方法来解决冲突.
下面来看第二个规则.开率另一个包含getName方法的几口
interface Named {
    default String getName() {return getClass.getName + "_" + hashCode();}
}
interface Person {
    default String getName() {return getClass.getName + "_" + hashCode();}
}
如果有一个类同时实现了这两个接口会怎么样呢?
class Student implements Person,Named {
    ...
}
类会继承Person和Named接口提供的两个不一致的getName方法,并不是从中选择一个,Java编译器会报告一个错误,让程序员来解决这个二义性.只需要在Student类中提供一个getName方法.在这个方法中,可以选择两个冲突方法中的一个,如下所示:
class Student implements Person,Named {
    public String getName() { return Person.super.getName(); }
}
如果Named接口没有为getName提供默认实现:
interface Named {
    String getName();
}
Student类也不会从Person接口继承默认方法.Java设计者更强调一致性.两个接口如何冲突并不重要.如果至少有一个接口提供了一个实现,编译器就会报告错误,而程序员就必须解决这个二义性.
如果两个接口都没有为共享方法提供默认实现,那么继承类必须实现接口方法.
现在来考虑另一种情况,一个类扩展了一个超类,同时实现了一个接口,并从超类和接口继承了相同的方法.例如,Person是一个类,Student定义为:
class Student extends Person implements Named{...}
在这种情况下,只会考虑超类方法,接口的所有默认方法都会被忽略.Student从Person继承了getName方法,Named接口是否为getName提供了默认实现并不会带来什么区别.这正是"类优先"规则."类优先"规则可以确保与Java SE 7的兼容性.如果为一个接口增加默认方法,这对于有这个默认方法之前能正常工作的代码不会有任何影响.
警告:千万不要让一个默认方法重新定义Object类中的某个方法.由于"类优先"规则,这样的方法绝对无法超越Object,toString或Object.equals.

#====================================================================
2. 对象克隆
原变量和副本都是同一个对象的引用.这说明,任何一个变量改变都会影响另一个变量.
clone方法是Object的一个protected方法,这说明你的代码不能直接调用这个方法.只有Employee类可以克隆Employee对象.这个限制是有原因的.现象看Object类如何实现clone.它对于这个对象一无所知,所以只能逐个域地进行拷贝.如果对象中的所有数据域都是数值或其他基本类型,拷贝这些域没有任何问题.但是如果对象包含子对象的引用,拷贝域就会得到相同子对象的另一个引用,这样一来,原对象和克隆的对象仍然会共享一些信息.
默认的克隆操作是"浅拷贝",并没有克隆对象中引用的其他对象.浅拷贝就是说对象中包含的其他对象在拷贝过程中仍是之前对象的引用,改变这个引用也会影响到之前对象的引用.并没有将clone对象和原对象完全隔离开.
浅拷贝会有什么影响么?如果原对象和浅克隆对象共享的子对象是不可变的,如String,就是这种情况.或者在对象的生命期中,子对象一直包含不变的常量,没有更改器会改变它,也没有办法会生成它的引用,这种情况下同样是安全的.
通常子对象都是可变的,必须重新定义clone方法来建立一个深拷贝,同时克隆所有子对象.
对于每一个类,需要确定:
(1)默认的clone方法是否满足要求;
(2)是否可以在可变的子对象上调用clone来修补默认的clone方法
(3)是否不该使用clone
实际上第3个选项是默认选项.如果选择第1项或第2项,类必须:
(1)实现Cloneable接口:
(2)重新定义clone方法,并指定public访问修饰符.
在这里,Cloneable接口的出现与接口的正常使用并没有关系.具体来说,它没有指定clone方法,这个方法是从Object类继承的.这个接口只是作为一个标记,指示类设计者了解克隆过程.对象对于克隆很"偏执",如果一个对象请求克隆,但没有实现这个接口,就会生成一个检查异常.

#====================================================================
3. lambda表达式
https://blog.csdn.net/weixin_37766087/article/details/94999833
lambda表达式是一个可传递的代码块,可以在以后执行一次或多次.

3.1 lambda表达式的语法
(1)Java中的一种lambda表达式形式:参数,箭头(->)以及一个表达式.如果代码要完成的计算无法放在一个表达式中,就可以像写方法一样,把这些代码放在{}中,并包含显式的return语句.例如:
(String first, String second) -> 
{
    if(first.lenght() < second.lenght()) return -1;
    else if (first.lenght() > second.lenght()) return 1;
    else return 0;
}

(2)即使lambda表达式没有参数,仍然要提供空括号,就像无参方法一样:
() -> {for(int i= 0 ; i < 10; i++) System.out.println(i);}

(3)如果可以推导出一个lambda表达式的参数类型,则可以忽略其类型.例如:
Comparator<String> comp 
    = (first, second)//Same as (String first, String second)
        ->first.lenght() - second.lenght();
在这里,编译器可以推导出first和second必然是字符串,因为这个lambda表达式将赋给一个字符串比较器(下一节会更详细地分析这个赋值)

(4)如果方法只有一个参数,而且这个参数的类型可以推倒得出,那么甚至还可以省略小括号:
ActionListener listener = event->
    System.out.println("The time is " + new Date());
    //Instead of (event)-> ... or (ActionEvent event)->...
无需指定lambda表达式的返回类型.lambda表达式的返回类型总是会由上下文推到得出.

注:如果一个lambda表达式只在某些分之返回一个值,而在另外一些分之不返回值,这是不合法的.例如,(int x)->{if(x>=0 )return 1;}就不合法;

3.2 函数式接口
对于只有一个抽象方法的接口,需要这种接口的对象时,就可以提供一个lambda表达式.这种接口称为函数式接口(function interface).
实际上,在Java中,对lambda表达式所能做的也只是能转换为函数式接口.在其他支持函数字面量的程序设计语言中,可以声明函数类型(如(String,String)->int),声明这些类型的变量,还可以使用变量保存函数表达式,不过,Java设计者还是决定保持我们熟悉的接口概念,没有为Java语言增加函数类型.
注释:甚至不能把lambda表达式赋给类型为Object的变量,Object不是一个函数式接口.
Java API在java.util.function包中定义了很多非常通用的函数式接口.其中一个接口BiFunction<T,U,R>描述了参数类型为T和U而且返回类型为R的函数.可以把我们的字符串比较lambda表达式保存在这个类型的变量中:
BiFunction<String,String,Integer>comp 
    = (first,second)->first.lenght() - second.lenght();
想要用lambda表达式做某些处理,还是要谨记表达式的用途,为它建立一个特定的函数式接口.
java.util.function包中有一个尤其有用的接口Predicate;
public interface Predicate<T> {
    boolean test(T t);
    //Additional default and static methods
}
ArrayList类有一个removeif方法,它的参数就是一个Predicate.这个接口专门用来传递lambda表达式.例如,下面的语句将从一个数组列表删除所有null值:
list.removeIf(e->e==null);

3.3 变量作用域
通常,你可能希望能够在lambda表达式中访问外围方法或类中的变量.考虑下面这个例子:
public static void repeatMessage(String text, int delay) {
    ActiobListener listener = event -> {
        System.out.println(text);
        Toolkit.getDefaultToolkit().beep();
    }
    new Timer(delay, listener).start();
}
//调用,Prints Hello every 1,000 milliseconds
repeartMessage("Hello",1000);
从上述例子看:
lambda表达式的代码可能会在repeatMessage调用返回很久以后才运行,而那时这个参数变量已经不存在了.如何保留text变量呢?
lambda表达式有3个部分:
(1)一个代码块;
(2)参数;
(3)自由变量的值,这是指非参数而且不在代码中定义的变量
这个lambda表达式有1个自由变量text.表示lambda表达式的数据结构必须存储自由变量的值,在这里就是字符串"Hello".我们说它被lambda表达式捕获(captured)
可以看到,lambda表达式可以捕获外围作用域中变量的值.在Java中,要确保所捕获的值是明确定义的,这里有一个重要的限制.在lambda表达式中,只能引用值不会改变的变量.例如,下面的做法是不合法的:
public static void countDown(int start, int delay) {
    ActionListener listener = event-> {
        start--;//Error:Can not mutate captured variable
        System.out.println(start);
    };
    new Timer(delay,listener).start();
}
之所以有这个限制是有原因的.如果在lambda表达式中改变变量,并发执行多个动作时就会不安全.
另外如果在lambda表达式中引用变量,而这个变量可能在外部改变,这也是不合法的.例如,下面就是不合法的:
public static void repeat(String text, int count) {
    for(int i = 1; i < count; i++) {
        ActionListener listener = event-> {
            System.out.println(i + ":" +text);
            //Error:Can not refer to changing i
        }
        new Timer(1000,listener).start();
    }
}
这里有一条规则:lambda表达式中捕获的变量必须实际上是最终变量(effectively final).实际上的最终变量是指,这个变量初始化之后就不会再为它赋新值.在这里,text总是指示同一个String对象,所以捕获这个变量是合法的.不过,i的值会改变,因此不能捕获i;
lambda表达式的体与嵌套块有相同的作用域.这里同样适用命名冲突和遮蔽的有关规则.在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的.
在一个lambda表达式中使用this关键字时,是指创建这个lambda表达式的方法的this参数.例如,考虑下面的代码
public class Application {
    public void init() {
        ActionListener listener = event-> {
            System.out.println(this.toString());
            ...
        }
        ...
    }
}
表达式this.toString()会调用Application对象的toString方法,而不是ActionListener实例的方法.在lambda表达式中,this的使用并没有任何特殊之处.lambda表达式的作用域嵌套在init方法中,与出现在这个方法中的其他位置一样,lambda表达式中this的含义并没有变化.

3.4 处理lambda表达式
使用lambda表达式的重点是延迟执行(deferred execution).毕竟,如果想要立即执行代码,完全可以直接执行,而无需把它包装在一个lambda表达式中.之所以希望以后在执行代码,这有很多原因,如:
(1)在一个单独的线程中运行代码;
(2)多次运行代码;
(3)在算法的释放位置运行代码(例如,排序中的比较操作);
(4)发生某种情况时执行代码(如,点击了一个按钮,数据到达,等等)
(5)只在必要时才运行代码
下面来看一个简单的例子.假设你想要重复一个动作n次.将这个动作和重复次数传递到一个repeat方法:
要接受这个lambda表达式,需要选择(偶尔可能需要提供)一个函数式接口.在这里,我们可以使用Runnable接口:
public static void repeat(int n, Runable action) {
    for(int i = 0; i < n; i++) action.run();
}
现在让这个例子更复杂一些.我们希望告诉这个动作它出现在哪一次迭代中.为此,需要选择一个合适的函数式接口,其中要包含一个方法,这个方法有一个int参数而且返回类型为void,处理int值的标准接口如下:
public interface IntConsumer {
    void accept(int value);
}
下面给出repeat方法的改进版本:
public static void repeat(int n, IntConsumer action) {
    for(int i = 0; i < n; i++)action.accept(i);
}
可以如下调用它:
repeat(10,i-> System.out.println("Countdown: " + (9-i)));
注:如果设计你自己的接口,其中只有一个抽象方法,可以用@FunctionalInterface注解来标记这个接口.这样做有两个优点.如果你无意中增加了两一个非抽象方法,编译器会产生一个错误消息.另外javadoc页里会指出你的接口是一个函数式接口.

#====================================================================
4. 方法引用
有时,可能已经有现成的方法可以完成你想要传递到其他代码的某个动作.
你希望值要出现一个定时器时间就打印这个时间对象.当然,为此也可以调用:
Timer t = new Timer(1000, event->System.out.println(event));
但是,如果直接把println方法传递到Timer构造器就更好了.具体做法如下:
Timer t = new Timer(1000,System.out::printfln);
表达式System.out::println是一个方法引用(method reference),它等价于lambda表达式x->System.out.println(x);
再来看一个例子,假设你想对字符串排序,而不考虑字母的大小写.可以传递一下方法表达式:
Arrays.sort(strings,String::compareToIgnoreCase);
从这些例子可以看出,要用::操作符分隔方法名与对象或类名.主要有3种情况:
(1)object::instanceMethod
(2)Class::staticMethod
(3)Class::instanceMethod
在前面2种情况中,方法引用等价于提供方法参数的lambda表达式.前面已经提到System.out.println等价于x->System.out.println(x).类似地,Math::pow等价于(x,y)->Math.pow(x,y);
对于第三种情况,第1个参数会称为方法的目标.例如,String::compareToIgnoreCase等同于(x,y)->x.compareToIgnoreCase(y).
注:如果有多个同名的重载方法,编译器就会尝试从上下文中找出你指的哪一个方法.例如,Math.max方法有两个版本,一个用于整数,另一个用于double值.选择哪一个版本取决于Math::max转换为哪个函数式接口的方法参数.类似于lambda表达式,方法引用不能独立存在,总是会转换为函数式接口的实例.
可以在方法引用中使用this参数.例如,this::equals等同于x->this.equals(x).使用super也是合法的.下面的方法表达式
super::instanceMethod
使用this作为目标,会调用给定方法的超类版本.下面给出一个假象的例子:
class Greeter {
    public void greet() {
        System.out.println("Hello,world!");
    }
}
class TimedGreeter extends Greeter {
    public void greet() {
        Timer t = new Timer(1000, super::greet);
        t.start();
    }
}
TimedGreeter.greet方法开始执行时,会构造一个Timer,它会在每次定时器滴答时执行super::greet方法.这个方法会调用超类的greet方法.

#====================================================================
5. 构造器引用
构造器引用与方法引用很类似,只不过方法名为new.例如,Person::new是Person构造其的一个引用.哪一个构造器呢?这取决于上下文.假设你有一个字符串列表.可以把它转换为一个Person对象数组.为此要在各个字符串上调用构造器,调用如下:
ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());
分析:map方法会为各个列表元素调用Person(String)构造器.如果有多个Person构造器,编译器会选择有一个String参数的构造器,因为它从上下文推导出这是在对一个字符串调用构造器.
可以用数组类型建立构造器引用.例如,int[]::new是一个构造器引用,它有一个参数:即数组的长度.这等价于lambda表达式 x->new int[x].
Java有一个限制,无法构造泛型类型T的数组.数组构造器引用对于客服这个限制很有用.表达式new T[n]会产生错误,因为这会改为new Object[n].对于开发类库的人来说,这是一个问题.例如,假设我们需要一个Person对象数组.Stream接口有一个toArray方法可以返回Object数组:
Object[] people = steam.toArray();
不过,这并不让人满意.用户希望得到一个Person引用数组,而不是Object引用数组.流库利用构造器引用解决了这个问题.可以把Person[]::new传入toArray方法:
Person[] people = stream.toArray(Person[]::new);
toArray方法调用这个构造器来得到一个正确类型的数组.然后填充这个数组并返回.

#====================================================================

6. 内部类
内部类是定义在另一个类中的类,为什么需要使用内部类呢?其主要原因有一下三点:
(1)内部类方法可以访问该类定义所在的作用域中的数据,包括私有的数据
(2)内部类可以对同一个包中的其他类隐藏起来.
(3)当想要定义一个回调函数且不想编写大量代码时,使用匿名(anonymous)内部类比较便捷
C++注释:C++有嵌套类.一个被嵌套的类包含在外围类的作用域内.下面是一个类型的例子,一个链表类定义了一个存储节点的类和一个定义迭代器位置的类.
class LinkedList {
public:
    class Iterator //a nested class 
    {
    public:
        void insert(int x);
    };
private:
    class Link // a nested class
    {
    public:
        Link* next;
        int data;
    };
};
嵌套类是一种类之间的关系,而不是对象之间的关系.一个LinkedList对象并不包含Iterator类型或Link类型的子对象.
嵌套类有两个好处:命名控制和访问控制.由于名字Iterator嵌套在LinkedList类的内部,所以在外部被命名为LinkedList::Iterator,这样就不会与其他名为Iterator的类发生冲突.在Java中这个并不重要,因为Java包已经提供了相同的命名控制.需要注意的是,Link类位于LinkedList类的私有部分,因此,Link对其他的代码均不可见.鉴于此情况,可以将Link的数据域设计为公有的,它仍然是安全的.这些数据域只能被LinkedList类(具有访问这些数据域的合理需要)中的方法访问,而不会暴露给其他的代码.在Java中,只有内部类能够实现这样的控制.
然而,Java内部类还有另外一个功能,这是的它比C++的嵌套类更加丰富,用途更加广泛.内部类的对象有一个隐式引用,它引用了实例化该内部对象的外围类对象.通过这个指针,可以访问外围类对象的全部状态.在Java中,static内部类没有这种附加指针,这样的内部类与C++中的嵌套类很相似.

6.1 使用内部类访问对象状态
外围类的引用在内部类的构造器中设置.编译器修改了所有的内部类的构造器,添加一个外围类引用的参数.
内部类示例:
public class Talking {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beeo){...}
    public void start(...);
    public class TimerPrint implements ActionListener {
        public void actionPerformed() {
            ...
        }
    }
}
注释:TimePrinter类声明为私有的.这样一来,只有TalkingClock的方法才能够构造TimePrinter对象.只有内部类可以是私有的,而常规类值可以具有可见性,或公有可见性

6.2 内部类的特殊语法规则
事实上,使用外围类引用的正规语法还要复杂一些,表达式
OuterClass.this(表示外围类引用)
例如:可以像下面这样编写TimePrinter内部类的actionPerformed方法:
public void actionPerformed() {
    ...
    if(Talking.this.beep)
        return;
}
反过来,可以采用下列语法格式更加明确地编写内部对象的构造器:
    outerObjec.new InnerClass(construction parameters)
例如:
ActionListener Listener = this.new TimerPrint();
通常,this限定词是多余的.不过,可以通过显式地命名将外围引用设置为其他的对象.例如,如果TimerPrint是一个公有内部类,对于任意的语音始终都可以构造一个TimerPrint:
Talking tk = new Talking();
Talking.TimerPrint listener = tk.new TimerPrint();
需要注意,在外围类的作用域之外,可以这样引用内部类:
OuterClass.InnerClass;
注释:内部类中声明的所有静态域都必须是final的.原因很简单.我们希望一个静态域只有一个实例,不过对于每个外部对象,会分别有一个单独的内部类实例.如果这个域不是final,它可能就不是唯一的.
内部类不能有static方法.Java语言规范对这个限制没有做任何解释.也可以允许有静态方法,但只能访问外围类的静态域和方法.显然,Java设计者认为相对于这种复杂性来说,它带来的好处有些得不偿失

6.3 局部内部类
如果仔细阅读一下TalkingClock(P246页)示例代码就会发现,TimePrinter这个类名字只在start方法中创建这个类型的对象时使用了一次.当遇到这类情况时,可以在一个方法中定义局部类.
public void start() {
    class TimePrinter implementes ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println("At the tone, the time is" + new Data());
            if(beep) Toolkit.getDefaultToolkit().beep();
        }
    }

    ActionListener listener = new TimerPrinter();
    Timer t = new Timer(interval,listener);
    t.start();
}
局部类不能用public或private访问说明符进行声明.它的作用域被限定在声明这个局部类的快中.
局部类有一个有时,即对外部世界可以完全地隐藏起来.即使TalkingClock类中的其他代码也不能访问它.除start方法之外,没有任何方法知道TimerPrinter类的存在.

6.3.1 由外部方法访问变量
与其他内部类相比较,局部类还有一个有点.它们不仅能够访问包含它们的外部类,还可以访问局部变量.不过,那些局部变量必须事实上为final.
局部类的方法只可以引用定义为final的局部变量.鉴于此情况,在列举的实例中,将beep参数声明为final,对它进行初始化后不能够在进行修改.因此,就使得局部变量与局部类内建立的拷贝保持一致.
注释:在JavaSE8之前,必须把从局部类访问的局部变量声明为final.例如,start方法原本应当这样声明,从而使内部类能够访问beep参数:
public void start(int interval,final boolean beep);
有时,final限制显得并不太方便.例如,假设想更新在一个封闭作用域内的计数器.这里想要统计一下排序过程中调用compareTo方法的次数.
int counter = 0;
Date[] dates = new Data[100];
for(int i= 0; i < dates.lenght; i++) {
    dates[i] = new Date() {
        public int compareTo(Date other) {
            counter++; //error
            return super.compareTo(other);
        };
    }
}
由于清楚地知道counter需要更新,所以不能将counter声明为final.由于Interger对象是不可变的,所以也不能用Interger代替它.补救的方法是使用一个长度为1的数组:
int[] counter = new int[i];
for(int i = 0; i < dates.lenght; i++) {
    dates[i] = new Date() {
        counter[0]++; //error
        return super.compareTo(other);
    };
}


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#===r================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================