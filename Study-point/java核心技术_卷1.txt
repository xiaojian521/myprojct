JAVA核心技术_卷一

#====================================================================
第二章 Java程序设计环境
#====================================================================
1 java 安装包
JDK 编写java程序的程序员使用的软件
JRE 运行java程序的用户使用的软件(包含虚拟机,但不包含编译器)
SE  用于桌面或简单服务器应用的Java平台
EE  用于复杂服务器应用的Java平台
ME  用于手机和其他小型设备的Java平台
 
#====================================================================
第三章 Java的基本程序设计结构
#====================================================================
1 &&和||运算符是按照"短路的方式来求值的",使用||的时候要注意,可能后面的表达式没有判断

#====================================================================
1 位运算符,应用在布尔值上时,&和|运算符也会得到一个布尔值

2 当使用两个数值进行二元操作时,例如n+f,n是整数,f是浮点数,先要将两个操作数转换为同一种类型,然后在进行计算
(1)如果两个操作数中有一个是double类型,另一个操作数就会转换为double类型
(2)否则,如果其中一个操作数是float类型,另一个操作数将会转换为float类型.
(3)否则,如果其中一个操作数是long类型,另一个操作数将会转换为long类型.
(4)否则,两个操作数都将被转换为int类型

#====================================================================
3. String类
在JVM中存在一个字符串池，其中存有很多String对象，并且可以被共享使用。当创建一个字符串常量时，例如String s="abc"，会首先在字符串常量池中查找是否存在相同的字符串定义，若已经定义，则直接引用其定义，此时不需要创建新的对象；如果没有定义，则首先创建对象，然后把他加入到字符串池中，再将他的引用返回。由于字符串是不可变类，一旦创建好了就不可修改，因此字符串对象可以被共享而且不会引起程序的混乱。
String a = "a";//创建新对象，值为"a"，丢到字符串池，返回此对象的引用给a

String b = "a";//在字符串池查找值为"a"的对象，找到，返回此对象的引用给b

b = "b";//在字符串池查找值为"b"的对象，没找到，然后创建新对象，值为"b"，丢到字符串池，返回此对象的引用给b

3.1 检测两个字符串是否相等,使用String.equal();
    不区分大小写,可以使用equalsIgnoreCase()
    一定不要使用==运算符检测两个字符串是否相等!这个运算符只能确定两个字符串是否放置在同一个位置上,当然,如果字符串放置在同一个位置上,它们必然相等.但是,完全有可能将内容相同的多个字符串的拷贝放置在不用的位置上
    如果虚拟机始终将相同的字符串共享,就可以使用==运算符检测是否相等.但实机上只有字符串常量是共享的,而+或substring等操作产生的结果并不是共享的,因此千万不要使用==运算符测试字符串的相等性

3.2 空串是一个java对象,有自己的串长度(0)和内容(空),String变量还可以存放一个特殊的值.名为null,这表示目前没有任何对象与该变量关联
    要检查一个字符串是否为null,要使用以下条件:
    if(str == null)
    有时要检查一个字符串即不是null也不是空串,这种情况下就需要使用一下条件:
    if(str != null && str.lenght() != 0)
    首先要检查str不为null,如果在一个null值上调用方法,会出现错误

     StringBuilder这个类的前身是StringBuffer,其效率稍有些低,但允许采用多线程的方式执行添加或删除字符的操作.如果所有字符串在一个单线程中编辑,则应该用StringBuilder替代它.这两个类的API是相同的
     注:String本身是不可改变的,它只能赋值一次,每一次内容发生改变,都会生成一个新的对象,然后原有的对象引用新的对象,而每一次生成新对象都会对系统性能产生影响,这会降低.NET编译器的工作效率.而StringBuilder类不同,每次操作都是对自身对象进行操作,而不是生成新的对象,其所占空间会随着内容的增加而扩充.这样,在做大量的修改操作时,不会因生成大量匿名对象而影响系统性能.

#====================================================================
4. Java还提供了一种带标签的break语句,用于跳出多重嵌套循环语句.
    example:
    read_data:
    while() {
        for() {
            if(true) {
                break read_data;
            }
        }
    }
    注:可以将标签应用到任何语句中,甚至可以应用到if语句或者块语句中,如下所示:
    label:
    {
        ...
        if(condition) break label; //exit block
        ...
    }
    //jump here when the break statement executes
    //只能跳出语句块,而不能跳入语句块
#====================================================================
5. 不要在boolean类型与任何数值类型之间进行强制类型转换,这样可以防止发生错误.只有极少数的情况才需要将布尔类型转换为数值类型,这时可以使用条件表达式   b ? 1 : 0

#====================================================================
6. 枚举类型 enum Size {ONE, TOW, THREE, FORE}
Size s = Size.ONE;
Size类型的变量只能存储这个类型声明中给定的某个枚举值,或者null值, null值表示这个变量没有设置任何值

#====================================================================
7.java读取标准输入,首先需要构造一个Scanner对象,并与"标准输入流"System.in关联
Scanner in = new Scanner(System.in);
因为输入是可见的,所以Scanner类不适用于从控制台读取密码.Java SE6特别引入了Console类实现这个目的.想要读取一个密码,可以采用下列代码
Consol cons = System.console();
String username = cons.readLine("User name: ");
char[] passwd = cons.readPasswod("Password: ");
注 1: 为了安全起见,返回密码存放在一维数组中,而不是字符串.在对密码进行处理后,应该马上用一个填充数值覆盖数组元素,采用Consol对象处理输入不如采用Scanner方便.每次只能读取一行输入,而没有能够读取一个单词或一个数值的方法.
注 2: 如果用一个不存在的文件构造一个Scanner,或者用一个不能被创建的文件名构造一个PrintWriter,就会发生异常

#====================================================================
8. 不能在嵌套的不同作用域中声明同名的变量
例: public static void main(Stringp[] args) {
    int n ;
    ...
    {
        int k;
        int n;//Error--can`t redefine n inner block
    }
}

#====================================================================
9.switch语句将从选项值相匹配的case标签处开始执行直到遇到break语句,或者执行到switch语句的结束位置.如果没有想匹配的case标签,而有default子句,就执行这个子句.有可能触发多个case分支.如果在case分支语句的末尾没有break语句,那么就会接着执行下一个case分支语句.这种情况非常危险,常常会引发错误.
case的标签可以是: char, byte, short,或int的常量表达式,枚举常量,从javaSE7开始,case标签还可以是字符串字面量
当在switch语句中使用枚举常量时,不必在每个标签中指明枚举名,可以由switch的表达式确定;
例:
Size sz = ...;
switch(sz) {
    case SMALL://no need to use Size.SMALL
        ...
        break;
        ...
}

#====================================================================
10. break可以跳出带有标签的语句块
例:
read_data:
while() {
    ...
    for(...) {
        break read_data;
    }
}
事实上,可以将标签应用到任何语句中,甚至可以应用到if语句或者块语句中
例:
label:
{
    ...
    if(condition) break label; //exits block
    ...
}
//jumps here when the break statement executes

#====================================================================
11. 如果将continue语句用于for循环中,就可以跳到for循环的"更新"部分
例:
for(int i = 0; i < 100; ++i) {
    ...
    if(n > 5) continue;
    ...
}
如果n > 5 ,则continue语句调到++i语句
#====================================================================
12. 创建一个数字数组时,所有元素都初始化为0.boolean数组的元素会初始化为false.对象数组的元素则初始化为一个特殊值null,这表示这些元素还未存放任何对象
注:有个更简单的方式打印数组中的所有值,即利用Arrays类的toString方法.调用Arrays.toString(a),返回一个包含数组元素的字符串.这些元素被放置在括号内,并用逗号分隔,例如,"[2,3,5,7,11,13]"

#====================================================================
13. 数组初始化以及匿名数组
在java中,提供了一种创建数组对象并同时赋予初始值的简化书写形式
例:
int[] smallPrimes = {2,3,5,7,11,13}; //在使用这种语句时,不需要调用new
甚至还可以初始化一个匿名数组:
new int[] {17,19,23,29,31,37};
这种表示法将创建一个新数组并利用括号中提供的值进行初始化,数组的大小就是初始值的个数.使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组
例:
smallPrime = new int[] {17,19,23,29,31,37};

#====================================================================
14. 数组拷贝
在Java中,允许将一个数组变量拷贝给另一个数组变量.这时,两个变量将引用同一个数组.
int[] luckNumbers = smallPrimes;
luckNumbers[5] = 12; //now smallPrimes[5] is also 12
如果希望将一个数组的所有值拷贝到一个新的数组中去,就要使用Arrays类的copyOf方法:
int[] copiedLuckyNumbers = Arrays.copyOf(luckNumbers,luckyNumbers.lenght);
第二个参数是新数组的长度.这个方法通常用来增加数组的大小.如果数组元素是数值型,那么多余的元素将被赋值为0;如果数组元素是布尔型,则将赋值为false.相反,如果长度小于原始数组的长度,则只拷贝最前面的数据元素

#====================================================================
第四章 对象与类
#====================================================================
1. 方法参数
(1)Java程序设计语言总是采用按值调用,也就是说.方法得到的是所有参数值的一个拷贝
(2)Java程序设计语言对对象采用的不是引用调用,实际上,对象引用是按值传递的.
下面总结一下Java中方法参数的使用情况
    (2.1)一个方法不能修改一个基本数据类型的参数(即数值型或布尔型)
    (2.2)一个方法可以改变一个对象参数的状态
    (2.3)一个方法不能让对象参数引用一个新的对象

#====================================================================
2. 调用另一个构造器
在Java中,this引用等价于C++的this指针.但是,在C++中,一个构造器不能调用另一个构造器.在C++中,必须将抽取出的公共初始化代码编写成一个独立的方法.

#====================================================================
3. 初始化块
前面已经讲过两种初始化数据域的方法
(1)在构造器中设置值
(2)在声明中赋值
(3)在初始化块中赋值
初始化顺序总结:
(1)父类静态属性
(2)父类静态代码块
(3)子类静态属性
(4)子类静态代码块
(5)父类普通的初始化块
(6)父类构造方法
(7)子类普通的初始化块
(8)子类构造方法

#====================================================================
4. 包的作用域
标记为public的部分可以被任意的类使用;标记为private的部分只能被定义它们的类使用.如果没有指定public或private,这个部分(类,方法或变量)可以被同一个包中的所有方法访问

#====================================================================
5. 文档注释
JDK包含一个很有用的工具,叫做javadoc,它可以由源文件生成一个HTML文档.

5.1 类注释
/**
 * A {@code Card} 注释内容...
 */
为类本身添加的说明

5.2 方法注释
每一个方法注释必须放在所描述的方法之前.除了通用标记之外,还可以使用下面的标记:
(1)@param变量描述
这个标记将对当前方法的"param"(参数)部分添加一个条目.这个描述可以占据多行,并可以使用HTML标记.一个方法的所有@param标记必须放在一起
(2)@return描述
这个标记将对当前方法添加"return"(返回)部分.这个描述可以跨越多行,并可以使用HTML标记
(3)@throws类描述
这个标记将添加一个注释,用于表示这个方法有可能跑出异常.
下面是一个方法注释的示例
/**
 * Raise the salary of an employee
 * @param byPercent the percentage by which
 * @return the amount of the raise
 */

5.3 域注释
只需要对公有域(通常指的是静态变量)建立文档.例如
/**
 * The "Hearts" card suit
 */
public static final int HEARTS = 1;

5.4 通用注释
下面的标记可以用在类文档的注释中
(1)@author姓名
这个标记将产生一个"author"(作者)条目.可以使用多个@author标记,每个@author标记对应一个作者
(2)@version文本
这个标记将产生一个"version"(版本)条目.这里的文本可以是对当前版本的任何描述
(3)@since文本
这个标记将产生一个"since"(始于)条目.这里的text可以是对引入特性的版本描述.例如@since version 1.7.1
(4)@deprecated文本
这个标记将对类,方法或变量添加一个不在使用的注释.文本中给出了取代的建议
例如.
@deprecated Use <code> setVisible(true) </code> instead
通过@see和@link标记,可以使用超级链接,连接到javadoc文档的相关部分或外部文档
(5)@see引用
这个标记将在"see also"部分增加一个超级链接.它可以用于类中,也可以用于方法中.这里的引用可以选择下列情形之一

5.5 包与概述注释
可以直接将类,方法和变量的注释放置在Java源文件中,只要用/**.. */文档注释界定就可以了.但是,要向产生包注释,就需要在每个名目录中添加一个单独的文件.可以有如下两个选择
(1)提供一个以package.html命名的HTML文件.在标记<body>...<body>之间的所有文本都会被抽取出来
(2)提供一个以package-info.java命名的Java文件.这个文件必须包含一个初始的以/** 和*/界定的Javadoc注释.跟随在一个包语句之后.它不应该包含更多的代码或注释

#====================================================================
第五章 继承
#====================================================================
1. 在Java中,子类数组的引用可以转换成超类数组的引用,而不需要采用强制类型转换.
Manager[] managers = new Manager[10];
将它转换成Employee[]数组完全是合法的
Employee[] staff = managers; //OK

staff[0] = new Employee("Harry Hacker...");//这里staff[0]与manager[0]引用的是同一个对象.当调用managers[0].setBonus(1000)的时候,将会导致调用一个不存在的实例域

#====================================================================
2. 前面曾经说过,方法的名字和参数列表成为方法的签名.例如.f(int)和f(String)是两个具有相同名字,不同签名的方法.如果在子类中定义了一个与超累签名相同的方法,那么子类中的这个方法就覆盖了超类中的这个相同签名的方法.不过,返回类型不是签名的一部分,因此,在覆盖方法时,一定要保证返回类型的兼容性.允许子类将覆盖方法的返回类型定义为原返回类型的子类型.
例如:假设Employee类有
public Employee getBuddy(){....}
在后面的子类Manager中,可以按照如下所示的方法覆盖这个方法
public Manager getBuddy(){....}

#====================================================================
3. 如果是private方法,static方法,final方法,我们将这中调用方式称为静态绑定
与此对应的是,调用的方法依赖于隐式参数的实际类型,并且在运行时实现动态绑定.

3.1 当程序运行时,并且采用动态绑定调用方法时,虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法.假设x的实际类型是D,它是C类的子类.如果D类定义了方法f(String),就直接调用它;否则,将在D类的超类中寻找f(String),以此类推
每次调用方法都要搜索,时间开销相当大.因此,虚拟机预先为每个类创建一个方法表(methond table),其中列出了所有方法的签名和实际调用的方法.这样一来,在真正调用方法的时候,虚拟机仅查找这个表就行了

3.2 在覆盖一个方法的时候,子类方法不能低于超类方法的可见性,

特别是如果超类方法是public,子类方法一定要声明为public

#====================================================================
4 阻止继承:final类和方法
有时候,可能希望组织人们利用某个类定义子类,不允许扩展的类被称为final类,使用final修饰符声明.声明格式如下:
public final class Executive extends Manager {....}
类中的特定方法也可以被声明为final.如果这样做,子类就不能覆盖这个方法(final类中的所有方法自动地成为final方法)
将方法或类声明为final主要目的是:确保它们不会在子类中改变语义

#====================================================================
5. 强制类型转换
将一个值存入变量时,编译器将检查是否允许该操作.将一个子类的引用赋给一个超类变量,编译器是允许的.但将一个超类的引用赋给一个子类变量,必须进行类型转换.这样才能通过运行时检查.如果试图在继承链上进行向下的类型转换,并且"谎报"有关对象包含的内容,会发生什么情况呢?
Employee staff = new Employee[3];
Manager boss = (Manager)staff[1];//error
运行这个程序时,Java运行时系统将报告这个错误,并产生一个ClassCastException异常,如果没有捕获这个异常,那么程序就会终止.因此应该养成这样一个良好的程序设计习惯;在进行类型转换之前,先查看一下是否能够成功地转换.这个过程简单地使用instanceof操作符就可以实现.
例如:
if(staff[1] instanceof Manager) {
    boss = (Manager)staff[1];
    ...
}
综上所述:
(1)只能在继承层次内进行类型转换
(2)在将超类转换成子类之前,应该使用instanceof进行检查
(3)请记住,只要没有捕获ClassCastException异常,程序就会终止执行.在一般情况下,应该尽量少用类型转换和instancenof运算符

补充:Java关键字——instanceof
https://www.cnblogs.com/ysocean/p/8486500.html

instanceof严格来说是Java中的一个双目运算符,用来测试一个对象是否为一个类的实例,用法为:
boolean result = obj instanceof class;
其中obj为一个对象,Class表示一个类或者一个接口,当obj为Class的对象,或者是其直接或间接子类,或者是其接口的实现类,结果result都返回true,否则返回false.
注意:编译器会检查obj是否能转换成右边的class类型,如果不能转换则直接报错,如果不能确定类型,则通过编译,具体看运行时定.
(1)obj必须为引用类型,不能是基本类型
int i = 0;
System.out.println(i instanceof Integer);//编译不通过
System.out.println(i instanceof Object);//编译不通过
instanceof运算符只能用作对象的判断
(2)obj为null
System.out.println(null instanceof Object);//false
一般我们知道Java分为两种数据类型,一种是基本数据类型,有八个分别是byte,short,int,long,float,double,char,boolean.一种是应用类型,包括类,接口,数组等等.而Java中还有一种特殊的null类型,null引用是null类型表达式唯一可能的值,null引用也可以转换为任意引用类型.
(3)obj为class类的实例对象
Integer integer = new Integer(1);
System.out.println(integer instanceof Integer);//true
(4)obj为class接口的实现类
了解Java集合的,我们知道集合中有个上层接口List,其中有个典型实现类ArrayList
public class ArrayList<E> extends AbstrackList<E>
        implements List<E>, RandomAccess,Cloneable,Java.io.Serializable{}
所以我们可以用instancenof运算符判断某个对象是否是List接口的实现类,如果是返回true,否则返回false
ArrayList arrayList = new ArrayList();
System.out.println(arrayList instanceof List);//true
或者反过来也是返回true
List list = new ArrayList();
System.out.println(list instanceof ArrayList);//true
(5)obj为class类的直接或间接子类
我们新建一个父类Person.class,然后在创建它的一个子类Man.class
public class Person{}
public class Man extends Person{}
测试:
Person p1 = new Person();
Person p2 = new Man();
Man m1 = new Man();
System.out.println(p1 instanceof Man);//false
System.out.println(p2 instanceof Man);//true
System.out.println(m1 instanceof Man);//true
(6)问题
前面我门说过编译器会检查obj是否能转换成右边的class类型.如果不能转换则直接报错,如果不能确定类型,则通过编译,具体看运行时定
看如下几个例子:
Person p1 = new Person();
 
System.out.println(p1 instanceof String);//编译报错
System.out.println(p1 instanceof List);//false
System.out.println(p1 instanceof List<?>);//false
System.out.println(p1 instanceof List<Person>);//编译报错

原理说明:
伪代码如下:
boolean result;
if (obj == null) {
  result = false;
} else {
  try {
      T temp = (T) obj; // checkcast
      result = true;
  } catch (ClassCastException e) {
      result = false;
  }
}
简单来说就是:如果obj不为null并且(T)obj不抛ClassCastException异常则该表达式值为true,否则值为false

#====================================================================
6. 抽象类
6.1 抽象方法
(1)从上面的例子中我们可以看到抽象方法跟普通方法是有区别的,它没有自己的主体(没有{}包起来的业务逻辑),跟接口中的方法有点类似.所以我们没法直接调用抽象方法
(2)抽象方法不能用private修饰,因为抽象方法必须被子类实现(覆写),而private权限对于子类来说是不能访问的,所以就会产生矛盾
(3)抽象方法也不能用static修饰,试想一下,如果用static修饰了,那么我们可以直接通过类名调用而抽象方法压根就没有主体,没有任何业务逻辑,这样就毫无意义了.
6.2 抽象类:
(1)用abstract关键字来表达的类,其表达式形式为:(public) abstract class类型{}
(2)抽象类不能被实例化,也就是说我们没办法直接new一个抽象类.抽象类本身就代表了一个类型,无法确定为一个具体的对象,所以不能实例化就合乎情理了,只能有它的继承类实例化
(3)抽象类虽然不能被实例化,但有自己的构造方法
(4)抽象类与接口(interface)有很大的不同之处,接口中不能有实例方法去实现业务逻辑.而抽象类中可以有实例方法,并实现业务逻辑,比如我们可以在抽象类中创建和销毁一个线程池
(5)抽象类不能使用final关键字修饰,因为final修饰的类是无法被继承,而对于抽象类来说就是需要通过继承去实现抽象方法
6.3 抽象类与抽象方法的关联:
(1)如果一个类中至少有一个抽象方法,那么这个类一定是抽象类,但反之则不然.也就是说一个抽象类中可以没有抽象方法.这样做的目的是为了此类不能被实例化
(2)如果一个类继承了一个抽象类,那么它必须全部复写抽象类中的抽象方法.当然也可以不全部覆写,如果不覆写全部抽象方法则这个类也必须是抽象类(这样就无意义了)

#====================================================================
7. 访问控制符
下面归纳一下Java用于控制可见性的4个访问修饰符:
(1)仅对本类可见---------------private
(2)对所有类可见---------------public
(3)对本包和所有子类可见---------protected
(4)对本包可见-----------------默认(很遗憾),不需要修饰符

#====================================================================
8. Object:所有类的超类
Object类是Java中所有类的始祖,在Java中每个类都是由它扩展而来的.如果没有明确地指出超类,Object就被认为是这个类的超类.
在Java中,只有基本类型不是对象,例如,数值,字符和布尔类型的值都不是对象.所有的数组类型,不管是对象数组还是基本类型的数组都扩展了Object类
C++注释:在C++中没有所有类的根类,不过,每个指针都可以转换成void*指针

#====================================================================
9. Java比较两个对象是否是同一个引用
9.1 euqlas方法
Object类中equals方法用于检测一个对象是否等于另外一个对象.在Object类中,这个方法将判断两个对象是否具有相同的引用.如果两个对象具有相同的引用,它们一定是相等的.

9.2 如果想重写Object对象的equals函数,给出以下方法的建议:
(1)显示参数命名为otherObject,稍后需要将它转换成另一个叫做other的变量
(2)检测this与otherObject是否引用同一个对象:
if(this == otherObject)return true;
这条语句只是一个优化.实际上,这是一种经常采用的形式.因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多
(3)检测otherObject是否为null,如果为null,返回false.这项检测是很必要的
(4)比较this与otherObject是否属于同一个类.如果equals的语义在每个子类中有所改变,就使用getClass检测:
if(getClass() != otherObject.getClass)return false;
如果所有的子类都拥有统一的语义,就使用instanceof检测:
if(!(otherObject instanceof ClassName)) return false;
(5)将otherObject转换为相应的类类型变量:
ClassName other = (ClassName)otherObject;
(6)现在开始对所有需要比较的域进行比较了.使用==比较基本类型域,使用equals比较对象域.如果所有的域都匹配,就返回true;否则返回false;
return filed1 == other.filed1 &&
Object,equals(filed2,other.filed2) &&
...;
(7)如果在子类中重新定义equals,就要在其中包含调用super.equals(other);
补充:对于数组类型的域,可以使用静态的Arrays.equals方法检测相应的数组元素是否相等

9.3 hashCode方法
散列码(hash code)是由对象导出的一个整型值.散列码是没有规律的.如x和y是两个不同的对象引用.x.hashCode()与y.hashCode()基本上不会相同.
由于hashCode方法定义在Object类中,因此每个对象都有一个默认的散列码,其值为对象的存储地址.
String s = "OK";
StringBuilder sb = new StringBuilder(s);
System.out.println(s.hashCode() + "" + sb.hashCode());
String t = new String("OK");
StringBuilder tb = new StringBuilder(t);
System.out.println(t.hashCode() + "" + tb.hashCode());
对象                散列码
s                   2556
sb                  20526976
t                   2556
tb                  20527144

注:如果重新定义equals方法,就必须重新定义hashCode方法,以便用户可以将对象插入到散列表中(有关散列表的内容将在第9章中讨论)
Equals与hashCode的定义必须一致:如果x.equals(y)返回true,那么x.hashCode()就必须与y.hashCode具有相同的值.

9.4 toString()
在Object中还有一个重要的方法,就是toString方法,它用于返回表示对象值的字符串.
Object类定义了toString方法,用来打印输出对象所属的类名和散列码

#====================================================================
10. 泛型数组列表ArrayList
一旦能够确定数组列表的大小不在发生变化,就可以调用trimToSize方法.这个方法将存储区域的大小调整为当前元素数量所需的存储空间数目.垃圾回收器将回收多余的存储空间.一旦整理了数组列表的大小,添加新元素就需要花时间再次移动存储快,所以应该在确认不会添加任何元素时,在调用trimToSize.
C++注释:ArrayList类似于C++的Vector模板.ArrayList与vector都是泛型类型.但是C++的vector模板为了便于访问元素重载了[]运算符.由于Java没有运算符重载,所以必须调用显示的方法.此外C++向量是值拷贝.如果a和b是两个向量,赋值操作a=b将会构造一个与b长度相同的新向量a,并将所有的元素由b拷贝到a,而在Java中,这条赋值语句的操作结果是让a和b引用同一个数组列表

10.1 访问数组列表元素
(1)void set(int index, E obj)
设置数组列表指定位置的元素值,这个操作将覆盖这个位置的原有内容.
(2)E get(int index)
获得指定位置的元素值
(3)void add(int index,E obj);
向后移动元素,以便插入元素
(4)E remove(int index)
删除一个元素,并将后面的元素向前移动.被删除的元素由返回值返回

10.2 类型化与原是数组列表的兼容性
public class EmployeeDB {
    public void update(ArrayList list) {...}
    public ArrayList fine(String query) {...}
}
可以将一个类型化的数组列表传递给update方法,而并不需要进行任何类型转换
ArrayList<EmployeeDB> staff = ...;
employeeDB.update(staff);
这种情况编译器没有给出任何错误信息或警告,但是这样调用并不太安全.在update方法中,添加到数组列表中的元素可能不是Employee类型,在对这些元素进行检索时就会出现异常.
相反的,将一个原始ArrayList赋给一个类型化ArrayList会得到一个警告.
ArrayList<Employee> result = employee.find(query); //yields warning
注释:为了能够看到警告性错误的文字信息,要将编译选项设置为-Xlint:unchecked
使用类型转换并不能避免出现警告
ArrayList<Employee> result = (ArrayList<EmployeeDB>employeeDB.find(query);//yileds another warning
这样,将会得到另外一个警告信息,指出类型转换有误
一旦确保不会造成严重的后果,可以使用@SupportWarnings("uncheked");标注来标记这个变量能够接受类型转换,如下所示:
@SuppressWarnings("unchecked");ArrayList<EmployeeDB> result = (ArrayList<Employee>)employee.find(query);//yeild another warning

#====================================================================
11. 对象包装器与自动装箱
有时,需要将int这样的基本类型转换为对象.所有的基本类型都有一个与之对应的类.例如,Integer类对应基本类型int.通常,这些类称为包装器(wrapper).这些对象包装器类拥有很明显的名字:Integer,Long,Float,Double,Short,Byte,Character,Void和Boolean(前六个派生于公共的超类Number).对象包装器类是不可变的,即一旦构造了包装器,就不允许更改包装在其中的值.同时,包装器类还是final,因此不能定义它们的子类.
幸运的是,有一个很有用的特性,从而更加便于添加int类型的元素到ArrayList<Integer>中,下面这个调用
list.add(3); 将自动地变换成 list.add(Integer.valueOf(3));
这种变换被称为自动装箱(autoboxing).相反的,当将一个Integer对象赋给一个int值时,将会自动地拆箱.也就是说,编辑器将下列语句:
int n = list.get(i);翻译成 int n = list.get(i).intValue();
注释:自动装箱规范要求boolean,byte,char小于等于127,介于-128 ~ 127之间的short和int被包装到固定的对象中.
Integer对象是不可变的:包含在包装器中的内容不会改变.不能使用这些包装器类纯碱修改数值参数的方法.
如果想编写一个修改数值参数值的方法,就需要使用在org.omg.CORBA包中定义的持有者(holder)类型,包括IntHolder,BooleanHolder等.每个持有者类型都包含一个公有(!)域值,通过它可以范文存储在其中的值.

#====================================================================
12 参数数量可变的方法
伪代码:
public Class PrintStream {
    public PrintStream printf(String fmt, Object... args){
        return format(fmt,args);
    }
}
这里的省略号...是Java代码的一部分,它表明这个方法可以接受任意数量的对象(除fmt参数之外)
用户自己也可以定义可变参数的方法,并将参数指定为任意类型,甚至是基本类型.下面是一个简单的示例:
public static double max(double... values) {
    double largest = Double.NEGATIVE_INFINITY;
    for(double v : values)if (v > largest) largest = v;
    return largest;
}
可以像下面这样调用这个方法:
double m = max(3.1,40.4,-5);
编译器将new double[] {3.1,40.4,-5}传递给max方法.

#====================================================================
13. 枚举类
示例:public enum Size{SMALL,MEDIUM,LARGE.EXTRA_LARGE};
实际上,这个声明定义的类型是一个类,它刚好有4个实例,再此尽量不要构造新对象.因此,在比较两个枚举类型的值时,永远不需要调用equals,而直接使用"=="就可以了.
如果需要的话,可以在枚举类型中添加一些构造器,方法和域.
public enum Size {
    SMALL("S"),MEDIUM("M"),LARGE("L"),EXTRA_LARGE("XL");

    private String abbreviation;

    private Size(String abbreviation){this.abbreviation = abbreviation}
    private String getAbbreviation() {return abbreviation}
}
所有的枚举类型都是Enum类的子类.它们继承了这个类的许多方法.其中最有用的一个是toString,这个方法能够返回枚举常量名.例如Size.SMALL.toString()将返回字符串"SMALL"
(1) static Enum valueof(Class enumClass,String name)
返回指定名字,给定类的枚举常量
(2)String toString()
返回枚举常量名
(3)int ordinal()
返回枚举常量在enum声明中的位置,位置从0开始计数.
(4)int compareTo(E other)
如果枚举常量出现在other之前,则返回一个负值;如果this == other,则返回一个负值;如果this==other,则返回0;否则,返回正值.枚举常量的出现次序在enum声明中给出.

#====================================================================
14. 反射
能够分析类能力的程序称为反射(reflective).反射机制可以用来:
(1)在运行时分析类的能力
(2)在运行时查看对象,例如,编写一个toString方法供所有类使用.
(3)实现通用的数组操作代码
(4)利用Method对象,这个对象很像C++中的函数指针

14.1 Class类
在程序运行期间,Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识.这个信息跟踪着每个对象所属的类.
一个Class对象实际上表示的是一个类型,而这个类型未必一定是一种类.
虚拟机为每个类型管理一个Class对象.因此,可以利用==运算符实现两个类对象比较的操作.例如
if(e.getClass() == Employee.class)....;
还有一个很有用的方法newInstance(),可以用来动态地创建一个类的实例.例如:
e.getClass().newInstance();
创建了一个与e具有相同类型的实例.newInstance方法调用默认的构造器(没有参数的构造器)初始化新创建的对象.如果这个类没有默认的构造器,就会抛一个异常.
将forName与newInstance配合起来使用,可以根据存储在字符串中的类名创建一个对象.
String s = "java.util.Random";
Object m = Class.froName(s).newInstance();
注:如果需要以这种方式向希望按名称创建的类的构造器提供参数,就不要使用上面那条语句,而必须使用Constructor类中的newInstance方法

14.2 利用反射分析类的能力
在java.lang.reflect包中有三个类Field,Method和Constructor分别用于描述类的域,方法和构造器.这三个类都有一个getModifiers的方法,它将返回一个整型数值,用不同的位开关描述public和static这样的修饰符使用状况.另外还可以使用java.lang.reflect包中的Modifier类的静态方法分析getModifiers返回的整型数值.
Class类中的getFields,getMethod和getConstructors方法将分别返回类提供的public域,方法和构造器数组,其中包括超类的公有成员.Class类的getDeclareFields.getDeclareMethods和getDeclaredConstructors方法将分别返回类中声明的全部域,方法和构造器,其中包括私有成员和受保护成员,但不包括超类的成员

14.3 在运行时使用反射分析对象
查看对象域(成员变量)的关键方法是Field类中的get方法.示例如下:
Employee harry = new Employee("Harry Hacker", 35000,10,1,1989);
Class cl = harry.getClass();
Filed f = cl.getDeclaredField("name");
Object v = f.get(harry);
这段代码存在一个问题.由于name是一个私有域,所以get方法将会抛出一个IllegalAccessException.反射机制的默认行为受限于Java的访问控制.为了达到这个目的,需要调用Field,Method或Constructor对象的setAccessible方法.
setAccessible方法是AccessibleObject类中的一个方法,它是Field,Method和COnstructor类的公共超类.这个特性是为调试,持久存储和相似机制提供的

14.4 使用反射编写泛型数组代码
java.lang.reflect包中的Array类允许动态地创建数组.使用反射编写伪代码示例如下:
public static Object goodCopyOf(Object a, int lenghth) {
    Class cl = a.getClass();
    if(!cl.isArray()) return null;
    Class componenType = cl.getCompoentType();
    int lenght = Array.getLenght(a);
    Object newArray = Array.newInstance(componenType,newLenght);
    System.arraycopy(a,0,newArray,0,Math.min(lenght,newLenght));
    return newArray;
}
这个CopyOf方法可以用来扩展任意类型的数组,而不仅是对象数组.
int[] a = {1,2,3,4,5};
a = (int[])goodCopyOf(a,10);
为了能够实现上述操作,应该将goodCopyOf的参数声明为Object类型,而不要声明为对象数组(Object[]).整型数组类型int[]可以被转换成Object,但不能转换成对象数组.

14.5 调用任意方法
示例:
Method m1 = Employee.class.getMethod("getName");
Method m2 = Employee,class.getMethod("raiseSalary",double.class);
String n = (String)m1.invoke(harry);
double s = (Double)m2.invoke(harry);

#====================================================================
15. 继承的设计技巧
(1).将公共操作和域放在超类
(2).不要使用受保护的域
(3).使用继承实现"is-a"关系
(4).除非所有继承的方法都有意义,否则不要使用继承
(5).在覆盖方法时,不要改变预期的行为
(6).使用多态,而非类型信息
(7).不要过多的使用反射.反射是很脆弱的,即编译器很难帮助人们发现程序中的错误,因此只有在运行时才发现错误并导致异常.

#====================================================================
第六章 接口,lambda表达式与内部类
#====================================================================
1. 接口
Arrays类中的sort方法承诺可以对对象数组进行排序,但要求满足下列前提:对象所属的类必须实现了Comparable接口
下面是Comparable接口代码:
public interface Comparable<T> {
    int cpmpareTo(T other);//parameter has type T
}
在接口声明中,没有将compareTo方法声明为public,这是因为在接口中的所有方法都自动地是public.不过,在实现接口时,必须把方法声明为public;否则,编辑器将认为这个方法的访问属性是包可见性,即类的默认访问属性,之后编译器就会给出试图提供更严格的方位权限的警告信息

1.1 接口的特性
(1)接口不是类,尤其不能使用new运算符实例化一个接口:
x = new Comparable{...}//ERROR
(2)如同使用instanceof检查一个对象是否属于某个特定类一样,也可以使用instance检查一个对象是否实现了某个特定的接口:
if(anObject instanceof Comparable){...}
(3)与可建立类的继承关系一样,接口也可以被扩展.这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链.例如:
public interface Moveable {
    void move(double x, double y);
}
然后,可以以它为基础扩展一个叫做Powered的接口:
public interface Powered extends Moveable {
    double milesPerGallon();
}
虽然接口中不能包含实例域或静态方法,但却可以包含常量.例如:
public interface Powered extends Moveable {
    double milesPerGallon();
    double SPEED_LIMIT = 95;//a public static final constant
}
与接口中的方法都自动地被设置为public一样,接口中的域将被自动设为 public static final.但Java语言规范却建议不要书写这些多余的关键字

注:如果希望自己设计的类拥有克隆和比较的能力,只要实现这两个接口就可以了.使用逗号将实现的各个接口分隔开.
class Employee implements Cloneable,Comarable {}

1.2 默认方法
可以为接口方法提供一个默认实现.必须用default修饰符标记这样一个方法
public interface Comparable<T> {
    default int compareTo(T other){ return 0; }
    //By default,all elements are the same
}
默认方法的一个重要的用法是"接口演化"详情见书P220页

1.3 解决默认方法冲突
如果现在一个接口中将一个方法定义为默认方法,然后又在超类或另一个接口中定义了同样的方法,会发生什么情况呢?
规则如下:
(1)超类优先.如果超类提供了一个具体方法,同名而且有相同参数类型的默认方法会被忽略
(2)接口冲突.如果一个超接口提供了一个默认方法,另一个接口提供了一个同名而且参数类型(不论是否是默认参数)相同的方法,必须覆盖这个方法来解决冲突.
下面来看第二个规则.考虑另一个包含getName方法的接口
interface Named {
    default String getName() {return getClass.getName + "_" + hashCode();}
}
interface Person {
    default String getName() {return getClass.getName + "_" + hashCode();}
}
如果有一个类同时实现了这两个接口会怎么样呢?
class Student implements Person,Named {
    ...
}
类会继承Person和Named接口提供的两个不一致的getName方法,并不是从中选择一个,Java编译器会报告一个错误,让程序员来解决这个二义性.只需要在Student类中提供一个getName方法.在这个方法中,可以选择两个冲突方法中的一个,如下所示:
class Student implements Person,Named {
    public String getName() { return Person.super.getName(); }
}
如果Named接口没有为getName提供默认实现:
interface Named {
    String getName();
}
Student类也不会从Person接口继承默认方法.Java设计者更强调一致性.两个接口如何冲突并不重要.如果至少有一个接口提供了一个实现,编译器就会报告错误,而程序员就必须解决这个二义性.
如果两个接口都没有为共享方法提供默认实现,那么继承类必须实现接口方法.
现在来考虑另一种情况,一个类扩展了一个超类,同时实现了一个接口,并从超类和接口继承了相同的方法.例如,Person是一个类,Student定义为:
class Student extends Person implements Named{...}
在这种情况下,只会考虑超类方法,接口的所有默认方法都会被忽略.Student从Person继承了getName方法,Named接口是否为getName提供了默认实现并不会带来什么区别.这正是"类优先"规则."类优先"规则可以确保与Java SE 7的兼容性.如果为一个接口增加默认方法,这对于有这个默认方法之前能正常工作的代码不会有任何影响.
警告:千万不要让一个默认方法重新定义Object类中的某个方法.由于"类优先"规则,这样的方法绝对无法超越Object,toString或Object.equals.

#====================================================================
2. 对象克隆
原变量和副本都是同一个对象的引用.这说明,任何一个变量改变都会影响另一个变量.
clone方法是Object的一个protected方法,这说明你的代码不能直接调用这个方法.只有Employee类可以克隆Employee对象.这个限制是有原因的.现象看Object类如何实现clone.它对于这个对象一无所知,所以只能逐个域地进行拷贝.如果对象中的所有数据域都是数值或其他基本类型,拷贝这些域没有任何问题.但是如果对象包含子对象的引用,拷贝域就会得到相同子对象的另一个引用,这样一来,原对象和克隆的对象仍然会共享一些信息.
默认的克隆操作是"浅拷贝",并没有克隆对象中引用的其他对象.浅拷贝就是说对象中包含的其他对象在拷贝过程中仍是之前对象的引用,改变这个引用也会影响到之前对象的引用.并没有将clone对象和原对象完全隔离开.
浅拷贝会有什么影响么?如果原对象和浅克隆对象共享的子对象是不可变的,如String,就是这种情况.或者在对象的生命期中,子对象一直包含不变的常量,没有更改器会改变它,也没有办法会生成它的引用,这种情况下同样是安全的.
通常子对象都是可变的,必须重新定义clone方法来建立一个深拷贝,同时克隆所有子对象.
对于每一个类,需要确定:
(1)默认的clone方法是否满足要求;
(2)是否可以在可变的子对象上调用clone来修补默认的clone方法
(3)是否不该使用clone
实际上第3个选项是默认选项.如果选择第1项或第2项,类必须:
(1)实现Cloneable接口:
(2)重新定义clone方法,并指定public访问修饰符.
在这里,Cloneable接口的出现与接口的正常使用并没有关系.具体来说,它没有指定clone方法,这个方法是从Object类继承的.这个接口只是作为一个标记,指示类设计者了解克隆过程.对象对于克隆很"偏执",如果一个对象请求克隆,但没有实现这个接口,就会生成一个检查异常.

#====================================================================
3. lambda表达式
https://blog.csdn.net/weixin_37766087/article/details/94999833
lambda表达式是一个可传递的代码块,可以在以后执行一次或多次.

3.1 lambda表达式的语法
(1)Java中的一种lambda表达式形式:参数,箭头(->)以及一个表达式.如果代码要完成的计算无法放在一个表达式中,就可以像写方法一样,把这些代码放在{}中,并包含显式的return语句.例如:
(String first, String second) -> 
{
    if(first.lenght() < second.lenght()) return -1;
    else if (first.lenght() > second.lenght()) return 1;
    else return 0;
}

(2)即使lambda表达式没有参数,仍然要提供空括号,就像无参方法一样:
() -> {for(int i= 0 ; i < 10; i++) System.out.println(i);}

(3)如果可以推导出一个lambda表达式的参数类型,则可以忽略其类型.例如:
Comparator<String> comp 
    = (first, second)//Same as (String first, String second)
        ->first.lenght() - second.lenght();
在这里,编译器可以推导出first和second必然是字符串,因为这个lambda表达式将赋给一个字符串比较器(下一节会更详细地分析这个赋值)

(4)如果方法只有一个参数,而且这个参数的类型可以推倒得出,那么甚至还可以省略小括号:
ActionListener listener = event->
    System.out.println("The time is " + new Date());
    //Instead of (event)-> ... or (ActionEvent event)->...
无需指定lambda表达式的返回类型.lambda表达式的返回类型总是会由上下文推到得出.

注:如果一个lambda表达式只在某些分之返回一个值,而在另外一些分之不返回值,这是不合法的.例如,(int x)->{if(x>=0 )return 1;}就不合法;

3.2 函数式接口
对于只有一个抽象方法的接口,需要这种接口的对象时,就可以提供一个lambda表达式.这种接口称为函数式接口(function interface).
实际上,在Java中,对lambda表达式所能做的也只是能转换为函数式接口.在其他支持函数字面量的程序设计语言中,可以声明函数类型(如(String,String)->int),声明这些类型的变量,还可以使用变量保存函数表达式,不过,Java设计者还是决定保持我们熟悉的接口概念,没有为Java语言增加函数类型.
注释:甚至不能把lambda表达式赋给类型为Object的变量,Object不是一个函数式接口.
Java API在java.util.function包中定义了很多非常通用的函数式接口.其中一个接口BiFunction<T,U,R>描述了参数类型为T和U而且返回类型为R的函数.可以把我们的字符串比较lambda表达式保存在这个类型的变量中:
BiFunction<String,String,Integer>comp 
    = (first,second)->first.lenght() - second.lenght();
想要用lambda表达式做某些处理,还是要谨记表达式的用途,为它建立一个特定的函数式接口.
java.util.function包中有一个尤其有用的接口Predicate;
public interface Predicate<T> {
    boolean test(T t);
    //Additional default and static methods
}
ArrayList类有一个removeif方法,它的参数就是一个Predicate.这个接口专门用来传递lambda表达式.例如,下面的语句将从一个数组列表删除所有null值:
list.removeIf(e->e==null);

3.3 变量作用域
通常,你可能希望能够在lambda表达式中访问外围方法或类中的变量.考虑下面这个例子:
public static void repeatMessage(String text, int delay) {
    ActionListener listener = event -> {
        System.out.println(text);
        Toolkit.getDefaultToolkit().beep();
    }
    new Timer(delay, listener).start();
}
//调用,Prints Hello every 1,000 milliseconds
repeatMessage("Hello",1000);
从上述例子看:
lambda表达式的代码可能会在repeatMessage调用返回很久以后才运行,而那时这个参数变量已经不存在了.如何保留text变量呢?
lambda表达式有3个部分:
(1)一个代码块;
(2)参数;
(3)自由变量的值,这是指非参数而且不在代码中定义的变量
这个lambda表达式有1个自由变量text.表示lambda表达式的数据结构必须存储自由变量的值,在这里就是字符串"Hello".我们说它被lambda表达式捕获(captured)
可以看到,lambda表达式可以捕获外围作用域中变量的值.在Java中,要确保所捕获的值是明确定义的,这里有一个重要的限制.在lambda表达式中,只能引用值不会改变的变量.例如,下面的做法是不合法的:
public static void countDown(int start, int delay) {
    ActionListener listener = event-> {
        start--;//Error:Can not mutate captured variable
        System.out.println(start);
    };
    new Timer(delay,listener).start();
}
之所以有这个限制是有原因的.如果在lambda表达式中改变变量,并发执行多个动作时就会不安全.
另外如果在lambda表达式中引用变量,而这个变量可能在外部改变,这也是不合法的.例如,下面就是不合法的:
public static void repeat(String text, int count) {
    for(int i = 1; i < count; i++) {
        ActionListener listener = event-> {
            System.out.println(i + ":" +text);
            //Error:Can not refer to changing i
        }
        new Timer(1000,listener).start();
    }
}
这里有一条规则:lambda表达式中捕获的变量必须实际上是最终变量(effectively final).实际上的最终变量是指,这个变量初始化之后就不会再为它赋新值.在这里,text总是指示同一个String对象,所以捕获这个变量是合法的.不过,i的值会改变,因此不能捕获i;
lambda表达式的体与嵌套块有相同的作用域.这里同样适用命名冲突和遮蔽的有关规则.在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的.
在一个lambda表达式中使用this关键字时,是指创建这个lambda表达式的方法的this参数.例如,考虑下面的代码
public class Application {
    public void init() {
        ActionListener listener = event-> {
            System.out.println(this.toString());
            ...
        }
        ...
    }
}
表达式this.toString()会调用Application对象的toString方法,而不是ActionListener实例的方法.在lambda表达式中,this的使用并没有任何特殊之处.lambda表达式的作用域嵌套在init方法中,与出现在这个方法中的其他位置一样,lambda表达式中this的含义并没有变化.

3.4 处理lambda表达式
使用lambda表达式的重点是延迟执行(deferred execution).毕竟,如果想要立即执行代码,完全可以直接执行,而无需把它包装在一个lambda表达式中.之所以希望以后在执行代码,这有很多原因,如:
(1)在一个单独的线程中运行代码;
(2)多次运行代码;
(3)在算法的释放位置运行代码(例如,排序中的比较操作);
(4)发生某种情况时执行代码(如,点击了一个按钮,数据到达,等等)
(5)只在必要时才运行代码
下面来看一个简单的例子.假设你想要重复一个动作n次.将这个动作和重复次数传递到一个repeat方法:
要接受这个lambda表达式,需要选择(偶尔可能需要提供)一个函数式接口.在这里,我们可以使用Runnable接口:
public static void repeat(int n, Runable action) {
    for(int i = 0; i < n; i++) action.run();
}
现在让这个例子更复杂一些.我们希望告诉这个动作它出现在哪一次迭代中.为此,需要选择一个合适的函数式接口,其中要包含一个方法,这个方法有一个int参数而且返回类型为void,处理int值的标准接口如下:
public interface IntConsumer {
    void accept(int value);
}
下面给出repeat方法的改进版本:
public static void repeat(int n, IntConsumer action) {
    for(int i = 0; i < n; i++)action.accept(i);
}
可以如下调用它:
repeat(10,i-> System.out.println("Countdown: " + (9-i)));
注:如果设计你自己的接口,其中只有一个抽象方法,可以用@FunctionalInterface注解来标记这个接口.这样做有两个优点.如果你无意中增加了两一个非抽象方法,编译器会产生一个错误消息.另外javadoc页里会指出你的接口是一个函数式接口.

#====================================================================
4. 方法引用
有时,可能已经有现成的方法可以完成你想要传递到其他代码的某个动作.
你希望值要出现一个定时器时间就打印这个时间对象.当然,为此也可以调用:
Timer t = new Timer(1000, event->System.out.println(event));
但是,如果直接把println方法传递到Timer构造器就更好了.具体做法如下:
Timer t = new Timer(1000,System.out::printfln);
表达式System.out::println是一个方法引用(method reference),它等价于lambda表达式x->System.out.println(x);
再来看一个例子,假设你想对字符串排序,而不考虑字母的大小写.可以传递一下方法表达式:
Arrays.sort(strings,String::compareToIgnoreCase);
从这些例子可以看出,要用::操作符分隔方法名与对象或类名.主要有3种情况:
(1)object::instanceMethod
(2)Class::staticMethod
(3)Class::instanceMethod
在前面2种情况中,方法引用等价于提供方法参数的lambda表达式.前面已经提到System.out.println等价于x->System.out.println(x).类似地,Math::pow等价于(x,y)->Math.pow(x,y);
对于第三种情况,第1个参数会称为方法的目标.例如,String::compareToIgnoreCase等同于(x,y)->x.compareToIgnoreCase(y).
注:如果有多个同名的重载方法,编译器就会尝试从上下文中找出你指的哪一个方法.例如,Math.max方法有两个版本,一个用于整数,另一个用于double值.选择哪一个版本取决于Math::max转换为哪个函数式接口的方法参数.类似于lambda表达式,方法引用不能独立存在,总是会转换为函数式接口的实例.
可以在方法引用中使用this参数.例如,this::equals等同于x->this.equals(x).使用super也是合法的.下面的方法表达式
super::instanceMethod
使用this作为目标,会调用给定方法的超类版本.下面给出一个假象的例子:
class Greeter {
    public void greet() {
        System.out.println("Hello,world!");
    }
}
class TimedGreeter extends Greeter {
    public void greet() {
        Timer t = new Timer(1000, super::greet);
        t.start();
    }
}
TimedGreeter.greet方法开始执行时,会构造一个Timer,它会在每次定时器滴答时执行super::greet方法.这个方法会调用超类的greet方法.

#====================================================================
5. 构造器引用
构造器引用与方法引用很类似,只不过方法名为new.例如,Person::new是Person构造其的一个引用.哪一个构造器呢?这取决于上下文.假设你有一个字符串列表.可以把它转换为一个Person对象数组.为此要在各个字符串上调用构造器,调用如下:
ArrayList<String> names = ...;
Stream<Person> stream = names.stream().map(Person::new);
List<Person> people = stream.collect(Collectors.toList());
分析:map方法会为各个列表元素调用Person(String)构造器.如果有多个Person构造器,编译器会选择有一个String参数的构造器,因为它从上下文推导出这是在对一个字符串调用构造器.
可以用数组类型建立构造器引用.例如,int[]::new是一个构造器引用,它有一个参数:即数组的长度.这等价于lambda表达式 x->new int[x].
Java有一个限制,无法构造泛型类型T的数组.数组构造器引用对于客服这个限制很有用.表达式new T[n]会产生错误,因为这会改为new Object[n].对于开发类库的人来说,这是一个问题.例如,假设我们需要一个Person对象数组.Stream接口有一个toArray方法可以返回Object数组:
Object[] people = steam.toArray();
不过,这并不让人满意.用户希望得到一个Person引用数组,而不是Object引用数组.流库利用构造器引用解决了这个问题.可以把Person[]::new传入toArray方法:
Person[] people = stream.toArray(Person[]::new);
toArray方法调用这个构造器来得到一个正确类型的数组.然后填充这个数组并返回.

#====================================================================

6. 内部类
内部类是定义在另一个类中的类,为什么需要使用内部类呢?其主要原因有一下三点:
(1)内部类方法可以访问该类定义所在的作用域中的数据,包括私有的数据
(2)内部类可以对同一个包中的其他类隐藏起来.
(3)当想要定义一个回调函数且不想编写大量代码时,使用匿名(anonymous)内部类比较便捷
C++注释:C++有嵌套类.一个被嵌套的类包含在外围类的作用域内.下面是一个类型的例子,一个链表类定义了一个存储节点的类和一个定义迭代器位置的类.
class LinkedList {
public:
    class Iterator //a nested class 
    {
    public:
        void insert(int x);
    };
private:
    class Link // a nested class
    {
    public:
        Link* next;
        int data;
    };
};
嵌套类是一种类之间的关系,而不是对象之间的关系.一个LinkedList对象并不包含Iterator类型或Link类型的子对象.
嵌套类有两个好处:命名控制和访问控制.由于名字Iterator嵌套在LinkedList类的内部,所以在外部被命名为LinkedList::Iterator,这样就不会与其他名为Iterator的类发生冲突.在Java中这个并不重要,因为Java包已经提供了相同的命名控制.需要注意的是,Link类位于LinkedList类的私有部分,因此,Link对其他的代码均不可见.鉴于此情况,可以将Link的数据域设计为公有的,它仍然是安全的.这些数据域只能被LinkedList类(具有访问这些数据域的合理需要)中的方法访问,而不会暴露给其他的代码.在Java中,只有内部类能够实现这样的控制.
然而,Java内部类还有另外一个功能,这是的它比C++的嵌套类更加丰富,用途更加广泛.内部类的对象有一个隐式引用,它引用了实例化该内部对象的外围类对象.通过这个指针,可以访问外围类对象的全部状态.在Java中,static内部类没有这种附加指针,这样的内部类与C++中的嵌套类很相似.

6.1 使用内部类访问对象状态
外围类的引用在内部类的构造器中设置.编译器修改了所有的内部类的构造器,添加一个外围类引用的参数.
内部类示例:
public class Talking {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beeo){...}
    public void start(...);
    public class TimerPrint implements ActionListener {
        public void actionPerformed() {
            ...
    }
}
注释:TimePrinter类声明为私有的.这样一来,只有TalkingClock的方法才能够构造TimePrinter对象.只有内部类可以是私有的,而常规类值可以具有可见性,或公有可见性

6.2 内部类的特殊语法规则
事实上,使用外围类引用的正规语法还要复杂一些,表达式
OuterClass.this(表示外围类引用)
例如:可以像下面这样编写TimePrinter内部类的actionPerformed方法:
public void actionPerformed() {
    ...
    if(Talking.this.beep)
        return;
}
反过来,可以采用下列语法格式更加明确地编写内部对象的构造器:
    outerObjec.new InnerClass(construction parameters)
例如:
ActionListener Listener = this.new TimerPrint();
通常,this限定词是多余的.不过,可以通过显式地命名将外围引用设置为其他的对象.例如,如果TimerPrint是一个公有内部类,对于任意的语音始终都可以构造一个TimerPrint:
Talking tk = new Talking();
Talking.TimerPrint listener = tk.new TimerPrint();
需要注意,在外围类的作用域之外,可以这样引用内部类:
OuterClass.InnerClass;
注释:内部类中声明的所有静态域都必须是final的.原因很简单.我们希望一个静态域只有一个实例,不过对于每个外部对象,会分别有一个单独的内部类实例.如果这个域不是final,它可能就不是唯一的.
内部类不能有static方法.Java语言规范对这个限制没有做任何解释.也可以允许有静态方法,但只能访问外围类的静态域和方法.显然,Java设计者认为相对于这种复杂性来说,它带来的好处有些得不偿失

6.3 局部内部类
如果仔细阅读一下TalkingClock(P246页)示例代码就会发现,TimePrinter这个类名字只在start方法中创建这个类型的对象时使用了一次.当遇到这类情况时,可以在一个方法中定义局部类.
public void start() {
    class TimePrinter implementes ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println("At the tone, the time is" + new Data());
            if(beep) Toolkit.getDefaultToolkit().beep();
        }
    }

    ActionListener listener = new TimerPrinter();
    Timer t = new Timer(interval,listener);
    t.start();
}
局部类不能用public或private访问说明符进行声明.它的作用域被限定在声明这个局部类的快中.
局部类有一个有时,即对外部世界可以完全地隐藏起来.即使TalkingClock类中的其他代码也不能访问它.除start方法之外,没有任何方法知道TimerPrinter类的存在.

6.3.1 由外部方法访问变量
与其他内部类相比较,局部类还有一个有点.它们不仅能够访问包含它们的外部类,还可以访问局部变量.不过,那些局部变量必须事实上为final.
局部类的方法只可以引用定义为final的局部变量.鉴于此情况,在列举的实例中,将beep参数声明为final,对它进行初始化后不能够在进行修改.因此,就使得局部变量与局部类内建立的拷贝保持一致.
注释:在JavaSE8之前,必须把从局部类访问的局部变量声明为final.例如,start方法原本应当这样声明,从而使内部类能够访问beep参数:
public void start(int interval,final boolean beep);
有时,final限制显得并不太方便.例如,假设想更新在一个封闭作用域内的计数器.这里想要统计一下排序过程中调用compareTo方法的次数.
int counter = 0;
Date[] dates = new Data[100];
for(int i= 0; i < dates.lenght; i++) {
    dates[i] = new Date() {
        public int compareTo(Date other) {
            counter++; //error
            return super.compareTo(other);
        };
    }
}
由于清楚地知道counter需要更新,所以不能将counter声明为final.由于Interger对象是不可变的,所以也不能用Interger代替它.补救的方法是使用一个长度为1的数组:
int[] counter = new int[i];
for(int i = 0; i < dates.lenght; i++) {
    dates[i] = new Date() {
        counter[0]++; //error
        return super.compareTo(other);
    };
}

6.4 匿名内部类
加入只创建这个类的一个对象,就不必命名了.这种类被称为匿名内部类(anonymous inner class)
通常的语法格式为:
new SuperType(construction parameters) {
    inner class methods and data
}
其中,SuperType可以使ActionListener这样的接口,于是内部类就要实现这个接口.SuperType也可以是一个类,于是内部类就要扩展它.

注释:下面的技巧称为"双括号初始化",这里利用了内部类语法.假设你想构造一个数组列表,并将它传递到一个方法:
ArrayList<String> friends = new ArrayList<>();
friends.add("Harry");
friends.add("Tony");
invite(friends);
如果不需要这个数组列表,最好让它作为一个匿名列表.不过作为一个匿名列表,该如何为它添加元素呢?方法如下:
invite(new ArrayList<String>() {{add("Harry");add("Tony");}});

6.5 静态内部类
有时候,使用内部类只是为了把一个类隐藏在另外一个类的内部,并不需要内部类引用外围类对象.为此,可以将内部类声明为static,以便取消产生的引用.
静态内部类的对象除了没有对生成它的外围类对象的引用特权外,与其他所有内部类完全一样.在我们列举的示例中,必须使用静态内部类,这是由于内部类对象是在静态方法中构造的:
public static Pair minmax(double[] d) {
    ...
    return new Pair(min,max);
}
如果没有将Pair类声明为static,那么编译器将会给出错误报告:没有可用的隐式ArrayAlg类型对象初始化内部类对象

注释:
(1)在内部类不需要访问外围类对象的时候,应该使用静态内部类.有些程序员用嵌套类表示静态内部类
(2)与常规内部类不同,静态内部类可以有静态域和方法
(3)声明在接口中的内部类自动成为static和public类

#====================================================================
7. 代理
利用代理可以在运行时创建一个实现了一组给定接口的新类.这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用.
不做过多解释详见(P259页)

#====================================================================
第七章 异常,断言和日志
#====================================================================
1.异常分类
所有的异常都是由Throwable继承而来,但在下一层立即分解为两个分之:Error和Exception.Error层次结构描述了Java运行时系统的内部错误和资源耗尽错误.应用程序不应该抛出这种类型的对象.
在设计Java程序时,需要关注Exception层次结构.这个层次结构又分解为两个分之:一个分之派生于RuntimeException;另一个分之包含其他异常.划分两个分之的规则是:由程序错误导致的异常属于RuntimeException;而程序本身没有问题,但由于像I/O错误这类问题导致的异常属于其他异常.
派生于RuntimeException的异常包含下面几种情况:
(1)错误的类型转换
(2)数组访问越界.
(3)访问null指针
不是派生于RuntimeException的异常包括:
(1)试图在文件尾部后面读取数据;
(2)试图打开一个不存在的文件
(3)试图根据指定的字符串查找Class对象,而这个字符串表示的类并不存在

C++注释:如果熟悉标准C++类库中的异常层次结构,就一定会感到有些困惑.C++有两个基本的异常类,一个是runtime_error;另一个是logic_error.logic_error类相当于Java中的RuntimeException,它表示程序中的逻辑错误;runtime_error类是所有由于不可预测的原因所引发的异常的基类.它相当于Java中的非RuntimeException异常. 

#====================================================================
2. 声明受查异常
在自己编写方法时,不必将所有可能抛出的异常都进行声明.以下4种情况时应该抛出异常:
(1)调用一个抛出受查异常的方法,例如,FileInputStream构造器
(2)程序运行过程中发现错误,并且利用throw语句抛出一个受查异常
(3)程序出现错误,例如,a[-1]=0会抛出一个ArrayIndexOutOfBoundsException这样的非受查异常.
(4)Java虚拟机和运行时库出现的内部错误
如果没有处理器捕获这个异常,当前执行的线程就会结束.
注释:如果在子类中覆盖了超类的一个方法,子类方法中声明的受查异常不能比超类方法中声明的异常更通用(也就是说,子类方法中可以抛出更特定的异常,或者根本不抛出任何异常).特别需要说明的是,如果超类方法没有抛出任何受查异常,子类也不能抛出任何受查异常.例如,如果覆盖JComponent.paintComponent方法,由于超类中这个方法没有抛出任何异常,所以自定义的paintComponent也不能排除任何受查异常.
C++注释:Java中throws说明符与C++中的throw说明符基本类似,但有一点重要的区别.在C++中,throw说明符在运行时执行,而不是在编译时执行.也就是说,C++编译器将不处理任何异常规范.但是,如果函数抛出的异常没有出现在throw列表中,就会调用unexpected函数,这个函数的默认处理方式是终止程序的执行.另外,在C++中,如果没有给出throw说明,函数可能会抛出任何异常.而在Java中,没有throws说明符的方法将不能抛出任何受查异常.

#====================================================================
3. 创建异常类
我们需要做的只是定义一个派生于Exception的类,或者派生于Exception子类的类.
示例:
class FileFormatException extends IOException {
    public FileFormatException() {}
    public FileFormatException(String gripe) {
        super(gripe);
    }
}

#====================================================================
4. 捕获异常
想要捕获一个异常,必须设置try/catch语句块.
请记住,编译器严格地执行throws说明符.如果调用了一个抛出受异常的方法,就必须对它进行处理,或者继续传递.
通常,应该捕获那些知道如何处理的异常,而将那些不知道怎么处理的异常继续进行传递.
异常对象可能包含与异常本身有关的信息.要想获得对象的更多信息,可以试着使用e.getMessage();
得到详细的错误信息,或者使用e.getclass().getName();得到异常对象的实际类型.

4.1 捕获多个异常
在Java SE7中,同一个catch字句中可以捕获多个异常类型.例如,假设对应缺少文件和未知主机异常的动作是一样的,就可以合并catch字句:
try {
    catch that might thorw exceptions
}
catch(FileNotFoundException | UnknowHostException e) {
    emergency action for missing files and unknown hosts
}
catch(IOException e) {
    emergency action for all other I/O problems
}
注释:捕获多个异常时,异常变量隐含为final变量.例如,不能在一下子句中为e赋不同的值:
catch(FileNotFoundException | UnknowHostException e) {...}

4.2 再次抛出异常与异常链
下面给出了捕获异常并将它再次抛出的基本方法:
try {
    access the datebase
} 
catch(SQLException e) {
    throw new ServletException("database error: " +　e.getMessage());
}
可以有一种更好的处理方法,并且将原始异常设置为新异常的"原因":
try {
    access the datebase
} 
catch(SQLException e) {
    Throwable se = new ServletException("database error");
    se.initCause(e);
    throw new ServletException("database error: " +　e.getMessage());
}
当捕获到异常时,就可以使用下面这条语句重新得到原始异常:
Throwable e = se.getCause();

4.3 finally子句
当代码抛出一个异常时,就会终止方法中剩余代码的处理,并退出这个方法的执行.
不管是否有异常被捕获,finally子句中的代码都被执行.在下面的示例中,程序将在所有情况下关闭文件.
InputStream in = new FileInputStream(...);
try {
    //1
    code that might throw exceptions
    //2
} 
catch (IOException e) {
    //3
    show error message
    //4
}
finally {
    //5
    in.close();
}
//6
在上面这段代码中,有下列3种情况会执行finally子句:
(1)代码没有抛出异常.在这种情况下,程序首先执行try语句块中的全部代码,然后执行finally子句中的代码.随后,继续执行try语句块之后的第一条语句.也就是说,执行标注1,2,5,6处
(2)抛出一个在catch子句中捕获的异常.在上面的示例中就是IOException异常.在这种情况下,程序将执行try语句块中的所有代码,直到发生异常为止.此时,将跳过try语句块中的剩余代码,转去执行与该异常匹配的catch子句中的代码,最后执行finally子句中的代码.
   (2.1)如果catch子句没有抛出异常,程序将执行try语句块之后的第一条语句.在这里,执行标注1,3,4,5,6处的语句.
   (2.2)如果catch子句抛出一个异常,异常将被抛回这个方法的调用者.在这里,执行标注1,3,5处
(3)代码抛出了一个异常,但这个异常不是由catch子句捕获的.在这种情况下,程序将执行try语句块中的所有语句,直到有异常被抛出为止.此时,将跳过try语句块中的剩余代码,然后执行finally子句的中语句,并将异常抛给这个方法的调用者.在这里,执行标注1,5处的语句.
try语句可以只有finally子句,而没有catch子句.例如,下面这条try语句:
InputStream in = ...;
try {
    code that might throw exception
}
finally{
    in.close();
}
无论在try语句块中是否遇到异常,finally子句中的in.close()语句都会被执行.
提示:这里,强烈建议解耦合try/catch和try/finally语句块.这样可以提高代码的清晰度.例如:
InputStream in = ...;
try {
    try {
        code that might throw exception
    }
    finally {
        in.close();
    }
}
catch() {
    show error message
}
内层的try语句块只有一个职责,就是确保关闭输入流.外层的try语句块也只有一个职责,就是确保报告出现的错误.这种设计方式不仅清楚,而且还具有一个功能,就是将会报告finally子句中出现的错误.

警告:当finally子句包含return语句时,将会出现一种意想不到的结果.假设利用return语句从try语句块中退出.在方法返回前,finally子句的内容将被执行.如果finally子句中也有一个return语句,这个返回值将会覆盖原始的返回值.请看一个复杂的例子:
public static int f(int n) {
    try {
        int r = n * n;
        return r;
    }
    finally {
        if(n == 2) return 0;
    }
}
如果调用f(2),那么try语句块的计算结果为r = 4,并执行return语句.然而,在方法真正返回前,还要执行finally子句.finally子句将使得方法返回0,这个返回值覆盖了原始的返回值4.

4.4 带资源的try语句
对于以下代码模式:
open a resource
try {
    work with the resource
}
finally {
    close the resource
}
假设资源属于一个实现了AutoCloseable接口的类,Java SE7为这种代码模式提供了一个很有用的快捷方式.AutoCLoseable接口有一个方法:
void close throws Exception
带资源的try语句(try-with-resources)的最简形式为:
try(Resource res = ...) {
    work with res
}
try块退出时,会自动调用res.close().下面给出一个典型的例子,这里要读取一个文件中的所有单词:
try(Scanner in = new Scanner(new FileInputStream("/usr/share/dict/words"),"UT-8")) {
    while(in.hasNext()) {
        System.out.println(in.next());
    }
}
这个块正常退出时,或者存在一个异常时,都会调用in.close()方法,就好像使用了finally块一样.还可以指定多个资源.例如:
try(Scanner in = new Scanner(new FileInputStream("/usr/share/dict/words"),,"UT-8");
    PrintWriter out = new PrintWriter("out.txt")) {
    while(in.hasNext()) {
        out.println(in.next().toUpperCase());
    }
}
不论这个块如何退出,in和out都会关闭.如果你用常规方式手动编程,就需要两个嵌套的try/finally语句.上一节已经看到如果try块抛出一个异常,而close方法也抛出一个异常,这就会带来一个难题.带资源的try语句可以很好地处理这种情况.原来的异常会重新抛出.而close方法抛出的异常会"被抑制".这些异常将自动捕获,并由addSuppressed方法增加到原来的异常.如果对这些异常感兴趣,可以调用getSuppressed方法,它会得到从close方法抛出并被抑制的异常列表.
注释:带资源的try语句自身也可以有catch子句和一个finally子句.这些子句会在关闭资源之后执行.不过在实际中,一个try语句中加入这么多内容可能不是一个好主意

#====================================================================
5. 分析堆栈轨迹元素
堆栈轨迹(stack trace)是一个方法调用过程的列表,它包含了程序执行过程中方法调用的特定位置.
(1)可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息:
Thowable t = new Throwable();
StringWriter out = new StringWriter();
t.printStackTrace(new PrintWriter(out));
String description = out.toString();
(2)一种更灵活的方法是使用getStackTrack方法,它会的到StackTraceElement对象的一个数组,可以在你的程序中分析这个对象数组,例如:
Throwable t = new Throwable();
StackTraceElement[] frames = t.getStackTrace();
for(StackTraceElement frame : frames)
    analyze frame
StackTraceElement类含有能够获得文件名和当前执行的代码行号的方法,同时,还含有能够获得类名和方法名的方法.toString方法将会产生一个字符串,其中包含所获得的信息.
(3)静态的Thread.getAllStackTrace方法,它可以产生所有线程的堆栈轨迹.西面给出使用这个方法的具体法师:
Map<Thread,StackTraceElement[]> map = Thread.getAllStackTrace();
for(Thread t : map.keyset()) {
    StackTraceElement[] frames = map.get(t);
    analyze frames
}

#====================================================================
6. 使用断言
断言机制允许在测试期间向代码中插入一些检查语句.当代码发布时,这些插入的检测语句将会被自动地移走.
Java语言引入了关键字assert.这个关键字有两种形式:
(1)assert : 条件
(2)assert 条件 : 表达式
这两种形式都会对条件进行检测,如果结果为false,则抛出一个AssertionError异常.在第二种形式中,表达式将被传入AssertionError的构造器,并转换成一个消息字符串.
注释:"表达式"部分的唯一目的是产生一个消息字符串.AssertionError对象并不存储表达式的值.因此,不可能在以后得到它.

6.1 使用断言完成参数检查
在Java语言中,给出了3种处理系统错误的机制:
(1)抛出一个异常
(2)日志
(3)使用断言
什么时候应该选择使用断言呢?请记住下面几点
(1)断言失败是致命的,不可回复的错误
(2)断言检查只用于开发和测试阶段

#====================================================================
第八章 泛型程序设计
#====================================================================
1. 定义简单泛型类
一个泛型类就是具有一个或多个类型变量的类.
泛型类可以有多个类型变量.例如,可以定义Pair类,其中第一个域和第二个域使用不同的类型:
public class Pair<T,U>{...}
注释:类型变量使用大写形式,且比较短,这是很罕见的.在Java中,使用变量E表示集合的元素类型,K和V分别表示表的关键字与值的类型.T(需要时还可以用临近的字母U和S)表示"任意类型"

1.1 泛型方法
实际上,还可以定义一个带有类型参数的简单方法
class ArrayAlg {
    public static <T> T getMiddle(T... a) {
        return a[a.lenght/2];
    }
}
泛型方法可以定义在普通类中,也可以定义在泛型类中.
当调用一个泛型方法时,在方法名前的尖括号中放入具体的类型:
String middle = ArrayAlg.<String>getMiddle("John","o","Public");
在这种情况下,方法调用中可以省略<String>类型参数.编译器有足够的信息能够推断出所调用的方法.它用names的类型(即String[])与泛型类T[]进行匹配并推断出T一定是String.也就是说,可以调用:
String middle = ArrayAlg.getMiddle("John","o","Public");
几乎在大多数情况下,对于泛型方法的类型引用没有问题.偶尔,编译器也会提示错误,此时需要解释错误报告.

1.2 类型变量的限定
有时,类或方法需要对类型变量加以约束.下面是一个典型的例子.我们要计算数组中的最小元素:
class ArrayAlg {
    public static <T> T min(T[] a) {//almost correct 
        if(a == null || a.lenght ==0) return null;
        T smallest = a[0];
        for (int i = 1; i < lenght; i++)
            if(smallest.compareTo(a[i] > 0)) smallest = a[i];
        return smallest;
    }
}
怎么才能确信T所属的类有compareTo方法呢?
解决这个问题的方案是将T限制为实现了Compareable接口的类.可以通过对类型变量T设置限定(bound)实现这一点:
public static <T extends Comparable> T min(T[] a)....
现在,泛型的min方法只能被实现了Comparable接口的类(如String,LocalDate)等的数组调用.由于Rectangle类没有实现Comparable接口,所以调用min将会产生一个编译错误.

注释:为什么使用关键字extends而不是implements?毕竟Comparable是一个接口,下面的记法:
<T extends BoundingType>
表示T应该是绑定类型的子类型.T和绑定类型可以是类,也可以是接口.选择关键字extends的原因是更接近子类的概念,并且Java的设计者也不打算在语言中在添加一个新的关键字.
一个类型变量或通配符可以有多个限定,例如:
T extends Comparable & Serializeable
限定类型用"&"分隔,而逗号用来分隔类型变量.在Java的继承中,可以根据需要拥有多个接口超类型,但限定中至多有一个类.如果用一个类作为限定,它必须是限定列表中的第一个

1.3 翻译泛型表达式
需要记住有关Java泛型转换的事实:
(1)虚拟机中没有泛型,只有普通的类和方法
(2)所有的类型参数都用它们的限定类型替换
(3)桥方法被合成来保持多态
(4)为保持类型安全性,必要时插入强制类型转换

#====================================================================
2. 约束与局限性
2.1 不能用基本类型实例化类型参数
不能用类型参数代替基本类型.因此,没有Pair<double>.只有Pair<Double>.当然,其原因是类型擦书.擦除之后,Pair类含有Object类型的域,而Object不能存储double值.

2.2 不能创建参数化类型的数组
例如:
Pair<String>[] table = new Pair<String>[10]; //Error
需要说明的是,只是不允许创建这些数组,而声明类型为Pair<String>[]的变量仍是合法的.不过不能用new Pair<String>[10]初始化这个变量.
注释:可以声明通配类型的数组,然后进行类型转换:
Pair<String>[] table = (Pair<String>[])new Pair<?>[10];
结果将是不安全的.如果在table[0]中存储一个Pair<Employee>,然后对table[0].getFirst()调用一个String方法,会得到一个ClassCastException异常.
提示:如果需要收集参数化类型对象,只有一种安全而有效的方法:使用ArrayList::ArrayList<Pair<String>>.

2.3 Varargs警告
Java不支持泛型类型的数组.这一节中我们再来讨论一个相关的问题:向参数个数可变的方法传递一个泛型类型的实例.
考虑下面这个简单的方法,它的参数个数是可变的:
public static <T> void addAll(Collection<T>,T... ts) {
    for(t:ts)coll.add(t);
}
为了调用这个方法,Java虚拟机必须建立一个Pair<String>数组,这就违反了前面的规则.不过,对于这种情况,规则有所松动,你只会得到一个警告,而不是错误.
可以采用两种方法来抑制这个警告.一种方法是为包含addAll调用的方法增加注解@SuppressWarning("unchecked").或者在JavaSE7中,还可以用@SafeVarargs直接标注addAll方法:

2.4 不能实例化类型变量
不能使用像 new T(...),new T[...]或 T.class这样的表达式中的类型变量.例如,下面的Pair<T>构造器就是非法的:
public Pair() {
    first = new T();
    second = new T();//Error
}
类型擦除将T改变成Object,而且,本意肯定不希望调用new Object().在Java SE8之后,最好的解决办法是让调用者提供一个构造器表达式.例如:
Pair<String> p = Pair.makePair(String::new);

2.5 不能构造泛型数组
就像不能实例化一个泛型实例一样们也不能实例化数组,不过原因有所不同,毕竟数组会填充null值,构造时看上去是安全的.不过,数组本身也有类型,用来监控存储在虚拟机中的数组.这个类型会被擦除.例如,考虑下面的例子:
public static <T extends Comparable> T[] minmax(T[] a) {
    T[] mm = new T[2];...
}//Error

2.6 泛型类的静态上下文中类型变量无效
不能在静态域或方法中引用类型变量,例如:
public class Singleton<T> {
    private static T singleInstance; //Error

    public static T getSingleInstance() {//Error
        if(singleInstance == null) construction new instance of T
        return singleInstance;
    }
}

2.7 不能抛出或捕获泛型类的实例
既不能抛出也不能捕获泛型类对象.实际上,真是泛型类扩展Throwable都是不合法的.
例如:
public class Problem<T> extends Exception{/** */}//Error--can not extend Throwable
catch子句中不能使用类型变量.例如,以下方法将不能编译:
public static <T extends Throwable> void doWork(Class<T> t) {
    try {
        do work
    }
    catch (T e) { //Error--can not catch type variable
        Logger.global.info(...)
    }
}
不过,在异常规范中使用类型变量是允许的.以下方法是合法的:
public static <T extends Throwable>void doWork(T t) throws T { //OK 
    try {
        do work
    } catch (Throwable realCause) {
        t.initCause(realCause);
        throw t;
    }
}

#====================================================================
3. 通配符类型
3.1 通配符概念
通配符类型中,允许类型参数变化.例如,通配符类型
Pair<? extends Employee>
表示任何泛型Pair类型,它的类型参数是Employee的子类,如Pair<Manager>,但不是Pair<String>.
假设要编写一个打印雇员对的方法,像这样:
public static void printBuddies(Pair<Employee> p) {}
正如前面讲到的,不能将Pair<Manager>传递给这个方法.解决的方法很简单:使用通配符类型:
public static void printBuddies(Pair<? extends Employee> p);

3.2 通配符的超类型限定
通配符限定与类型变量限定十分类似,但是,还有一个附加的能力,即可以指定一个超类型限定(supertype bound),如下所示:
? super Manager
这个通配符限制为Manager的所有超类型.
示例:
public static void minmaxBouns(Manager[] a, Pair<? super Manager> result) {}

3.3 无限定通配符
还可以使用无限定的通配符,例如,Pair<?>.
Pair<?>和Pair本质的不同在于:可以用任意Object对象调用原始Pair类的setObject方法

#====================================================================
4. 反射和泛型
4.1 虚拟机中的泛型类型信息
可以使用反射API来确定:
(1)这个泛型方法有一个叫做T的类型参数.
(2)这个类型参数有一个子类型限定,其自身又是一个泛型类型
(3)这个限定类型有一个通配符参数
(4)这个通配符参数有一个超类型限定
(5)这个泛型方法有一个泛型数组参数

#====================================================================
第九章 集合
#====================================================================
1. 如果需要一个循环数组队列,就可以使用ArrayDeque类.如果需要一个链表队列,就直接使用LinkedList类,这个类实现了Queue接口.

1.1 Collection接口
在Java类库中,集合类的基本接口是Collection接口.这个接口有两个基本方法:
public interface Collection<E> {
    boolean add(E element);
    Iterator<E> iterator():
    ...
}

1.2 迭代器
Iterator接口包含4个方法
public interface Iterator<E> {
    E next():
    boolean hasNext();
    void remove();
    default void forEachRemaining(Consumer<? super E> action);
}
Collection接口扩展了Iterable接口.因此,对于标准类库中的任何集合都可以使用"for each"循环.
在Java SE8中,甚至不用写循环.可以调用forEachRemaining方法并提供一个lambda表达式.将对迭代器的每一个元素调用这个lambda表达式,直到在没有元素为止.
iterator.forEachRemaining(elment->do something with element);
元素被访问的顺序取决于集合类型.如果对ArrayList进行迭代,迭代器将从索引0开始,每迭代一次,索引值加1.然而,如果访问HashSet中的元素,每个元素将会按照某种随机的次序出现.虽然可以确定在迭代过程中能够遍历到集合中的所有元素,但却无法预知元素被访问的次序.

#====================================================================
2. Java库中的具体集合
ArrayList       一种可以动态增长和缩减的索引序列
LinkedList      一种可以在任何位置进行高效地插入和删除操作的有序序列
ArrayDeque      一种用循环数组实现的双端队列
HashSet         一种没有重复元素的无序集合
TreeSet         一种有序集
EnumSet         一种包含枚举类型值的集
LinkedHashSet   一种可以记住元素插入次序的集
PriorityQueue   一种允许高效删除最小元素的集合
HashMap         一种存储键/值关联的数据结构
TreeMap         一种键值有序排列的映射表
EnumMap         一种键值属于枚举类型的映射表
LinkedHashMap   一种可以记住键/值项添加次序的映射表
WeakHashMap     一种其值无用武之地后可以被垃圾回收器回收的映射表
IdenityHashMap  一种用==而不是用equals比较键值的映射表

#====================================================================
3. 数组列表
对于一个经验丰富的Java程序员来说,在需要动态数组时,可能会使用Vector类.为什么要用ArrayList取代Vector呢?原因很简单:Vector类的所有方法都是同步的.可以由两个线程安全地访问一个Vector对象.但是,如果由一个线程访问Vector,代码要在同步操作上耗费大量的时间.这种情况还是很常见的.而ArrayList的方法不是同步的,因此,建议在不需要同步时使用ArrayList,而不要使用Vector.

#====================================================================
4. 散列集
散列表可以用于实现几个重要的数据结构.其中最简单的是set类型.set是没有重复元素的元素集合.

#====================================================================
5. 树集
TreeSet类与散列集十分类似,不过,它比散列集有所改进.树集是一个有序集合.可以以任意顺序将元素插入到集合中,在对集合进行遍历时,每个值将自动地按照排序后的顺序呈现.
注释:要使用树集,必须能够比较元素.这些元素必须实现Comparable接口,或者构造集时必须提供一个Comparator.
从JavaSE6起,TreeSet类实现了NavigableSet接口.这个接口增加了几个便于定位元素以及反向遍历的方法.

#====================================================================
6. 优先级队列
优先级队列(priority queue)中的元素可以按照任意的顺序插入,却总是按照排序的顺序进行检索.也就是说,无论何时调用remove方法,总会获得当前优先级队列中最小的元素.然而,优先级队列并没有对所有的元素进行排序.如果用迭代的方式处理这些元素,并不需要对它们进行排序.优先级队列使用了一个优雅且高效的数据结构,称为堆(heap).堆是一个可以自我调整的二叉树,对树执行添加(add)和删除(remore)操作,可以让细小的元素移动到根,而不必花费时间对元素进行排序.
与TreeSet一样,一个优先级队列既可以保存实现了Comparable接口的类对象,也可以保存在构造器中提供的Comparator对象.使用优先级队列的典型示例是任务调度.每一个任务有一个优先级,任务以随机顺序添加到队列中.每当启动一个新的任务时,都将优先级最高的任务从队列中删除.

#====================================================================
7. 映射
Java类库为映射提供了两个通用的实现:HashMap和TreeMap.这两个类都实现了Map接口.散列映射对键进行散列,树映射用键的整体顺序对元素进行排序,并将其组织成搜索树.散列或比较函数只能作用于键.与键关联的值不能进行散列或比较.

7.1 弱散列映射
设计WeakHashMap类是为了解决一个有趣的为.如果有一个值,对应的键已经不在使用了.
下面是这种机制的内部运行情况.WeakHashMap使用弱引用(weak references)保存键.WeakReference对象将引用保存到另一个对象中,在这里,就是散列键.对于这种类型的对象,垃圾回收器用一种特有的方式进行处理.通常,如果某个对象只能由WeakReference引用,垃圾回收器仍然回收它,但要将引用这个对象的弱引用放入队列中.WeakHashMap将周期性地检查队列,以便找出新添加的弱引用.一个弱引用进入队列意味着这个键不在被他人使用,并且已经被收集起来.于是,WeakHashMap将删除对应的条目.

7.2 链接散列集与映射
LinkedHashSet和LinkedHashMap类用来记住插入元素项的顺序.这样就可以避免在散列表中的项从表面上看是随机排列的.当条目插入到表中时,就会并入到双向链表中.
链接散列映射将用访问顺序,而不是插入顺序,对映射条目进行迭代.每次调用get或put,受到影响的条目将从当前的位置删除,并放到条目链表的尾部(只有条目在链表中的位置会受影响,而散列表中的桶不会受影响,一个条目总位于与键散列码对应的桶中)
访问顺序对于实现高速缓存的"最近最少使用"原则十分重要.

#====================================================================
8. 枚举集与映射
EnumSet是一个枚举类型元素集的高效实现.由于枚举类型只有有限个实例,所以EnumSet内部用位序列实现,.如果对应的值在集中,则相应的位被置为1
EnumSet类没有公共的构造器.可以使用静态工厂方法构造这个集:
enum Weekday{MONDAY, TUESDAY, WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY};
Enum<Weekday> always = Enum.allOf(Weekday.class);
Enum<Weekday> never = Enum.noneOf(Weekday.class);
Enum<Weekday> workday = Enum.range(Weekday.MONDAY,Weekday.FRIDAY);
Enum<Weekday> mwf = Enum.of(Weekday.MONDAY ,Weekday.TUESDAY ,Weekday.WEDNESDAY);

#====================================================================
9. 标识散列映射
类IdentityHashMap有特殊的作用.在这个类中,键的散列值不是用hashCode函数计算的,而是用System.identityHashCode方法计算的.这是Object.hashCode方法根据对象的内存地址来计算散列码时所使用的方式.而且,在对两个对象进行比较时,IdentityHashMap类使用==,而不适用equals.也就是说,不同的键对象,即使用内容相同,也被视为是不同的对象.在实现对象遍历算法(如对象串行化)时,这个类非常有用,可以用来跟踪每个对象的遍历状况.

#====================================================================
10. 同步视图
如果由多个线程访问集合,就必须确保集不会被意外地破坏.类库的设计者使用视图机制来确保常规集合的线程安全,而不是实现线程安全的集合类.例如Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有同步方法的Map:
Map<String, Employee> map = Collections.synchronizedMap(new HashMap<String,Employee>);
现在,就可以由多线程访问map对象了.像get和put这类方法都是同步操作的,即在另一个线程调用另一个方法之前,刚才的方法调用必须彻底完成

#====================================================================
11. 位集
Java平台的BitSet类用于存放一个位序列.如果需要高效地存储位序列(例如,标志)就可以使用位集.由于位集将位包装在字节里,所以,使用位集要比使用Boolean对象的ArrayList更加高效.

#====================================================================
第十三章 部署Java应用程序
#====================================================================
1.Jar文件
在将应用程序进行打包时,使用者一定希望仅提供给其一个单独的文件,而不是一个含有大量类文件的目录,Java归档(JAR)文件就是为此目的而设计的,一个Jar文件即可以包含类文件,也可以包含诸如图像和声音这些其他类型的文件.此外,Jar文件是亚索的,它使用了大家熟悉的ZIP压缩格式.

1.1 创建Jar文件
可以使用jar工具制作Jar文件(在默认的JDK安装中,位于jdk/bin目录下).创建一个新的Jar文件应该使用的常见命令格式为:
jar cvf JARFileName File1 filed2 ...
通常,jar命令的格式如下:
jar options File1 Filed2 ...
(P581)列出了所有jar程序的可选项.它们类似于UNIX tar命令的选项.

1.2 清单文件
除了类文件,图像和其他资源外,每个Jar文件还包含一个用于描述归档特征的清单文件(manifest).
清单文件被命名为MANIFEST.MF,它位于Jar文件的一个特殊META-INF子目录中.最小的符合标准的清单文件是很简单的:
Manifest-Version:1.0
复杂的清单文件可能包含更多条目.这些清单条目被分成多个节.第一节被称为主节(main section).它作用与整个Jar文件.随后的条目用来指定已命名条目的属性,这些已命名的条目可以是某个文件,包或者URL.它们都必须起始于名为Name的条目.节与节之间用空行分开.例如:
Manifest-Version: 1.0
描述这个归档文件的行

Name: Woozle.class
描述这个文件的行
Name: com/mycompany/mypkg
描述这个包的行

1.3 资源
类加载器知道如何搜索类文件,直到在类路径,存档文件或web服务器上找到为止.利用资源机制,对于非类文件也可以同样方便地进行操作.下面是必要的步骤:
(1)获得具有资源的Class对象,例如,AboutPanel.class
(2)如果资源是一个图像或声音文件,那么就需要调用getresource(filename)获得作为URL的资源为止,然后利用getImage或getAudioClip方法进行读取
(3)与图像或声音文件不同,其他资源可以使用getResourceAsStream方法读取文件中的数据.
例如,要想利用about.gif图像文件制作图标,可以使用下列代码:
URL url = Resource.class.getResource("about.gif");
Image img = new ImageIcon(url).getImage();
这段代码的含义是"在找到ResourceTest类的地方查找about.gif文件"
除了可以将资源文件与类文件放在同一个目录中外,还可以将它放在子目录中.可以使用在下面所示的层级资源名
data/text/about.txt
这是一个相对的资源名,它会被解释为相对于加载这个资源的类所在的包.注意,必须使用"/"作为分隔符,而不要理睬存储资源文件的系统实际使用哪种目录分隔符.

1.4 密封
可以将java包密封以保证不会有其他的类加入到其中.如果在代码中使用了包可见的类,方法和域,就可能希望密封包.如果不密封,其他类就有可能放在这个包中,进而访问包的可见的特性.
例如,如果密封了com.mycompany.util包,就不能用下面的语句顶替密封包之外的类:package com.mycompany.util
想要密封一个包,需要将包中的所有类放到一个Jar文件中.在默认情况下,Jar文件中的包是没有密封的.可以 在清单文件的主节中加入下面一行:
Sealed: true
来改变全局的默认设定.对于每个单独的包,可以通过在Jar文件的清单中增加一节,来指定是否想要密封这个包.例如:
Name: com/mycompany/util/
Sealed: true
Name: com/mycompany/misc/
Sealed: false
想要密封一个包,需要创建一个包含清单指令的文本文件.然后用常规的方式运行jar命令:
jar cvfm MyArchive.jar manifest.mf files to add

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================