STL学习
#==================================================================== 
一. STL六大组件
1.容器:各种数据结构,如vector,list等
2.算法:各种常用算法如sort,search等
3.迭代器:扮演容器与算法之间的胶合剂,是所谓的"泛型指针"
4.仿函数:仿函数行为类似函数,可以作为算法的某种策略
5.配接器:一种用来修饰容器或仿函数或迭代器接口的东西
6.配置器:配置器负责空间配置与整理

#====================================================================
1. 空间配置器
1.1 在C++中内存配置操作和释放操作使用new和delete,这其中new算式内含两阶段操作:
(1)调用::operator new配置内存
(2)调用构造函数构造对象内容
delete算式也内含两阶段操作:
(1)调用析构函数
(2)调用::operator delete释放内存
STL将这两阶段操作区分开来,内存配置操作由alloc:allocate()负责,内存释放操作由alloc::deallocate()负责
对象构造操作由::construct()负责,对象析构操作由::destroy()负责

1.2 考虑到小型区块所可能造成的内存破碎问题,SGI设计了双层级配置器,第一级配置器直接使用malloc()和free(),第二级配置器则视情况采用不同的策略.当配置区块超过128byte时,视之为"足够大",便调用第一级配置器;当配置区块小于128byte时,视之为"过小",为了降低额外负担,便采用复杂的memory pool整理方式,而不在求助于第一级配置器
#==================================================================== 
array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全
#==================================================================== 
2 序列容器
vector概述
array是静态空间,一旦配置了就不能改变;
vector是动态空间,随着元素的加入,它的内部机制会自行扩充空间以容纳新元素,vector维护的是一个连续线性空间,所以不论其元素型别为何,普通指针都可以作为vector的迭代器而满足所有必要条件.
为了降低空间配置时的速度成本,vectror实际配置的大小可能比客户端需求量更大一些,已备将来可能的扩充,换句话说一个vector的容量永远大于或等于其大小,便是满载,下次再有新增元素,整个vector就的另觅居所
vector虽可成长,却只能向尾端成长,通过
(1)另觅更大的空间;
(2)将原数据复制过去
(3)释放原空间三部曲

1.push_back         在数组的最后添加一个数据
2.pop_back          去掉数组的最后一个数据 
3.at                得到编号位置的数据
4.begin             得到数组头的指针
5.end               得到数组的最后一个单元+1的指针
6.front             得到数组头的引用
7.back              得到数组的最后一个单元的引用
8.max_size          得到vector最大可以是多大
9.capacity          当前vector分配的大小(包括备用空间)
10.size             当前使用数据的大小
11.resize           改变当前使用数据的大小，如果它比当前使用的大，者填充默认值
12.reserve          改变当前vecotr所分配空间的大小
13.erase            删除指针指向的数据项
14.clear            清空当前的vector
15.rbegin           将vector反转后的开始指针返回(其实就是原来的end-1)
16.rend             将vector反转构的结束指针返回(其实就是原来的begin-1)
17.empty            判断vector是否为空
18.swap             与另一个vector交换数据

注:对vector的任何操作,一旦引起空间重新配置,指向原vector的所有迭代器就都失效了,这是易犯的一个错误
迭代器end指向NULL
#==================================================================== 
3 list概述
它的好处是每次插入或删除一个元素,就配置或释放一个元素空间,因此list对于任何位置的元素插入或元素移除,list永远是常数时间
由于STL中list是一个双向链表,迭代器必须具备前移,后移的能力,SGI list不仅是一个双向链表,而且还是一个环状双向链表,所以它只需要一个指针,便可以完整表现整个链表

3.1 如果希望在list内的某处插入新节点,首先必须确定插入位置,新节点将位于哨兵迭代器所指之节点的前方

assign()            给list赋值 
back()              返回最后一个元素 
begin()             返回指向第一个元素的迭代器 
clear()             删除所有元素 
empty()             如果list是空的则返回true 
end()               返回末尾的迭代器 
erase()             删除一个元素 
front()             返回第一个元素 
get_allocator()     返回list的配置器 
insert()            插入一个元素到list中 
max_size()          返回list能容纳的最大元素数量 
merge()             合并两个list 
pop_back()          删除最后一个元素 
pop_front()         删除第一个元素 
push_back()         在list的末尾添加一个元素 
push_front()        在list的头部添加一个元素 
rbegin()            返回指向第一个元素的逆向迭代器 
remove()            从list删除元素 
remove_if()         按指定条件删除元素 
rend()              指向list末尾的逆向迭代器 
resize()            改变list的大小 
reverse()           把list的元素倒转 
size()              返回list中的元素个数 
sort()              给list排序 
splice()            合并两个list 
swap()              交换两个list 
unique()            删除list中重复的元素

注:迭代器end指向NULL
#==================================================================== 
4 deque概述
vector是单向开口的连续线性空间,deque则是一种双向开口的连续线性空间,所谓开口,意思是可以在头尾两端分别做元素的插入和删除操作
deque和vector的差异
    1 deque允许于常数时间内对头端进行元素的插入或删除
    2 deque它是动态以分段连续空间组合而成,随时可以增加一段新的空间并链接起来.
虽然deque也提供了迭代器,但它的迭代器并不是普通指针,其复杂成都和vector不可以道理计,这影响了各个运算层面,因此除非必要,我们应尽可能选择使用vector而非deque.对deque进行的排序操作,为了最高效率,可将deque完整的复制到一个vector中,将vector排序后,在复制回deque

4.1 deque采用一块所谓的map作为主控.这里所谓map是一块连续空间,其中每个元素都是指针,指向另一段连续线性空间,称为缓冲区,缓冲区管理才是deque的储存空间主体
4.2 最常用函数
（1）at()：返回索引;
（2）front()：返回第一个数据;
（3）back()：返回最后一个数据;
（4）push_back()：在尾部加入一个数据;
（5）push_front()：在头部插入一个数据;
（6）pop_back()：删除最后一个数据;
（7）pop_front()：删除头部数据;
（8）empty()：判断容器是否位空;
（9）size()：返回容器中实际数据的个数;
(10)clear(): 清除整个deque
(11)erase(): 清除某个元素,还可以用来清除[first,last)区间内的所有元素
(12)insert():允许在某个点(之前)插入一个元素,并设定其值
#==================================================================== 
5. stack概述
stack是一种先进后出的数据结构,它只有一个出口,stack允许新增元素,移除元素,取得最顶端元素,但除了最顶端外,没有任何其他方法可以存取stack的其它元素,换言之,stack不允许有遍历行为
由于stack系以底部容器(也就是使用其他容器)完成其所有工作,而具有这种"修改某物接口,形成另一种是风貌"之性质者,称为adapter(配接器).因此,STL stack往往不被归类为container(容器)
,而被归类为container adapter
5.1 stack所有元素的进出都必须符合"先进后出"的条件,只有stack顶端的元素,才有机会被外界取用.stack不提供走访功能,也不提供迭代器
5.2 可以使用deque或list作为底层容器
#==================================================================== 
6 queue概述
queue是一种先进先出的数据结构,它有两个出口.queue允许新增元素,移除元素,从最底端加入元素,取得最顶端元素.但除了最底端可以加入,最顶端可以取出外,没有任何其他办法可以存取queue的其他元素,换言之,queue不允许有遍历行为.queue和stack一样使用底层容器deque来实现,被归类为container adapter
6.1 queue所有元素的进出都必须符合"先进先出"的条件,只有queue顶端的元素, 才有机会被外界取用.queue不提供遍历功能,也不提供迭代器
6.2 可以使用deque或list作为底层容器
#==================================================================== 
7 heap堆算法
所谓binary heap就是一种完全二叉树,也就是说,整颗binary tree除了最底层的叶节点之外,是填满的,而最底层的叶节点由左至右不得有空隙
完全二叉树整棵树内没有任何节点漏洞,这带来一个极大的好处:我们可以利用array来储存所有节点,那么当完全二叉树中的某个节点位于array的i处时,其左子几点必须位于array的2i处,其右子节点必位于array的2i+1处,其父节点必位于"i/2"处(此处的"/"权权代表高斯符号,取其整数)
7.1 根据元素排列方式,heap可分为max-heap(大堆)和min-heap(小堆),前者每个节点的键值都大于或等于其子节点键值,后者的每个节点键值都小于或等于其子节点键值,因此max-heap的最大值在根节点,并总是位于底层array或vector的起头处;min-heap的最小值在根节点,亦总是位于底层array或vector的起头处.STL供应的是max-heap
7.2 
(1)push_heap()      插入新元素
实现:将新节点拿来与其父节点比较,如果其键值比父节点大,就父子对换位置,如此一直上溯,直到不需要了对换或直到根节点为止
(2)pop_heap()       取出最大值(根节点)
(3)sort_heap()      对堆进行排序成顺序数组
实现:即每次pop_heap可获得heap中键值最大的元素,如果持续对整个heap做pop_heap操作,每次将操作范围从后向前缩减一个元素,当整个程序执行完,我们便有了一个递增序列
用法:该函数接受两个迭代器,用来表现一个heap底部容器的头尾,注意,排序过后,原来的heap就不在是一个合法的heap了
(4)make_heap()      将一段现有数据转换为一个heap
7.3 heap的所有元素都必须遵循特别的排列规则,所以heap不提供遍历功能,也不提供迭代器

#==================================================================== 
8 priority_queue概述
priority_queue是一个拥有权值观念的queue,它允许加入新元素,移除旧元素,审视元素值等功能;
priority_queue带有权值观念,其内的元素并非依照被推入的次序排列,而是自动依照元素的权值排列(通常权值以实值表示)
通过底层容器实现被归类为container adapter,并不具备遍历功能没有迭代器

#==================================================================== 
9 slist概述
slist和list共同具有的一个相同特色是,他们的插入(insert),移除(erase),接合(splice)等操作并不会造成原有的迭代器失效(指向被移除元素的那个迭代器,在移除操作发生之后肯定实会失效的)

#==================================================================== 
关联式容器
标准的STL关联式容器分为set(集合)和map(映射表)两大类,以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表).这些容器的底层机制均以RB-tree(红黑树)完成.RB-tree也是一个独立容器,但并不开放给外界使用

#==================================================================== 
10 set概述
set的特性是,所有元素都会根据元素的键值自动被排序,set的元素不像map那样可以同时拥有实值和键值,set元素的键值就是实值,实值就是键值.set不允许两个元素有相同的键值

#==================================================================== 

#==================================================================== 

#==================================================================== 

#==================================================================== 


#==================================================================== 


#==================================================================== 


#==================================================================== 


#==================================================================== 


#==================================================================== 


#==================================================================== 


#==================================================================== 