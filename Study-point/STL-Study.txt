STL学习
#==================================================================== 
一. STL六大组件
1.容器:各种数据结构,如vector,list等
2.算法:各种常用算法如sort,search等
3.迭代器:扮演容器与算法之间的胶合剂,是所谓的"泛型指针"
4.仿函数:仿函数行为类似函数,可以作为算法的某种策略
5.配接器:一种用来修饰容器或仿函数或迭代器接口的东西
6.配置器:配置器负责空间配置与整理

#====================================================================
1. 空间配置器
1.1 在C++中内存配置操作和释放操作使用new和delete,这其中new算式内含两阶段操作:
(1)调用::operator new配置内存
(2)调用构造函数构造对象内容
delete算式也内含两阶段操作:
(1)调用析构函数
(2)调用::operator delete释放内存
STL将这两阶段操作区分开来,内存配置操作由alloc:allocate()负责,内存释放操作由alloc::deallocate()负责
对象构造操作由::construct()负责,对象析构操作由::destroy()负责

1.2 考虑到小型区块所可能造成的内存破碎问题,SGI设计了双层级配置器,第一级配置器直接使用malloc()和free(),第二级配置器则视情况采用不同的策略.当配置区块超过128byte时,视之为"足够大",便调用第一级配置器;当配置区块小于128byte时,视之为"过小",为了降低额外负担,便采用复杂的memory pool整理方式,而不在求助于第一级配置器

1.3 适配器
适配器是用来修改其他组件接口的STL组件，是带有一个参数的类模板（这个参数是操作的值的数据类型）。STL定义了3种形式的适配器：容器适配器，迭代器适配器，函数适配器。
容器适配器：包括栈（stack）、队列(queue)、优先(priority_queue)。使用容器适配器，stack就可以被实现为基本容器类型（vector,dequeue,list）的适配。可以把stack看作是某种特殊的vctor,deque或者list容器，只是其操作仍然受到stack本身属性的限制。queue和priority_queue与之类似。容器适配器的接口更为简单，只是受限比一般容器要多。
迭代器适配器：修改为某些基本容器定义的迭代器的接口的一种STL组件。反向迭代器和插入迭代器都属于迭代器适配器，迭代器适配器扩展了迭代器的功能。
函数适配器：通过转换或者修改其他函数对象使其功能得到扩展。这一类适配器有否定器（相当于"非"操作）、绑定器、函数指针适配器。函数对象适配器的作用就是使函数转化为函数对象，或是将多参数的函数对象转化为少参数的函数对象
#==================================================================== 
array也位于名称空间std中,与数组一样,array对象的长度也是固定的,也使用栈(静态内存分配),而不是自由存储区,因此其效率与数组相同,但更方便,更安全
#==================================================================== 
2 序列容器
vector概述
array是静态空间,一旦配置了就不能改变;
vector是动态空间,随着元素的加入,它的内部机制会自行扩充空间以容纳新元素,vector维护的是一个连续线性空间,所以不论其元素型别为何,普通指针都可以作为vector的迭代器而满足所有必要条件.
为了降低空间配置时的速度成本,vectror实际配置的大小可能比客户端需求量更大一些,已备将来可能的扩充,换句话说一个vector的容量永远大于或等于其大小,便是满载,下次再有新增元素,整个vector就的另觅居所
vector虽可成长,却只能向尾端成长,通过
(1)另觅更大的空间; 
(2)将原数据复制过去
(3)释放原空间三部曲

1.push_back()         在数组的最后添加一个数据
2.pop_back()          去掉数组的最后一个数据 
3.at()                得到编号位置的数据
4.begin()             得到数组头的指针
5.end()               得到数组的最后一个单元+1的指针
6.front()             得到数组头的引用
7.back()              得到数组的最后一个单元的引用
8.max_size()          得到vector最大可以是多大
9.capacity()          当前vector分配的大小(包括备用空间)
10.size()             当前使用数据的大小
11.resize()           改变当前使用数据的大小，如果它比当前使用的大，者填充默认值
12.reserve()          改变当前vecotr所分配空间的大小
13.erase()            删除指针指向的数据项
14.clear()            清空当前的vector
15.rbegin()           将vector反转后的开始指针返回(其实就是原来的end-1)
16.rend()             将vector反转构的结束指针返回(其实就是原来的begin-1)
17.empty()            判断vector是否为空
18.swap()             与另一个vector交换数据

注:对vector的任何操作,一旦引起空间重新配置,指向原vector的所有迭代器就都失效了,这是易犯的一个错误
迭代器end指向NULL
#==================================================================== 
3 list概述
它的好处是每次插入或删除一个元素,就配置或释放一个元素空间,因此list对于任何位置的元素插入或元素移除,list永远是常数时间
由于STL中list是一个双向链表,迭代器必须具备前移,后移的能力,SGI list不仅是一个双向链表,而且还是一个环状双向链表,所以它只需要一个指针,便可以完整表现整个链表

3.1 如果希望在list内的某处插入新节点,首先必须确定插入位置,新节点将位于哨兵迭代器所指之节点的前方

assign()            给list赋值 
back()              返回最后一个元素 
begin()             返回指向第一个元素的迭代器 
clear()             删除所有元素 
empty()             如果list是空的则返回true 
end()               返回末尾的迭代器 
erase()             删除一个元素 
front()             返回第一个元素 
get_allocator()     返回list的配置器 
insert()            插入一个元素到list中 
max_size()          返回list能容纳的最大元素数量 
merge()             合并两个list 
pop_back()          删除最后一个元素 
pop_front()         删除第一个元素 
push_back()         在list的末尾添加一个元素
push_front()        在list的头部添加一个元素 
rbegin()            返回指向第一个元素的逆向迭代器 
remove()            从list删除元素 
remove_if()         按指定条件删除元素 
rend()              指向list末尾的逆向迭代器 
resize()            改变list的大小 
reverse()           把list的元素倒转 
size()              返回list中的元素个数 
sort()              给list排序 
splice()            合并两个list 
swap()              交换两个list 
unique()            删除list中重复的元素

注:迭代器end指向NULL
#==================================================================== 
4 deque概述
vector是单向开口的连续线性空间,deque则是一种双向开口的连续线性空间,所谓开口,意思是可以在头尾两端分别做元素的插入和删除操作
deque和vector的差异
    1 deque允许于常数时间内对头端进行元素的插入或删除
    2 deque它是动态以分段连续空间组合而成,随时可以增加一段新的空间并链接起来.
虽然deque也提供了迭代器,但它的迭代器并不是普通指针,其复杂成都和vector不可以道理计,这影响了各个运算层面,因此除非必要,我们应尽可能选择使用vector而非deque.对deque进行的排序操作,为了最高效率,可将deque完整的复制到一个vector中,将vector排序后,在复制回deque

4.1 deque采用一块所谓的map作为主控.这里所谓map是一块连续空间,其中每个元素都是指针,指向另一段连续线性空间,称为缓冲区,缓冲区管理才是deque的储存空间主体
4.2 最常用函数
（1）at()：返回索引;
（2）front()：返回第一个数据;
（3）back()：返回最后一个数据;
（4）push_back()：在尾部加入一个数据;
（5）push_front()：在头部插入一个数据;
（6）pop_back()：删除最后一个数据;
（7）pop_front()：删除头部数据;
（8）empty()：判断容器是否位空;
（9）size()：返回容器中实际数据的个数;
(10)clear(): 清除整个deque
(11)erase(): 清除某个元素,还可以用来清除[first,last)区间内的所有元素
(12)insert():允许在某个点(之前)插入一个元素,并设定其值
#==================================================================== 
5. stack概述
stack是一种先进后出的数据结构,它只有一个出口,stack允许新增元素,移除元素,取得最顶端元素,但除了最顶端外,没有任何其他方法可以存取stack的其它元素,换言之,stack不允许有遍历行为
由于stack系以底部容器(也就是使用其他容器)完成其所有工作,而具有这种"修改某物接口,形成另一种是风貌"之性质者,称为adapter(配接器).因此,STL stack往往不被归类为container(容器)
,而被归类为container adapter
5.1 stack所有元素的进出都必须符合"先进后出"的条件,只有stack顶端的元素,才有机会被外界取用.stack不提供走访功能,也不提供迭代器
5.2 可以使用deque或list作为底层容器
#==================================================================== 
6 queue概述
queue是一种先进先出的数据结构,它有两个出口.queue允许新增元素,移除元素,从最底端加入元素,取得最顶端元素.但除了最底端可以加入,最顶端可以取出外,没有任何其他办法可以存取queue的其他元素,换言之,queue不允许有遍历行为.queue和stack一样使用底层容器deque来实现,被归类为container adapter
6.1 queue所有元素的进出都必须符合"先进先出"的条件,只有queue顶端的元素, 才有机会被外界取用.queue不提供遍历功能,也不提供迭代器
6.2 可以使用deque或list作为底层容器
#==================================================================== 
7 heap堆算法
所谓binary heap就是一种完全二叉树,也就是说,整颗binary tree除了最底层的叶节点之外,是填满的,而最底层的叶节点由左至右不得有空隙
完全二叉树整棵树内没有任何节点漏洞,这带来一个极大的好处:我们可以利用array来储存所有节点,那么当完全二叉树中的某个节点位于array的i处时,其左子节点必须位于array的2i处,其右子节点必位于array的2i+1处,其父节点必位于"i/2"处(此处的"/"权权代表高斯符号,取其整数)
7.1 根据元素排列方式,heap可分为max-heap(大堆)和min-heap(小堆),前者每个节点的键值都大于或等于其子节点键值,后者的每个节点键值都小于或等于其子节点键值,因此max-heap的最大值在根节点,并总是位于底层array或vector的起头处;min-heap的最小值在根节点,亦总是位于底层array或vector的起头处.STL供应的是max-heap
7.2 
(1)push_heap()      插入新元素
实现:将新节点拿来与其父节点比较,如果其键值比父节点大,就父子对换位置,如此一直上溯,直到不需要了对换或直到根节点为止
(2)pop_heap()       取出最大值(根节点)
(3)sort_heap()      对堆进行排序成顺序数组
实现:即每次pop_heap可获得heap中键值最大的元素,如果持续对整个heap做pop_heap操作,每次将操作范围从后向前缩减一个元素,当整个程序执行完,我们便有了一个递增序列
用法:该函数接受两个迭代器,用来表现一个heap底部容器的头尾,注意,排序过后,原来的heap就不在是一个合法的heap了
(4)make_heap()      将一段现有数据转换为一个heap
7.3 heap的所有元素都必须遵循特别的排列规则,所以heap不提供遍历功能,也不提供迭代器

#==================================================================== 
8 priority_queue概述
priority_queue是一个拥有权值观念的queue,它允许加入新元素,移除旧元素,审视元素值等功能;
priority_queue带有权值观念,其内的元素并非依照被推入的次序排列,而是自动依照元素的权值排列(通常权值以实值表示)
通过底层容器实现被归类为container adapter,并不具备遍历功能没有迭代器

#==================================================================== 
9 slist概述
slist和list共同具有的一个相同特色是,他们的插入(insert),移除(erase),接合(splice)等操作并不会造成原有的迭代器失效(指向被移除元素的那个迭代器,在移除操作发生之后肯定实会失效的)

#==================================================================== 
关联式容器
标准的STL关联式容器分为set(集合)和map(映射表)两大类,以及这两大类的衍生体multiset(多键集合)和multimap(多键映射表).这些容器的底层机制均以RB-tree(红黑树)完成.RB-tree也是一个独立容器,但并不开放给外界使用

#==================================================================== 
10 set概述
10.1 基本概念
set的特性是,所有元素都会根据元素的键值自动被排序,set的元素不像map那样可以同时拥有实值和键值,set元素的键值就是实值,实值就是键值.set不允许两个元素有相同的键值
set拥有与list相同的某些性质,当客户端对它进行元素新增操作或删除操作时,操作之前的所有迭代器,在操作完成之后都依然有效
由于RB-tree是一种平衡二叉搜索树,自动排序的效果很不错,所有标准的STL set即以RB-tree为底层机制,又由于set所开放的各种操作接口,RB-tree也都提供了,所以几乎所有的set操作行为,都只是转调用RB-tree的操作行为而已
10.2 基本用法
begin();            返回指向第一个元素的迭代器
end();              返回指向最后一个元素的迭代器
clear();            清除所有元素
count();            返回某个值元素的个数
empty();            如果集合为空，返回true
equal_range();      返回集合中与给定值相等的上下限的两个迭代器
erase()             删除集合中的元素
find()              返回一个指向被查找到元素的迭代器
get_allocator()     返回集合的分配器
insert()            在集合中插入元素
lower_bound()       返回指向大于（或等于）某值的第一个元素的迭代器
key_comp()          返回一个用于元素间值比较的函数
max_size()          返回集合能容纳的元素的最大限值
rbegin()            返回指向集合中最后一个元素的反向迭代器
rend()              返回指向集合中第一个元素的反向迭代器
size()              集合中元素的数目
swap()              交换两个集合变量
upper_bound()       返回大于某个值元素的迭代器
value_comp()        返回一个用于比较元素间的值的函数

#==================================================================== 
11 map概述
11.1 基本概念
map的特性是,所有元素都会根据元素的键值自动被排序.map的所有元素都是pair.map不允许两个元素拥有相同的键值
map元素的键值关系到map元素的排列规则,任意改变map元素键值将会严重破坏map组织,但修正元素的实值是可以的
map拥有与list相同的某些性质,当客户端对它进行元素新增操作或删除操作时,操作之前的所有迭代器,在操作完成之后都依然有效
由于RB-tree是一种平衡二叉搜索树,自动排序的效果很不错,所有标准的STL map即以RB-tree为底层机制,又由于set所开放的各种操作接口,RB-tree也都提供了,所以几乎所有的map操作行为,都只是转调用RB-tree的操作行为而已
11.2 基本用法
begin()             返回指向map头部的迭代器
clear()             删除所有元素
count()             返回指定元素出现的次数
empty()             如果map为空则返回true
end()               返回指向map末尾的迭代器
equal_range()       返回特殊条目的迭代器对
erase()             删除一个元素
find()              查找一个元素
get_allocator()     返回map的配置器
insert()            插入元素
key_comp()          返回比较元素key的函数
lower_bound()       返回键值>=给定元素的第一个位置
max_size()          返回可以容纳的最大元素个数
rbegin()            返回一个指向map尾部的逆向迭代器
rend()              返回一个指向map头部的逆向迭代器
size()              返回map中元素的个数
swap()              交换两个map
upper_bound()       返回键值>给定元素的第一个位置
value_comp()        返回比较元素value的函数

#==================================================================== 
12 multiset概述
12.1 基本概念
multiset的特性以及用法和set完全相同,唯一的差别在于它允许键值重复.
multiset -find返回的是第一个匹配到的迭代器

#==================================================================== 
13 multimap概述
multimap的特性以及用法与map完全相同,唯一的差别在于它允许键值重复
multimap -find返回的是第一个匹配到的迭代器

#==================================================================== 
14 hashtable概述
14.1 基本概念
hashtable可提高任何有名项的存取操作和删除操作,由于操作对象是有名项,所以hashtable也可被视为一种字典结构,这种结构的用意在于提供常数时间之基本操作
hashtable并不会自动排序,所有使用hashtable的容器都不会自动排序,例如hash_set,hash_map,hash_multiset,hash_multimap

#==================================================================== 
15 hash_map概述
15.1 基本概念
hash_map和hash_set是以hashtable为底层机制,因为set和map是以RB-tree为底层实现所以有自动排序功能,而hash_set和hash_map是以hashtable(hashtable本身不存在自动排序功能)为底层实现不存在了自动排序功能
虽然hash_map目前并没有纳入C++ 标准模板库中，但几乎每个版本的STL都提供了相应的实现。

#==================================================================== 
算法
16 质变算法--会改变操作对象之值
所有STL算法都作用在由迭代器[first, last)所标志出来的区间上,所谓"质变算法",是指运算过程中会更改区间内(迭代器所指)的元素内容.诸如拷贝(copy),互换(swap),替换(replace),填写(fill),删除(remove),排列组合(permutation),分割(partition),随机重排(random shuffing),排序(sort)等算法

16.1 非质变算法--不改变操作对象之值
所有STL算法都作用在由迭代器[first, last)所标志出来的区间上,所谓"非质变算法",是指运算过程中不会更改区间内(迭代器所指)的元素内容,诸如查找(find),匹配(search),计数(count),巡访(for_each),比较(equal,mismatch),寻找极值(max,min)等算法

#==================================================================== 
17 set相关算法
(1)并集(union)
(2)交集(intersection)
(3)差集(difference)
(4)对称差集(symmetric difference)

#==================================================================== 
18 heap算法
(1)make_heap()
(2)pop_heap()
(3)push_heap()
(4)sort_heap()

具体算法没有细看详见书P288-P291算法总览
#==================================================================== 
仿函数
19 仿函数可以应用于STL算法中充当,自定义算法传入到模板参数中(扮演一种策略的角色)
STL仿函数应该有能力被函数配接器修饰,彼此像积木一样地串接,为了拥有配接能力,每一个仿函数必须定义自己的相应型别,就像迭代器如果要融入整个STL大家庭(就像int等基本函数类型,将仿函数统一成一种类型,在模板中可进行识别)
STL中仿函数分类
(1)算数类仿函数,支持加法,减法,乘法,除法,模数(余数,modulus)和否定(negation)运算,否定为一元运算,其他都是二元运算
(2)关系运算类仿函数,支持等于,不等于,大于,大于等于,小于,小于等于六种运算,每一个人都是二元运算(二元运算是由两个元素形成第三个元素的一种规则)
(3)逻辑运算类(Logical)仿函数,支持了逻辑运算中的And,Or,Not三种运算,其中And和Or为二元运算,Not为一元运算

#==================================================================== 
20 配接器
配接器在STL组件的灵活组合运用功能上,扮演着轴承,转换器的角色(adapter定义:将一个class的接口转换为另一class的接口,使原本因接口不兼容而不能合作的class,可以一起运作)

#==================================================================== 
21 在遍历中使用 iterator/reverse_iterator 进行 erase 的用法
第一种情形：正向遍历删除元素
对 list 和 vector 来说，它们的erase函数会返回下一个迭代器，因此在遍历时，只需要it = c.erase(it); 即可。
对map和set来说，它们的erase函数返回的void，而在进行erase之后，当前迭代器会失效，无法再用于获取下一个迭代器。因此需要erase之前就获取指向下一个元素的迭代器
第二种情形，反向遍历删除元素 
从一个反向迭代器获得对应的正向迭代器需要使用base()方法,由于所有的 erase 函数都只接受正向迭代器 iterator，所以在进行反向遍历删除元素时，首先需要将 reverse_iterator 转换为 iterator，然后再考虑更新迭代器的问题
先来分析如何将 reverse_iterator 转换为 iterator,我们想要删除正向第三个元素，而正向第三个元素.base() 所得到的正向迭代器指向的其实正向第四个元素，因而为了正确地删除元素正向第三个，需要将第三个元素迭代器往前（反向的）挪一个位置
eg:c.erase((++rit).base());  或 c.erase(--(rit.base());  

#====================================================================
22 【C++标准库】STL算法
https://www.cnblogs.com/larry-xia/p/9497340.html

#====================================================================