SELinux学习整理
https://www.tsz.wiki/selinux/AndroidSelinux/Selinux.html#_1-%E7%8E%B0%E6%9C%89%E6%9D%83%E9%99%90%E4%BB%8B%E7%BB%8D

权限控制DAC，MAC，RBAC，ABAC
https://blog.csdn.net/u011607686/article/details/89072494

#=======================================================================
// SElinux是通过标签系统来控制主体对客体的读写等访问权限的。每个进程或者其他主体都有一个相关联的标签；我们称之为安全上下文。这个上下文是有user，role，type，MLS四部分组成；
// 1.type我们也称之为domain(域)，这个域必须要在SELinux策略中进行定义；
// 2.一个主体的标签常常由对应的安全上下文文件所决定；


#=======================================================================
1. 现有权限介绍
现有的权限：
一.自主式访问控制，DAC(Discretionary Access Control)
1.主体对它所属的对象和运行的程序拥有全部的控制权
2.被某个用户执行的程序又有与该用户相同的权限
3.拥有对象权限的用户，又可以将该对象的权限分配给其他用户，所以称之为"自主(Discretionary)"控制
这种设计最常见的应用就是文件系统的权限设计，如微软的NTFS

二.强制访问控制,MAC(Mandatory Access Control)
MAC是为了弥补DAC权限控制过于分散的问题而诞生的
1.在MAC这种模型里，管理员管理访问控制。管理员制定策略，用户不能改变它。策略定义了哪个主体能访问哪个对象。
    这种访问控制模型可以增加安全级别，因为它基于策略，任何没有被显式授权的操作都不能执行。
2.工作机制是"need to know basis"，即最少的特权，用户只能访问他工作需要的对象。同时，主体不能向下写，即他们不能写或创建低于自己级别的标记的对象。
    这防止了主体把秘密和低于它的级别的主体共享，从而保证信息秘密

三.基于角色的访问控制,RBAC(Role-Based Access Control)
    因为DAC和MAC的诸多限制，于是诞生了RBAC，并且成为了迄今为止最为普及的权限设计模型。用户-角色-权限

四.基于属性的权限验证，ABAC(Attribute-Based Access Control)
    不同于常见的将用户通过某种方式关联到权限的方式，ABAC则是通过动态计算一个或一组属性来满足某种条件来进行授权判断(可以编写简单的逻辑)。属性通常来说分为四类：用户属性(如用户年龄),环境属性(如当前时间)，操作属性(如读取)和对象属性


#=======================================================================
2. SELinux权限控制
SELinux权限控制：委任式访问控制，MAC**他可以针对特定的程序与特定的档案资源来进行权限的控管！也就是说，即使你是root，那么在使用不同的程序时，你所能取得的权限并不一定是root，而得要看当时该程序的设定而定。如此一来，我们针对控制的主体变成了程序而不是用户。此外，这个主体程序也不能任意使用系统档案资源，因为每个档案资源也有针对该主体程序设定可取用的权限.**
如此一来，控件目就细的多了！SELinux也提供一些预设的政策(Policy),并在该政策内提供多个(rule),让你可以选择是否启用该控制规则

#=======================================================================
3. SELinux的运作模式
SELinux是透过MAC的方式来控管程序，他控制的主体是程序，而目标则是该程序能否读取的档案资源，所以先来说明一下这些的相关性
主体(Subject):SELinux主要想要管理的就是程序，因此你可以将主体跟process划上等号；
目标(Object):主体程序能否存取的目标资源一般就是文件系统，因此这个目标项目可以和文件系统划上等号；
政策(Policy):由于程序与档案数量庞大，因此SELinux会一句某些服务来制定基本的存取安全性政策。这些政策内还会有详细的规则(rule)来制定不同的服务开放某些资源的存取与否
安全性本文(security context):我们刚刚谈到了主体。目标与政策面，但是主体能不能存取目标除了政策指定之外，主体与目标的安全性本文必须一致才能够顺利存取。这个安全性本文(security context)有点类似文件系统的rwx。安全性本文的内容与设定是非常重要的！如果设定错误，你的某些服务(主体程序)就无法存取文件系统(目标资源)，当然就会一直出现权限不符的错误
安全性本文存在于主体程序中与目标档案资源中。程序在内存内，所以安全性本文可以存入是没问题。那档案的安全性本文是记录在哪里呢？事实上，安全性本文是放置到档案的inode内的，因此主体程序想要读取目标档案资源时，同样需要读取inode，这inode内就可以比对安全性本文以及rwx等权限值是否正确，而给予适当的读取权限依据。
先看系统中的安全性文本：
1.先看文件的安全性文本
ls -Z
drwxr-xr-x root     root              u:object_r:cgroup:s0 acct
drwxrwx--- system   cache             u:object_r:cache_file:s0 cache
lrwxrwxrwx root     root              u:object_r:rootfs:s0 charger -> /sbin/healthd
dr-x------ root     root              u:object_r:rootfs:s0 config
lrwxrwxrwx root     root              u:object_r:rootfs:s0 d -> /sys/kernel/debug
drwxrwx--x system   system            u:object_r:system_data_file:s0 data
-rw-r--r-- root     root              u:object_r:rootfs:s0 default.prop
drwxr-xr-x root     root              u:object_r:device:s0 dev
lrwxrwxrwx root     root              u:object_r:rootfs:s0 etc -> /system/etc
-rw-r--r-- root     root              u:object_r:rootfs:s0 file_contexts
dr-xr-x--- system   system            u:object_r:firmware_file:s0 firmware
-rw-r----- root     root              u:object_r:rootfs:s0 fstab.qcom
2.在看下进程的安全性文本：
u:r:init:s0                    root      1     0     /init
u:r:kernel:s0                  root      2     0     kthreadd
u:r:kernel:s0                  root      3     2     ksoftirqd/0
u:r:kernel:s0                  root      6     2     kworker/u:0
u:r:kernel:s0                  root      7     2     kworker/u:0H
u:r:kernel:s0                  root      8     2     migration/0
u:r:kernel:s0                  root      9     2     watchdog/0
u:r:kernel:s0                  root      25    2     khelper
u:r:kernel:s0                  root      26    2     netns
u:r:kernel:s0                  root      31    2     kworker/0:1H
u:r:kernel:s0                  root      32    2     modem_notifier
u:r:kernel:s0                  root      33    2     smd_channel_clo
u:r:kernel:s0                  root      34    2     smsm_cb_wq
如上所示：安全性本文主要用冒号分为三个字段，这三个字段的意义未：
Identify：Role：Type[:Range]身份识别：角色：类型
这三个字段的意义仔细的说明一下吧：
身份识别(Identify)：相当于账号方面的身份识别！主要的身份识别则有地下三种常见的类型：
(1)root:标识root的账号身份，如同上面的表格显示的是root家目录下的数据
(2)system_u:表示系统程序方面的识别，通常就是程序
(3)user_u:代表的是一般使用者账号相关的身份

你会发现身份识别中，除了root之外，其他的识别后面都会加上_u的字样，这个身份识别重点在让我们了解该数据为何种身份所有，而系统上面大部分的数据都会是system_u或root。至于如果是在/home底下的数据，那么大部分应该就会是user_u

角色(Role):透过角色字段，我们可以直到这个数据是属于程序，档案资源还是

#=======================================================================




#=======================================================================




#=======================================================================




#=======================================================================



#=======================================================================




#=======================================================================




#=======================================================================



#=======================================================================



#=======================================================================




#=======================================================================