Boost库学习
#====================================================================
1. boost库安装
 (1)http://www.boost.org 下载最新版本的boost库源代码
 (2)解压进入,执行命令: ./booststrap.sh (编译前的配置工作)
 (3)执行命令: ./b2 install (编译并安装boost)
 (4)如果像上面这样不指定额外选项,Boost将编译release版本的库文件,把头文件安装到
 "/usr/local/include",库文件安装到"/usr/local/lib"

#====================================================================
2. 智能指针
 (1)scoped_ptr是一种"智能指针",因此其行为与普通的指针基本相同,可以使用非常熟悉的"*"和"->"操作符 ,它将拷贝构造函数和赋值函数都声明为私有的,不允许拷贝构造或赋值.使用scoped_ptr会带来两个好处:一是使代码变的清晰简单,而简单意味着更少的错误,二是它并没有用增加多余的操作,安全的同时保证了效率,可以获得与原始指针同样的速度

 (2)因为auto_ptr存在缺陷,C++11借鉴boost库里的智能指针
#====================================================================
3. pool库学习
pool库包含四个组成部分:最简单的pool,分配实例的object_pool,单件内存池singleton_pool和可用与标准库的pool_alloc

3.1 pool的构造函数接受一个size_type类型的整数,指示分配内存块的大小(而不是我内存池的大小)

3.2 一般情况内存池会自动管理内存分配,不应该是调用free(),除非你认为内存池的空间已经不足,必须释放已经分配的内存

3.3 pool库它只能作为普通数据类型如int,double等的内存池,不能应用于复杂的类和对象,因为它只能分配内存,不能调用构造函数,这个时候我们需要用object_pool
#====================================================================
4 object_pool库学习
object_pool是用于类实例(对象)的内存池,它的功能与pool类似,但它会在析构时对所有已经分配的内存块调用析构函数,从而正确地释放资源

4.1 一旦在模板中指定了类型,object_pool实例就不能在用于分配其他类型的对象
#====================================================================
5 assign库学习
assign库重载了赋值操作符"+=",逗号操作符",",和括号操作符"()"可以用难以想象的简介语法非常方便的对标准容器赋值或者初始化

#====================================================================
6 trilbool库学习
boost.tribool是基于三态的bool逻辑
对tribool的操作都是通过逻辑运算符和比较运算符的重载来完成的,支持的逻辑运算包括||,&&和!,比较运算支持==和!=,这些操作都可以任意混合bool和tribool一起运算

#====================================================================
7 operators库学习
boost.operators库它采用std::rel_ops的实现手法,允许用户在自己的类里仅定义少量的操作符(如"<")就可以方便地自动生成其他操作符重载,而且保证正确的语义实现
因为很多运算可以由基本运算转变而来.
优化的主要方式是进行等号操作符的重载和一节抽象类的定义

#====================================================================
8 字符串与文本处理
format学习
boost.format库"扬弃"了printf,实现了类似于printf()的格式化对象,可以把参数格式化到一个字符串,而且是完全类型安全的
eg1:
boost::format fmt("(%1% + %2%) * %2% = %3%\n");
fmt % 2 % 5;
fmt % ((2+5)*6);
std::cout<<fmt.str()<<std::endl; //42
eg2:
format("%s:%d+%d=%d\n") %"sum" %1 %2 %(1+2); //sum:1+2=3

format并不是一个真正的类,而是一个typedef,真正的实现是basic_fromat
format基本继承了printf的格式化语法,每个printf格式化选项以%开始,后面是格式规则,规定了输出的对齐,宽度,精度,字符类型
eg:
%05d  输出宽度为5的整数,不足位用0填充
%-8.3f  输出左对齐,总宽度位8,小数位3位的浮点数
% 10是 输出10位的字符串,不足位用空格填充

优点:printf()不进行类型检查,直接向stdout输出,因此它的速度非常快,而format较printf()做了很多安全检查的工作,因此性能略差,速度上要慢一些
还有很多高级用法比如绑定参数设置输出方式和格式详见资料或书籍

#====================================================================
9.string_ref
boost.string_ref是一种轻量级的字符串,顾名思义,它只持有字符串的引用,没有内存拷贝成本,所以运行效率很高,是更好的const std::string&它已被收入C++17标准(但更名为string_view)

string_ref实际类名class basic_string_ref
使用 typedef basic_string_ref<char> string_ref
basic_string_ref的工作原理很简单的,它不拷贝字符串,所以也就不分配内存,只用两个成员变量ptr_和len_标记字符串的起始位置和长度,这样就是实现了字符串的表示.
但是需要注意,basic_string_ref是一个很字符串的"常量视图",大部分成员函数都是const修饰的,我们只能像const std::string&那样去观察字符串而无法修改字符串

9.1 string_algo它是一个非常全面的字符串算法库,提供了大量的字符串操作函数,如大小写无关比较,修剪,特定模式的字符串查找的那个,可在不使用正则表达式的情况下处理大多数字符串相关问题
string_algo库提供的算法共分五大类:
1.大小写转换
2.判断式与分类:判断式算法可以检测两个字符串之间的关系,分类可以用于检测一个字符是否符合某些特性,主要用于搭配其他算法
3.修剪:修剪算法可以删除字符串开头或结尾部分的空格
4.查找与替换
5.分割和合并
#====================================================================
10.xpressive正则表达式
xpressive不仅是一个类似std::regex的正则表达式解析器,同时它还是一个类似于boost.spirit的语法分析器,并且将这两种完全不相关的文本处理方式完美的融合在一起

#====================================================================
11.assert断言库
BOOST_ASSERT是标准断言宏assert的增强版,因此它有更多的使用灵活性
assert库定义了两个断言宏
#define BOOST_ASSERT(expr)            assert(expr)
#define BOOST_ASSERT_MSG(expr,msg)    assert((expr) && (msg))

11.1 禁用断言
如果在头文件<boost/assert.hpp>之前定义了宏BOOST_DISABLE_ASSERTS,那么BOOST_ASSERT将会定义为((void)0),自动失效.但标准的assert宏并不会受影响,这可以让程序员有选择的关闭BOOST_ASSERT
扩展用法,如果在头文件<boost/assert.hpp>之前定义了宏BOOST_ENABLE_ASSERT_HANDLER,这将导致BOOST_ASSERT的行为发生改变,它将不再等同于assert宏,断言的表达式无论是在debug还是release模式下都将被求值

11.2 assert宏和BOOST_ASSERT宏是用于运行时断言,但有时候,运行时断言太晚了,static_assert库把断言的诊断时刻由运行期提前到编译器,让编译器检查可能发生的错误,能够更好地增加程序的健壮性
BOOST_STATIC_ASSERT是一个编译期断言,使用了模板元编程技术实现,虽然在很多方面都与BOOST_ASSERT很相似,但用法还是有所不同的.最重要的区别是使用范围:
BOOST_ASSERT(expr)必须是一个能够执行的语句,它只能在函数域里出现,而BOOST_STATIC_ASSERT则可以出现在程序的任何位置:名字空间域,类域或函数域
使用:static_assert主要在泛型编程或模板元变成中用于验证编译期常数或者模板参数

#====================================================================
12. lightweight_test
lightweight_test是一个轻量级的单元测试框架,不支持测试用例,测试套件的概念,但因为简单小巧,适合要求不高或快速的测试工作

#====================================================================
13. 容器与数据结构
array包装了C++语言内建的数组,为其提供标准的容器接口.速度,性能上与原始数组相差无几,在程序对性能要求很高,或者不需要动态数组的情况下可以使用.现在它已经是C++标准库的一部分
模板类array本质上是一个很对静态数组的包装,因此它不完全符合标准容器的定义,不具有标准容器的许多功能,虽然它在很多方面很像标准容器
array的能力缺陷主要是:
1.没有构造函数,不能指定大小和初始值,只能用模板参数指定大小再用fill()填充;
2.没有push_back()和push_front(),因为他不能动态增长.
3.不能搭配插入迭代器适配器功能,同样因为它不能动态增长.
对比标准
array被收入C++标准后做了一些修订,区别是
1.接口使用noexcept关键字保证不抛出异常;
2.接口使用constexpr替代static保证函数在编译期优化;
3.没有c_array()操作;
4.没有operator=赋值操作符
array 定义的时候必须定义数组的元素个数;而vector 不需要；array只能包含整型字面值常量，枚举常量或者用常量表达式初始化的整型const对象，
非const变量以及需要到运行阶段才知道其值的const变量都不能用来定义数组的维度.

#====================================================================
14.散列集合ybirdered_set用法
unordered库提供两个散列集合列,unordered_set和unordered_multiset,他们的接口,用法与C++标准里的关联容器set/multiset相同,只是内部使用散列表代替了二叉树的实现,因此查找复杂度由对数降为常数.
除了以上的基本用法之外,unordered_set还与C++标准定义的散列容器完全兼容---支持移动语句std::move()和新的emplace方法

#====================================================================
15.散列映射简介
unordered库提供两个散列映射类unordered_map和unordered_mutimap,他们的接口,用法与C++标准里的关联容器map/mutimap相同,内部使用散列表代替了二叉树的实现,模板参数多了散列计算函数
unordered库支持C++内建类型和大多数标准库容器,但不支持用户自定义类型的类型,因为它无法计算自定义类型的散列值
如果要使unorderred支持自定义类型,需要定制类模板的第二个和第三个参数,也就是提供散列函数和相等比较谓词

#====================================================================
16.C++标准提供了映射型容器map和multi_map,它们相当于关联数组,把一个元素(key)映射到另一个元素(value),但这种映射关系是单项的,只能key到value,而不能反过来.
boost.bitmap扩展了标准库的映射型容器,提供双向映射的能力,功能强大,,其接口被特意设计为符合标准容器规范

#====================================================================
17.assign库学习初始化容器
assign库提供三个工厂函数list_of(),map_list_of()/pair_list_of()和tuple_list_of(),它们能够产生generic_list对象,然后我们就可以像list_inserter一样使用operator()和operator,来填充数据
eg:
vector<int> v = list_of(1) (2) (3) (4) (5);
//v= [1,2,3,4,5]
deque<string> d= (list_of("power")("bomb"),"bomb","suit")
//d = ["power","bomb","bomb","suit"]

使用list_of()处理map容器不是很方便,于是map_list_of()/pair_list_of()应运而生,map_list_of可以接受两个参数,然后自动构造std::pair对象插入map容器,pair_list_of()则纯粹是pair_list_if()的同义词,两者的用法功能完全相同

tuple_list_of用于初始化元素类型为tuple的容器,tuple是Boost引入的一种新的容器/数据结构

#====================================================================
18. circular_buffer
circular_buffer实现了循环缓冲区的数据结构,支持标准的容器操作(如push_back)但大小是固定的,当到达容器末尾时将自动循环利用容器另一端的空间
用法:
circular_buffer被设计成一种可以与标准容器无缝结合使用的容器,实现了一个大小固定的循环队列,就像是一个deque和stack的混合体,可以像普通双端队列一样执行push_back(),push_front(),insert()等操作来增加元素,也可以像栈一样用pop_back(),pop_front()来弹出元素,它也具有标准容器的共通功能,如判断大小,获取迭代器,删除元素,operator[]等
可以使用assign的list_of来初始化
circular_buffer为这种环形结构提供以下几个特殊的操作函数
1.full() 判断缓冲区是否已满
2.linearize()可以把缓冲区线性化成一个连续的普通数组
3.is_linearized()检测缓冲区是否已经线性化
4.rotate()从指定的迭代器位置旋转整个缓冲区
空间优化
circular_buffer库提供了一个circular_buffer_space_optimized类,它是circular_buffer的适配器,只有在确实需要时才分配内存空间,而且当容器内元素减少时也会自动释放内存
#====================================================================
19.tuple(元组)
tuple(元组)定义了一个有固定数目元素的容器,其中每个元素类型都可以的不同,这与其他容器有着本质的区别.tuple很有用,它是std::pair的泛华,可以从函数返回任意数量的值,也可以替代struct组合数据
19.2 创建与赋值
tuple默认最多支持10个模板类型参数,也就是说它最多能容纳10个不同类型的元素,tuple对元素的类型没有特殊的要求,但如果类型不支持默认构造或者赋值操作,那么tuple也会相应地缺失功能.特别的,元素也可以是tuple,也就是说tuple支持嵌套定义.
如果tuple的元素类型是引用,那么在初始化时必须给予初值.
如果想让make_tuple生产的tuple数据类型是引用,那么要用到ref库的ref()和cref()函数,
详细用法参考Boost书籍P260
19.3 内部结构
tuple的内部结构是一个部件(cons)的链表
19.4 遍历tuple中的元素
无法使用get()和for循环的方式遍历tuple中的元素
因为get是一个模板函数,编译进行模板实例化时要求模板参数<int N>必须是编译期可确定的,而for循环中的变量i只能在运行时确定
正确的遍历方法使用print_tuple()函数,因为tuple内部是一个链表print_tuple()函数通过递归遍历获得头节点来实现的
19.5 代替struct
tuple的构造和访问函数都是内联的,因而很容易被编译器优化,一个tuple和一个持有同样元素类型的struct几乎拥有同样的运行时性能,因此我们完全可以用tuple来替代struct来打包数据
19.6 对比标准
tuple类已经是C++标准库的一部分与Boost库中的存在一些差异
1.支持右值引用共和转移语义
2.使用可变参数模板,支持不限数量的类型
3.兼容std::pair,具有互操作性
4.提供swap成员函数,支持交换操作
5.提供新的forward_as_tuple()和tuple_cat()工厂函数;
6.没有成员get()
7.元函数tuple_element和tuple_size,对应boost::tuple的element和length
#====================================================================
20. property_tree是一个保存了多个属性值的树形数据结构,property_tree特别适合与应用程序的配置数据处理,可以解析XML/JSON/INI/INFO四种格式的文本数据

20.1 写入配置信息
property_tree不仅能够读取配置信息,也可以写入配置信息


#====================================================================