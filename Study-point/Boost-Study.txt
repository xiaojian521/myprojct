Boost库学习
#=================================================================== 
1. boost库安装
 (1)http://www.boost.org 下载最新版本的boost库源代码
 (2)解压进入,执行命令: ./booststrap.sh (编译前的配置工作)
 (3)执行命令: ./b2 install (编译并安装boost)
 (4)如果像上面这样不指定额外选项,Boost将编译release版本的库文件,把头文件安装到
 "/usr/local/include",库文件安装到"/usr/local/lib"

#====================================================================
2. 智能指针
 (1)scoped_ptr是一种"智能指针",因此其行为与普通的指针基本相同,可以使用非常熟悉的"*"和"->"操作符 ,它将拷贝构造函数和赋值函数都声明为私有的,不允许拷贝构造或赋值.使用scoped_ptr会带来两个好处:一是使代码变的清晰简单,而简单意味着更少的错误,二是它并没有用增加多余的操作,安全的同时保证了效率,可以获得与原始指针同样的速度

 (2)因为auto_ptr存在缺陷,C++11借鉴boost库里的智能指针
#====================================================================
3. pool库学习
pool库包含四个组成部分:最简单的pool,分配实例的object_pool,单件内存池singleton_pool和可用与标准库的pool_alloc

3.1 pool的构造函数接受一个size_type类型的整数,指示分配内存块的大小(而不是我内存池的大小)

3.2 一般情况内存池会自动管理内存分配,不应该是调用free(),除非你认为内存池的空间已经不足,必须释放已经分配的内存

3.3 pool库它只能作为普通数据类型如int,double等的内存池,不能应用于复杂的类和对象,因为它只能分配内存,不能调用构造函数,这个时候我们需要用object_pool
#====================================================================
4 object_pool库学习
object_pool是用于类实例(对象)的内存池,它的功能与pool类似,但它会在析构时对所有已经分配的内存块调用析构函数,从而正确地释放资源

4.1 一旦在模板中指定了类型,object_pool实例就不能在用于分配其他类型的对象
#====================================================================
5 assign库学习
assign库重载了赋值操作符"+=",逗号操作符",",和括号操作符"()"可以用难以想象的简介语法非常方便的对标准容器赋值或者初始化

#====================================================================
6 trilbool库学习
boost.tribool是基于三态的bool逻辑
对tribool的操作都是通过逻辑运算符和比较运算符的重载来完成的,支持的逻辑运算包括||,&&和!,比较运算支持==和!=,这些操作都可以任意混合bool和tribool一起运算

#====================================================================
7 operators库学习
boost.operators库它采用std::rel_ops的实现手法,允许用户在自己的类里仅定义少量的操作符(如"<")就可以方便地自动生成其他操作符重载,而且保证正确的语义实现
因为很多运算可以由基本运算转变而来.
优化的主要方式是进行等号操作符的重载和一节抽象类的定义

#====================================================================
8 字符串与文本处理
format学习
boost.format库"扬弃"了printf,实现了类似于printf()的格式化对象,可以把参数格式化到一个字符串,而且是完全类型安全的
eg1:
boost::format fmt("(%1% + %2%) * %2% = %3%\n");
fmt % 2 % 5;
fmt % ((2+5)*6);
std::cout<<fmt.str()<<std::endl; //42
eg2:
format("%s:%d+%d=%d\n") %"sum" %1 %2 %(1+2); //sum:1+2=3

format并不是一个真正的类,而是一个typedef,真正的实现是basic_fromat
format基本继承了printf的格式化语法,每个printf格式化选项以%开始,后面是格式规则,规定了输出的对齐,宽度,精度,字符类型
eg:
%05d  输出宽度为5的整数,不足位用0填充
%-8.3f  输出左对齐,总宽度位8,小数位3位的浮点数
% 10是 输出10位的字符串,不足位用空格填充

优点:printf()不进行类型检查,直接向stdout输出,因此它的速度非常快,而format较printf()做了很多安全检查的工作,因此性能略差,速度上要慢一些
还有很多高级用法比如绑定参数设置输出方式和格式详见资料或书籍

#====================================================================
9.string_ref
boost.string_ref是一种轻量级的字符串,顾名思义,它只持有字符串的引用,没有内存拷贝成本,所以运行效率很高,是更好的const std::string&它已被收入C++17标准(但更名为string_view)

string_ref实际类名class basic_string_ref
使用 typedef basic_string_ref<char> string_ref
basic_string_ref的工作原理很简单的,它不拷贝字符串,所以也就不分配内存,只用两个成员变量ptr_和len_标记字符串的起始位置和长度,这样就是实现了字符串的表示.
但是需要注意,basic_string_ref是一个很字符串的"常量视图",大部分成员函数都是const修饰的,我们只能像const std::string&那样去观察字符串而无法修改字符串

9.1 string_algo它是一个非常全面的字符串算法库,提供了大量的字符串操作函数,如大小写无关比较,修剪,特定模式的字符串查找的那个,可在不使用正则表达式的情况下处理大多数字符串相关问题
string_algo库提供的算法共分五大类:
1.大小写转换
2.判断式与分类:判断式算法可以检测两个字符串之间的关系,分类可以用于检测一个字符是否符合某些特性,主要用于搭配其他算法
3.修剪:修剪算法可以删除字符串开头或结尾部分的空格
4.查找与替换
5.分割和合并
#====================================================================
10.xpressive正则表达式
xpressive不仅是一个类似std::regex的正则表达式解析器,同时它还是一个类似于boost.spirit的语法分析器,并且将这两种完全不相关的文本处理方式完美的融合在一起

#====================================================================
11.assert断言库
BOOST_ASSERT是标准断言宏assert的增强版,因此它有更多的使用灵活性
assert库定义了两个断言宏
#define BOOST_ASSERT(expr)            assert(expr)
#define BOOST_ASSERT_MSG(expr,msg)    assert((expr) && (msg))

11.1 禁用断言
如果在头文件<boost/assert.hpp>之前定义了宏BOOST_DISABLE_ASSERTS,那么BOOST_ASSERT将会定义为((void)0),自动失效.但标准的assert宏并不会受影响,这可以让程序员有选择的关闭BOOST_ASSERT
扩展用法,如果在头文件<boost/assert.hpp>之前定义了宏BOOST_ENABLE_ASSERT_HANDLER,这将导致BOOST_ASSERT的行为发生改变,它将不再等同于assert宏,断言的表达式无论是在debug还是release模式下都将被求值

11.2 assert宏和BOOST_ASSERT宏是用于运行时断言,但有时候,运行时断言太晚了,static_assert库把断言的诊断时刻由运行期提前到编译器,让编译器检查可能发生的错误,能够更好地增加程序的健壮性
BOOST_STATIC_ASSERT是一个编译期断言,使用了模板元编程技术实现,虽然在很多方面都与BOOST_ASSERT很相似,但用法还是有所不同的.最重要的区别是使用范围:
BOOST_ASSERT(expr)必须是一个能够执行的语句,它只能在函数域里出现,而BOOST_STATIC_ASSERT则可以出现在程序的任何位置:名字空间域,类域或函数域
使用:static_assert主要在泛型编程或模板元变成中用于验证编译期常数或者模板参数

#====================================================================
12. lightweight_test
lightweight_test是一个轻量级的单元测试框架,不支持测试用例,测试套件的概念,但因为简单小巧,适合要求不高或快速的测试工作

#====================================================================
13. 容器与数据结构
array包装了C++语言内建的数组,为其提供标准的容器接口.速度,性能上与原始数组相差无几,在程序对性能要求很高,或者不需要动态数组的情况下可以使用.现在它已经是C++标准库的一部分
模板类array本质上是一个很对静态数组的包装,因此它不完全符合标准容器的定义,不具有标准容器的许多功能,虽然它在很多方面很像标准容器
array的能力缺陷主要是:
1.没有构造函数,不能指定大小和初始值,只能用模板参数指定大小再用fill()填充;
2.没有push_back()和push_front(),因为他不能动态增长.
3.不能搭配插入迭代器适配器功能,同样因为它不能动态增长.
对比标准
array被收入C++标准后做了一些修订,区别是
1.接口使用noexcept关键字保证不抛出异常;
2.接口使用constexpr替代static保证函数在编译期优化;
3.没有c_array()操作;
4.没有operator=赋值操作符
array 定义的时候必须定义数组的元素个数;而vector 不需要；array只能包含整型字面值常量，枚举常量或者用常量表达式初始化的整型const对象，
非const变量以及需要到运行阶段才知道其值的const变量都不能用来定义数组的维度.

#====================================================================
14.散列集合ybirdered_set用法
unordered库提供两个散列集合列,unordered_set和unordered_multiset,他们的接口,用法与C++标准里的关联容器set/multiset相同,只是内部使用散列表代替了二叉树的实现,因此查找复杂度由对数降为常数.
除了以上的基本用法之外,unordered_set还与C++标准定义的散列容器完全兼容---支持移动语句std::move()和新的emplace方法

#====================================================================
15.散列映射简介
unordered库提供两个散列映射类unordered_map和unordered_mutimap,他们的接口,用法与C++标准里的关联容器map/mutimap相同,内部使用散列表代替了二叉树的实现,模板参数多了散列计算函数
unordered库支持C++内建类型和大多数标准库容器,但不支持用户自定义类型的类型,因为它无法计算自定义类型的散列值
如果要使unorderred支持自定义类型,需要定制类模板的第二个和第三个参数,也就是提供散列函数和相等比较谓词

#====================================================================
16.C++标准提供了映射型容器map和multi_map,它们相当于关联数组,把一个元素(key)映射到另一个元素(value),但这种映射关系是单项的,只能key到value,而不能反过来.
boost.bitmap扩展了标准库的映射型容器,提供双向映射的能力,功能强大,,其接口被特意设计为符合标准容器规范

#====================================================================
17.assign库学习初始化容器
assign库提供三个工厂函数list_of(),map_list_of()/pair_list_of()和tuple_list_of(),它们能够产生generic_list对象,然后我们就可以像list_inserter一样使用operator()和operator,来填充数据
eg:
vector<int> v = list_of(1) (2) (3) (4) (5);
//v= [1,2,3,4,5]
deque<string> d= (list_of("power")("bomb"),"bomb","suit")
//d = ["power","bomb","bomb","suit"]

使用list_of()处理map容器不是很方便,于是map_list_of()/pair_list_of()应运而生,map_list_of可以接受两个参数,然后自动构造std::pair对象插入map容器,pair_list_of()则纯粹是pair_list_if()的同义词,两者的用法功能完全相同

tuple_list_of用于初始化元素类型为tuple的容器,tuple是Boost引入的一种新的容器/数据结构

#====================================================================
18. circular_buffer
circular_buffer实现了循环缓冲区的数据结构,支持标准的容器操作(如push_back)但大小是固定的,当到达容器末尾时将自动循环利用容器另一端的空间
用法:
circular_buffer被设计成一种可以与标准容器无缝结合使用的容器,实现了一个大小固定的循环队列,就像是一个deque和stack的混合体,可以像普通双端队列一样执行push_back(),push_front(),insert()等操作来增加元素,也可以像栈一样用pop_back(),pop_front()来弹出元素,它也具有标准容器的共通功能,如判断大小,获取迭代器,删除元素,operator[]等
可以使用assign的list_of来初始化
circular_buffer为这种环形结构提供以下几个特殊的操作函数
1.full() 判断缓冲区是否已满
2.linearize()可以把缓冲区线性化成一个连续的普通数组
3.is_linearized()检测缓冲区是否已经线性化
4.rotate()从指定的迭代器位置旋转整个缓冲区
空间优化
circular_buffer库提供了一个circular_buffer_space_optimized类,它是circular_buffer的适配器,只有在确实需要时才分配内存空间,而且当容器内元素减少时也会自动释放内存
#====================================================================
19.tuple(元组)
 (元组)定义了一个有固定数目元素的容器,其中每个元素类型都可以的不同,这与其他容器有着本质的区别.tuple很有用,它是std::pair的泛化,可以从函数返回任意数量的值,也可以替代struct组合数据
19.2 创建与赋值
tuple默认最多支持10个模板类型参数,也就是说它最多能容纳10个不同类型的元素,tuple对元素的类型没有特殊的要求,但如果类型不支持默认构造或者赋值操作,那么tuple也会相应地缺失功能.特别的,元素也可以是tuple,也就是说tuple支持嵌套定义.
如果tuple的元素类型是引用,那么在初始化时必须给予初值.
如果想让make_tuple生产的tuple数据类型是引用,那么要用到ref库的ref()和cref()函数,
详细用法参考Boost书籍P260
19.3 内部结构
tuple的内部结构是一个部件(cons)的链表
19.4 遍历tuple中的元素
无法使用get()和for循环的方式遍历tuple中的元素
因为get是一个模板函数,编译进行模板实例化时要求模板参数<int N>必须是编译期可确定的,而for循环中的变量i只能在运行时确定
正确的遍历方法使用print_tuple()函数,因为tuple内部是一个链表print_tuple()函数通过递归遍历获得头节点来实现的
19.5 代替struct
tuple的构造和访问函数都是内联的,因而很容易被编译器优化,一个tuple和一个持有同样元素类型的struct几乎拥有同样的运行时性能,因此我们完全可以用tuple来替代struct来打包数据
19.6 对比标准
tuple类已经是C++标准库的一部分与Boost库中的存在一些差异
1.支持右值引用共和转移语义
2.使用可变参数模板,支持不限数量的类型
3.兼容std::pair,具有互操作性
4.提供swap成员函数,支持交换操作
5.提供新的forward_as_tuple()和tuple_cat()工厂函数;
6.没有成员get()
7.元函数tuple_element和tuple_size,对应boost::tuple的element和length
#====================================================================
20. property_tree是一个保存了多个属性值的树形数据结构,property_tree特别适合与应用程序的配置数据处理,可以解析XML/JSON/INI/INFO四种格式的文本数据

20.1 写入配置信息
property_tree不仅能够读取配置信息,也可以写入配置信息

#====================================================================
21. foreach学习
foreach库提供两个宏BOOST_FOREACH和BOOST_REVERSE_FOREACH,分别来实现对序列的正向遍历和反向遍历
eg:
BOOST_FOREACH(auto& c, str)  //遍历string容器
注:auto关键字也可以加const或者&来修饰,用来推导常量或者引用类型,通常用auto&的形式最好,可以避免无谓的拷贝
使用前提:假设序列是稳定的,也就是说在BOOST_FOREACH循环中不能改变序列的长度,也不能增减序列的元素,否则会导致遍历使用的迭代器失效,发生未定义错误.
#define BOOST_FOREACH(VAR, COL)
通常情况下VAR可以直接声明循环变量,但在BOOST_FOREACH循环中获得的将是序列内元素的拷贝,可以使用但无法修改,如果想搞笑地使用序列内元素或者修改序列,则需要声明时使用引用的形式如上面例子

21.1 如果觉得大写的宏太过耀眼可以在定义一个宏来替代

21.2 支持的序列类型
BOOST_FOREACH支持所有标准容器,原始数组,C字符串以及元素迭代器的std::pair,此外还支持Boost库内的大部分容器类型

#====================================================================
22. 操作系统相关
22.1 filesystem没有细看是一个可移植的文件系统操作库,已被收入C++17标准,它在底层做了大量的工作,使用POSIX标准表示文件系统的路径,接口很类似标准库的容器和迭代器,是C++具有了类似脚本语言的功能每课一练跨平台操作目录,文件,写出通用的脚本程序

#====================================================================
23. ref库
reference_wrapper的名字过长,声明包装对象很不方便,因而ref库提供了两个便捷的工厂函数ref()和cref(),可以通过参数类型推到很容易的构造reference_wrapper对象

#====================================================================
24. bind
bind是对C++98标准中函数适配器的泛化和增强,可以适配任意的可调用对象,包括函数指针,函数引用,成员函数指针,函数对象和lambda表达式
bind采用拷贝的方式存储绑定对象和参数,这意味着绑定表达式中的每个变量都会有一份拷贝,如果函数对象或值参数很大,拷贝代价很高,或者无法拷贝,可以搭配ref库使用
工作原理
24.1 bind接受的第一个参数必须是一个可调用对象f,可以是函数,函数指针,函数对象或成员函数指针,绑定完成后,bind会返回一个函数对象,它内部保存了f的拷贝,具有operator(),返回值类型被自动推导为f的返回值类型,这个函数对象将把之前存储的参数转发给f完成调用.
24.2 bind同样支持绑定虚拟成员函数,用法与非虚函数相同,虚函数的行为将由实际调用发生时的实例来决定
24.3 可以绑定函数对象也就是类重载了operator()操作符的类
24.4 很多时候我们需要把写好的bind表达式存储起来,以便稍后再度使用,但bind表达式生成的函数对象类型声明非常复杂,通常无法写出正确的类型,因此可以使用auto来辅助我们
24.5 bind的标准形式也不能支持使用了不同的调用方式(如__stdcall,__fastcall,extern "C")的函数,通常bind把他们看做函数对象,需要显示的指定bind的返回值类型才能绑定

#====================================================================
25. function
function是一个函数对象的容器是一种"智能函数指针",function可以配合bind/lambda使用,存储bind/lamda表达式的结果,使bind/lambda能够被多次调用
25.1 用于回调,function可以容纳任意符合函数签名式的可调用物,因此它非常适合代替函数指针存储用于回调的函数,而且它的强大功能会使代码更灵活更富有弹性
25.2 function还可以搭配bind库,把bind表达式作为回调函数,可以接受类成员函数,或者把不符合函数签名式的函数bind为可接受的形式
25.3 对比auto
有的时候关键字auto可以近似的取代function,但他们实现有很大的不同,function类似一个容器,可以容纳任意有operator()的类型(函数指针,函数对象,lamda表达式),它是运行时的,可以任意拷贝,赋值,存储其他可调用物,而auto仅是在编译期推导出的一个静态类型变量,它很难在赋以其他值,也无法容纳其他类型,不能用于泛型编程
当需要存储一个可调用物用于回调的时候,最好使用function,它具有更多的灵活性,特别是把回调作为类的一个成员的时候我们只能使用function
auto也有它的优点,它的类型是在编译期推导的,没有运行时的开销,效率上要比function略高一点.但它声明的变量不能存储其他类型的可调用物,不具有灵活性,只能用于有限范围的延后回调

#====================================================================
26. signals2库学习
signals2基于BOOST里的另一个库signals实现了线程安全的观察者模式,在signal2库中,观察者模式被称为信号/插槽(signals/slot),它是一种函数回调机制,一个信号关联多个插槽,当信号发出时,所有关联它的插槽都会被调用
signal就像是一个增强的function对象,它可以容纳(使用connect()连接)多个符合模板参数中函数签名类型的函数(插槽),形成一个插槽链表,然后在信号发生时一起调用
26.1 信号与插槽的连接并不要求是永久的,当信号调用完插槽后,有可能需要把插槽从信号中断开,在连接到其他的信号上去

#====================================================================
27. unique_lock
unique_lock的工作机制与lock_guard相同,同样使用了RAII在构造函数里锁定在析构函数里解锁,但它的构造函数可以接收其他的锁定选项,从而有不同的行为.
unique_lock也不允许拷贝,但它内部使用指针而不是引用来保存互斥量,这使得它可以被转移,用起来更灵活.
unique_lock还拥有与mutex相同的接口,所以允许程序员任意控制锁定/解锁时机,而且最终unique_lock的西沟函数会保证正确的处理互斥量.

#====================================================================
28. thread对象是不可拷贝的,不可比较的,但它支持转移(move)语义,有转移构造函数和转移赋值函数,所以允许从工厂函数产生
在传递参数时需要注意,thread使用的是参数的拷贝,因此要求可调用物和参数类型都支持拷贝构造,如果希望传递给线程引用值就需要使用ref库,进行包装,同时必须保证被引用的对象在线程执行期间一直存在,否则会引发未定义行为.
thread对象在析构时会调用std::terminate结束线程的执行,并不关心我线程是否执行完毕,所以如果要保证函数正确运行必须调用join()等待线程执行结束,或者调用detach()分离线程体

28.1 启动线程,当成功创建了一个thread对象后,线程就立刻开始执行,thread不提供类似start(),begine()那样的方法

#====================================================================
29. shared_mutex
共享互斥量shared_mutex不同于mutex和recursive_mutex,它允许线程获取多个共享所有权和一个专享所有权,实现了读写锁的机制,即多个读线程一个写线程

#====================================================================
30. barrier
barrier是thread库基于条件变量提供的一另一种同步机制,可用于多个线程同步,当线程执行到barrier时必须等待,直到所有的线程都到达这个点时才能继续执行.barrier的另一个人名字rendezvous(约会地点)更形象地描述了这种行为

#====================================================================
31. asio网络通信
asio库支持TCP,UDP,ICMP,等通信协议,提供了大量的网络通信方面的函数和类,很好地封装了原始的Socket API.
具体例子看书实践过可正常进行网络通信

asio库使用前摄器模式实现了同步或异步的I/O操作,提供了UNIX信号,定时器,网络通信,串口通信等许多I/O操作,并且支持使用协程来简化异步代码的编写

31.1 解析网络地址
resolver类对应Socket API getaddrinfo()系列函数,用于解析网址获得可用的IP地址,解析得到的IP地址可以使用socket对象连接.之前关于TCP通信的所有论述我们都是使用直接的IP地址,但在实际生活中大多数时候我们不可能知道socket连接另一端的地址,而只有一个域名,这时候我们就需要使用resolver类来通过域名获得可用的IP,它可以实现与IP版本无关的网址解析

#====================================================================

 