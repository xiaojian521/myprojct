#====================================================================
1.Android广播机制Broadcast详解
  https://www.cnblogs.com/travellife/p/3944363.html
  https://blog.csdn.net/weixin_39460667/article/details/82413819
注: 如果我们设置为静态注册的时候，我们的广播接收器就一个设置为 独立外部类 或者是 静态内部类

#====================================================================
2.AndroidManifest.xml 最全详解
  https://blog.csdn.net/u012486840/article/details/52468931

#====================================================================
3.Java final修饰符：final修饰属性、final修饰方法及final修饰类
  http://c.biancheng.net/view/970.html
1. final 修饰类中的属性
表示该属性一旦被初始化便不可改变，这里不可改变的意思对基本类型来说是其值不可变，而对对象属性来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在 final 属性定义时直接给其赋值；二是在构造函数中。这两个地方只能选其一，要么在定义时给值，要么在构造函数中给值，不能同时既在定义时赋值，又在构造函数中赋予另外的值。
2. final 修饰类中的方法
说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次。
3. final 修饰类
表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。

#====================================================================
4.java关键字abstract(抽象)详解
  https://blog.csdn.net/weixin_40096176/article/details/79094991
  1、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的主体（没有{}包起来的
业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法

2、抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来
说是不能访问的，所以就会产生矛盾

3、抽象方法也不能用static修饰，试想一下，如果用static修饰了，那么我们可以直接通过类名调
用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。

4.抽象类中可以正常使用静态方法

#====================================================================
5.类内创建interface接口,该类可以new对象,但是想调用接口函数则重新new接口类并实现接口

#====================================================================
6.java 不允许多重继承

#====================================================================
7.静态内部类写单例的好处
  https://blog.csdn.net/xiexiaotian11/article/details/88742247

#====================================================================
8.private static与public static的用法及区别（Java）
  https://blog.csdn.net/u013110200/article/details/81331688

#====================================================================
9.Android语音识别（本地+第三方）
  https://blog.csdn.net/liyuanjinglyj/article/details/46127607

#====================================================================
10.android语音识别 android.speech 包分析
   https://blog.csdn.net/almo_omla/article/details/51513779
   https://www.cnblogs.com/androidme/archive/2012/03/07/2384453.html

#====================================================================
11.Android Service设置权限
   http://www.anddle.com/?p=181

#====================================================================
12.java反射机制
   https://www.cnblogs.com/ysocean/p/6516248.html
   一个类在 JVM 中只会有一个 Class 实例,

#====================================================================
13.Android组件系列----Intent详解
   https://www.cnblogs.com/smyhvae/p/3959204.html

#====================================================================
14.Android Service、IntentService，Service和组件间通信
   https://blog.csdn.net/qq_34115898/article/details/83347882

#====================================================================
15.Android Binder机制原理（史上最强理解，没有之一）（转）
   https://www.cnblogs.com/qingchen1984/p/5212755.html

#====================================================================
16.Android.VoiceInteractionService类详解
   Demo源代码
   https://github.com/penglu20/RecentTask
   Bigbang项目
   https://github.com/penglu20/Bigbang

#====================================================================
17.ANDROID 中UID与PID的作用与区别
   https://blog.csdn.net/wi__wi/article/details/51078029
   Pid是进程ID，Uid是用户ID，只是Android和计算机不一样，计算机每个用户都具有一个Uid，哪个用户start的程序，这个程序的Uid就是那个用户，而Android中每个程序都有一个Uid，默认情况下，Android   会给每个程序分配一个普通级别互不相同的 Uid，如果用互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application 只有一个Uid，所以  application下的Activity之间不存在访问权限的问题。

#====================================================================
18.AndroidStudio添加Button点击响应方法
1.通过内部类来实现
eg:
loginButton1 = (Button) findViewById(R.id.login1);
loginButton1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    }
});
2.通过外部类来实现
loginButton2 = (Button) findViewById(R.id.login1);
loginButton2.setOnClickListener(new MyListener());
class MyListener implements View.OnClickListener {
    @Override
    public void onClick(View v) {
    }
}

#====================================================================
19.MVC设计模式
https://www.cnblogs.com/senior-engineer/p/5562794.html

#====================================================================
20.Listview详解
https://www.cnblogs.com/huangjie123/p/5990737.html
ListView 控件的设计正好遵循MVC 设计模式
ArrayAdapter的使用
ArrayAdapter通常用于显示较为简单的数组和集合数据，界面较为简单，直接向ArrayAdapter添加相关的参数即可。

#====================================================================
21.android自定义静态jar包和动态jar包的编译、使用
https://blog.csdn.net/bukker/article/details/51672506

#====================================================================
22.从Android8.0 广播配置AndroidManifest.xml方式大部分是不允许的


#====================================================================