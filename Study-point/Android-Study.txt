
Android系统为每一个应用开启一个独立的虚拟机，每个应用都运行在各自进程里（默认情况下），彼此之间相互独立，无法共享内存。当一个应用想要访问另一个应用的数据或调用其方法，就要用到Android系统提供的IPC机制。而AIDL就是Android实现IPC机制的方式之一。
#==================================================================== 
1.Android广播机制Broadcast详解
  https://www.cnblogs.com/travellife/p/3944363.html
  https://blog.csdn.net/weixin_39460667/article/details/82413819
注: 如果我们设置为静态注册的时候，我们的广播接收器就一个设置为 独立外部类 或者是 静态内部类
静态广播和动态广播的区别:
1. 静态广播在进程没有运行的情况下也会接收广播,假如进程没有启动的话,会优先调用 AMS 中的中的方法,拉起进程,然后处理广播 onReceive 函数。动态广播是在程序中通过代码显示注册的,因此必须要在进程已经运行的时候才能收到广播。
2. 静态广播处理的时候,每次都会创建一个广播接收器的对象,动态广播一般都是同一个广播接收器对象。
3. 静态广播无法接收隐式广播,在 Android 8 以上已经不起作用,个别广播除外。至于为什么要做这一变更,还是为了节省电量,提升续航,增强性能,提高用戶体验。
4. 发送一个无序广播,动态注册的广播要优先于静态的注册的广播,同一个应用内,先注册的接收器先收到广播

广播处理机制:
静态注册的receivers始终采用串行方式来处理； 动态注册的广播处理方式是串行还是并行方式, 取决于广播的发送方式。
注:只有串行广播才需要考虑超时，因为接收者是串行处理的，前一个receiver处理慢，会影响后一个receiver；
动态注册时假如没有在注册的时候指定那个线程来处理，则默认的指定主线程来处理。
为什么静态注册要跟动态注册有区别呢？
重点在于动态注册的时候可以指定处理receiver的handler，而静态注册无法指定，因此只能用主线程处理

#====================================================================
2.AndroidManifest.xml 最全详解
  https://blog.csdn.net/u012486840/article/details/52468931

#====================================================================
3.Java final修饰符：final修饰属性、final修饰方法及final修饰类
  http://c.biancheng.net/view/970.html
1. final 修饰类中的属性
表示该属性一旦被初始化便不可改变，这里不可改变的意思对基本类型来说是其值不可变，而对对象属性来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在 final 属性定义时直接给其赋值；二是在构造函数中。这两个地方只能选其一，要么在定义时给值，要么在构造函数中给值，不能同时既在定义时赋值，又在构造函数中赋予另外的值。
2. final 修饰类中的方法
说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次。
3. final 修饰类
表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。

#====================================================================
4.java关键字abstract(抽象)详解
  https://blog.csdn.net/weixin_40096176/article/details/79094991
  1、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的主体（没有{}包起来的
业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法

2、抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来
说是不能访问的，所以就会产生矛盾

3、抽象方法也不能用static修饰，试想一下，如果用static修饰了，那么我们可以直接通过类名调
用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。

4.抽象类中可以正常使用静态方法

#====================================================================
5.类内创建interface接口,该类可以new对象,但是想调用接口函数则重新new接口类并实现接口

#====================================================================
6.java 不允许多重继承

#====================================================================
7.静态内部类写单例的好处
  https://blog.csdn.net/xiexiaotian11/article/details/88742247

#====================================================================
8.private static与public static的用法及区别（Java）
  https://blog.csdn.net/u013110200/article/details/81331688

#====================================================================
9.Android语音识别（本地+第三方）
  https://blog.csdn.net/liyuanjinglyj/article/details/46127607

#====================================================================
10.android语音识别 android.speech 包分析
   https://blog.csdn.net/almo_omla/article/details/51513779
   https://www.cnblogs.com/androidme/archive/2012/03/07/2384453.html

#====================================================================
11.Android Service设置权限
   http://www.anddle.com/?p=181

#====================================================================
12.java反射机制
   https://www.cnblogs.com/ysocean/p/6516248.html
   https://www.cnblogs.com/yrstudy/p/6500982.html
   一个类在 JVM 中只会有一个 Class 实例,

#====================================================================
13.Android组件系列----Intent详解
   https://www.cnblogs.com/smyhvae/p/3959204.html
通过intent的bundle的源码可以看到它们都是实现了Parcelable，其实就是通过序列化来实现通信的。
介绍Parcelable不得不先提一下Serializable接口,Serializable是Java为我们提供的一个标准化的序列化接口,那什么是序列化呢? —- 简单来说就是将对象转换为可以传输的二进制流(二进制序列)的过程,这样我们就可以通过序列化,转化为可以在网络传输或者保存到本地的流(序列),从而进行传输数据 ,那反序列化就是从二进制流(序列)转化为对象的过程.

一 序列化原因：
1.永久性保存对象，保存对象的字节序列到本Abdr地文件中；
2.通过序列化对象在网络中传递对象；
3.通过序列化在进程间传递对象。 

二 至于选取哪种可参考下面的原则：
1.在使用内存的时候，Parcelable 类比Serializable性能高，所以推荐使用Parcelable类。
2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC。
3.Parcelable不能使用在要将数据存储在磁盘上的情况，因为Parcelable不能很好的保证数据的持续性在外界有变化的情况下。尽管Serializable效率低点， 也不提倡用，但在这种情况下，还是建议你用Serializable 。

#====================================================================
14.Android Service、IntentService，Service和组件间通信
   https://blog.csdn.net/qq_34115898/article/details/83347882
   https://blog.csdn.net/xyh269/article/details/53355399

#====================================================================
15.Android Binder机制原理（史上最强理解，没有之一）（转）
   https://www.cnblogs.com/qingchen1984/p/5212755.html

#====================================================================
16.Android.VoiceInteractionService类详解
   Demo源代码
   https://github.com/penglu20/RecentTask
   Bigbang项目
   https://github.com/penglu20/Bigbang

#====================================================================
17.ANDROID 中UID与PID的作用与区别
   https://blog.csdn.net/wi__wi/article/details/51078029
   Pid是进程ID，Uid是用户ID，只是Android和计算机不一样，计算机每个用户都具有一个Uid，哪个用户start的程序，这个程序的Uid就是那个用户，而Android中每个程序都有一个Uid，默认情况下，Android   会给每个程序分配一个普通级别互不相同的 Uid，如果用互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application 只有一个Uid，所以  application下的Activity之间不存在访问权限的问题。

#====================================================================
18.AndroidStudio添加Button点击响应方法
1.通过内部类来实现
eg:
loginButton1 = (Button) findViewById(R.id.login1);
loginButton1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    }
});
2.通过外部类来实现
loginButton2 = (Button) findViewById(R.id.login1);
loginButton2.setOnClickListener(new MyListener());
class MyListener implements View.OnClickListener {
    @Override
    public void onClick(View v) {
    }
}

#====================================================================
19.MVC设计模式
https://www.cnblogs.com/senior-engineer/p/5562794.html

#====================================================================
20.Listview详解
  
ListView 控件的设计正好遵循MVC 设计模式
ArrayAdapter的使用
ArrayAdapter通常用于显示较为简单的数组和集合数据，界面较为简单，直接向ArrayAdapter添加相关的参数即可。

#====================================================================
21.android自定义静态jar包和动态jar包的编译、使用
https://blog.csdn.net/bukker/article/details/51672506

#====================================================================
23.Android APK Crash重启机制

#====================================================================
24.Java 序列化Serializable详解（附详细例子）
https://www.cnblogs.com/gtaxmjld/p/4866931.html
Intent可传递的数据类型
1.简单或基本数据类型
2.传递一个Bundle
3.传递Serializable对象
4.传递Parcelable对象
5.传递Intent
总结:
a）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
b）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
c） static,transient后的变量不能被序列化；
#====================================================================
25.android-Service和Thread的区别
1.servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。
2.Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。
3.怎么将service变成remote service,只需要在AndroidManifest.xml中添加 android:process=":remote" >即可
4.Service的所有生命周期方法和ServiceConnection的回调方法都是运行在主线程的。所以在开发中特别要注意，千万不能在Service的生命周期方法中做非常耗时的操作，否则会引起主线程卡顿，严重时还会引起ANR。

#====================================================================
26.Java弱引用(WeakReference)的理解与使用
https://www.cnblogs.com/zjj1996/p/9140385.html
以如果你希望能够控制一些对象的生命周期，比方说当JVM内存不足时这些对象就可以被回收，或者说只要GC线程扫描到该对象，那么这个对象就会被回收。那怎样控制这些对象的生命周期呢？答案就是通过指定指向对象的引用的类型！不同类型的引用所指向对象的生命周期是不同的。JVM之所以在回收被弱引用指向对象时这么“猖狂”，是因为被回收的对象只有一个弱引用指向它，如果同时还有强引用指向当前对象的话JVM可是没这个胆子的哈。

#====================================================================
27.WeakReference在android中的使用场景
https://blog.csdn.net/firedancer0089/article/details/83023412

#====================================================================
28.Android消息处理机制(Handler 与Message)
https://www.cnblogs.com/cheneasternsun/p/5467115.html
1.在使用Handler处理Message时，需要Looper（通道）来完成。在一个Activity中，系统会自动帮用户启动Looper对象，而在一个用户自定义的类中，则需要用户手工调用Looper类中的方法，然后才可以正常启动Looper对象。Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程
2.Looper有以下几个要点：
1）每个线程有且只能有一个Looper对象，它是一个ThreadLocal
2）Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行
3）Looper使一个线程变成Looper线程。
3.消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)

#====================================================================
29.ThreadLocal用法详解和原理
一、用法
ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。
1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。
2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。
3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值

#====================================================================
30.+BUILD_MULTI_PREBUILT将库文件拷贝到系统库路径下面,如果是动态库则需要源文件
在生成apk的moudle中添加LOCAL_STATIC_JAVA_LIBRARIES打包到apk中

#====================================================================
//单例模式
1java
使用内部静态类,保证线程安全
class Test {
    private Test() {};
    private static class GetHandler {
        private final static Test mTest = new Test();
    }

    public static Test GetInstance() {
        return GetHandler.mTest;
    }
}
2.C++
懒汉模式
非静态变量要加锁
class Test {
private:
    Test() {}
private:
    static Test* mTest = null;
    static std::mutex mtx;
public:
    static Test* GetInstance() {
        if(null == Test) {
            std::lock_guard<std::mutext> lck(mtx);
            if(null == mTest)
                mTest = new Test();
        }
        return mTest;
    }
};
静态变量要加锁
class Test {
private:
    Test(){}
private:
    static std::mutex mtx;
public:
    static Test* GetInstance() {
       {
           std::lock_guard<std::mutex> lck(mtx);
           static Test mTest;
       }
       return &mTest;
    }

};
饿汉模式
class Test {
private:
    Test(){}
private:
    static Test* mTest = new Test();
public:
    static Test* GetInstance() {
        return mTest;
    }
};

#====================================================================
31.java中Runtime类
https://www.cnblogs.com/lixiaolun/p/4320754.html
Runtime类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。
1.一般不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。
2.一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。 
3.当Applet和其他不被信任的代码调用任何Runtime方法时，常常会引起SecurityException异常。

#====================================================================
32.Android序列化完全解析
https://www.jianshu.com/p/287acb9e396f
https://www.cnblogs.com/yezhennan/p/5527506.html
Serializable使用反射机制
Parcelable使用binder机制
3.Parcelable与Serializable的性能比较
首先Parcelable的性能要强于Serializable的原因我需要简单的阐述一下
  1）. 在内存的使用中,前者在性能方面要强于后者
  2）. 后者在序列化操作的时候会产生大量的临时变量,(原因是使用了反射机制)从而导致GC的频繁调用,因此在性能上会稍微逊色
  3）. Parcelable是以Ibinder作为信息载体的.在内存上的开销比较小,因此在内存之间进行数据传递的时候,Android推荐使用Parcelable,既然是内存方面比价有优势,那么自然就要优先选择.
  4）. 在读写数据的时候,Parcelable是在内存中直接进行读写,而Serializable是通过使用IO流的形式将数据读写入在硬盘上.
  但是：虽然Parcelable的性能要强于Serializable,但是仍然有特殊的情况需要使用Serializable,而不去使用Parcelable,因为Parcelable无法将数据进行持久化,因此在将数据保存在磁盘的时候,仍然需要使用后者,因为前者无法很好的将数据进行持久化.(原因是在不同的Android版本当中,Parcelable可能会不同,因此数据的持久化方面仍然是使用Serializable)

#====================================================================
33.java线程(上)Thread和Runnable的区别
https://www.cnblogs.com/yangdy/p/5274455.html
实现Runnable接口比继承Thread类所具有的优势：
1）：适合多个相同的程序代码的线程去处理同一个资源
2）：可以避免java中的单继承的限制
3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

#====================================================================
59.Android消息处理机制(Handler 与Message)
   https://www.cnblogs.com/cheneasternsun/p/5467115.html
Looper是一个ThreadLoacl,ThreadLocal可以在线程间进行传递所以Looper在线程间传递来进行线程间通信
ThreadLocal共享原理
线程共享变量缓存如下：
Thread.ThreadLocalMap<ThreadLocal, Object>;
1、Thread: 当前线程，可以通过Thread.currentThread()获取。
2、ThreadLocal：我们的static ThreadLocal变量。
3、Object: 当前线程共享变量。
我们调用ThreadLocal.get方法时，实际上是从当前线程中获取ThreadLocalMap<ThreadLocal, Object>，然后根据当前ThreadLocal获取当前线程共享变量Object。
ThreadLocal.set，ThreadLocal.remove实际上是同样的道理。
#====================================================================
60. Android中的Activity和Service是否属于同一个进程
1.只要你不开线程，所有的组件(四大组件)都在主线程中跑，当然一般情况下一个程序也只有一个进程，远程的话是进程间通信，所以是多个进程
2.本地service默认情况下运行在当前进程的主线程中，远程service运行再另一个进程中。
不要在service中做过多的事情,会使主线程卡顿

#====================================================================
61.Service 的两大功能
https://blog.csdn.net/jaycee110905/article/details/8990449
情况1：当Acitivity和Service处于同一个Application和进程时，通过继承Binder类来实现
情况2：跨进程通讯，使用AIDL;
总结
内核空间内存在一个binder映射表
再来梳理总结一下：当Client进程向ServiceManager查询Server进程（我要调用你的某个对象的某个方法了），这个过程也是一个跨进程通信的过程，也经过了Binder驱动，这时Binder驱动发挥它的作用，来了个狸猫换太子，将Server进程中的真实对象转换成代理对象，返回这个代理对象给Client进程.
Client进程拿到了这个代理对象，然后调用这个代理对象的方法，Binder驱动继续发挥他的使命，它会通知Server进程执行计算工作，将Server进程中的真实对象执行的结果返回给了Client进程，这样Client进程还是如愿的得到了自己想要。跨进程通信完毕！

#====================================================================
62.AIDL通信原理
但是在安卓里是行不通的，因为单独的进程是运行在自己的虚拟机里面，有着自己的内存映射，所以内存共享没法实现，只能借助AIDL。
https://blog.csdn.net/michael1112/article/details/78675520 

1.在这之前我们先简单说一下IPC，IPC是Inter-Process Communication的缩写，是进程间通信或者跨进程通信的意思，既然说到进程，大家要区分一下进程和线程，进程一般指的是一个执行单元，它拥有独立的地址空间，也就是一个应用或者一个程序。线程是CPU调度的最小单元，是进程中的一个执行部分或者说是执行体，两者之间是包含与被包含的关系。因为进程间的资源不能共享的，所以每个系统都有自己的IPC机制，Android是基于Linux内核的移动操作系统，但它并没有继承Linux的IPC机制，而是有着自己的一套IPC机制。\
2.sutido帮我们生成了一个继承android.os.IInterface接口的UserManager接口，所有在Binder中传输的接口都必须实现IInterface接口。接口定义了我们在AIDL文件中定义的方法，然后还有个内部静态类Stub
3.Stub继承了android.os.Binder并实现UserManager接口
我们可以看到Stub中的常量，其中两个int常量是用来标识我们在接口中定义的方法的，DESCRIPTOR常量是 Binder的唯一标识。
asInterface 方法用于将服务端的Binder对象转换为客户端所需要的接口对象，该过程区分进程，如果进程一样，就返回服务端Stub对象本身，否则呢就返回封装后的Stub.Proxy对象。
onTransact 方法是运行在服务端的Binder线程中的，当客户端发起远程请求后，在底层封装后会交由此方法来处理。通过code来区分客户端请求的方法，注意一点的是，如果该方法返回false的换，客户端的请求就会失败。一般可以用来做权限控制。
4.代理类中我们主要看一下getName和getOtherName方法就可以了，这两个方法都是运行在客户端，当客户端发起远程请求时，_data会写入参数，当然这边的例子并没有（啦啦啦...），然后调用transact方法发起RPC(远程过程调用)请求，同时挂起当前线程，然后服务端的onTransact方法就会被调起，直到RPC过程返回后，当前线程继续执行，并从_reply取出返回值（如果有的话），并返回结果。
5.最后
分析完sutido生成的Binder之后，我们就大概知道AIDL的工作原理，定义好AIDL文件只是方便sutido帮我生成所需的Binder类，AIDL并不是必须的文件，因为这个Binder类我们也可以手写出来（当然，你闲的没事的话），所以这边最重要的还是Binder的知识点，其他一些IPC方式其实都是通过Binder来实现的，比如说Messager，Bundle，ContentProvider，只是它们的封装方式不一样而已。总的来说，从应用层来说，Binder是客户端和服务端之间通信的媒介。从FrameWork层来说，Binder是ServiceManager连接各种Manager和ManagerService的桥梁。Android系统中充斥着大量的CS模型，而Binder作为独有的IPC方式，如果我们能更好的理解它，对我们的开发工作就会带来更多的帮助。

#====================================================================
63. JNI原理分析
主要流程就是
1.检查是否已经加载过该so，如果是还需要判断加载so的classLoader是否相同，不同的话也会报错，
2.如果没有加载过，则使用dlopen打开so，然后创建一个ShareLib加入到gDvm.nativeLibs哈希表中。
3.如果so中有JNI_OnLoad方法，则执行该方法。我们可以在该方法中做一些初始化工作，还可以手动建立java类中的native方法和so中的native方法的对应关系。

findMethodInLib的主要流程是，首先根据规则，生成对应的native方法名，然后使用dlsym查找so中是否有该方法。
java层的native方法和so中的对应关系为：Java_类全名_方法名。

#====================================================================
64. Android：远程服务Service（含AIDL & IPC讲解）
https://www.jianshu.com/p/34326751b2c6

#====================================================================
65. java外部类可以访问内部类的私有成员变量

#====================================================================
66. AIDL中RemoteCallbackList的使用及权限验证方式
https://www.jianshu.com/p/69e5782dd3c3

#====================================================================
67. Android ContentProvider详解
https://blog.csdn.net/carson_ho/article/details/76101093
https://www.jianshu.com/p/ea8bc4aaf057
注意事项:
1.application初始化的时候会installProvider
2.向AMS请求provider的时候如果对端进程不存在则请求的那个线程需要一直等待
3.当对方的进程启动之后并publish之后，请求provider的线程才可返回，所以尽量不要在主线程请求provider
4.请求provider分为stable以及unsbale，stable类型链接在server进程挂掉之后，client进程会跟着被株连kill
5.insert/delete/update默认建立stable链接，query默认建立unstable链接，如果失败会重新建立stable链接
6.AMS作为一个中间管理员的身份，所有的provider会向它注册
7.向AMS请求到provider之后，就可以在client和server之间自行binder通信，不需要再经过systemserver

#====================================================================
68. 图文详解 Android Binder跨进程通信的原理
https://www.jianshu.com/p/4ee3fd07da14

注：传统的跨进程通信需拷贝数据2次，但Binder机制只需1次，主要是使用到了内存映射
#====================================================================
69. 安卓丢log的问题，以下方法是网上查的，遇到问题可以试下是否能够解决丢log的问题？
原因：每个TAG的缓存上限是256K（property中设置），超过这个上限，会有擦除规则。
        缓存区有一个总的大小，默认是1M，可以修改。
logcat -g 可以查看log缓存的大小
logcat -G <size> 可以设置Log缓存的大小
例子： logcat -G 4096K

#====================================================================
70. 理解Java中的弱引用（Weak Reference）
https://www.cnblogs.com/android-blogs/p/5566277.html

#====================================================================
71 【个人笔记一】ART系统类的编译解析加载探究
https://blog.csdn.net/zhu929033262/article/details/76999996
首先AndroidRuntime::start函数中会进行jni的初始化，实际上就是加载虚拟机的so库，并从中导出三个函数，其中JNI_CreateJavaVM用来启动虚拟机。Android 5.0之后默认加载的就是libart.so。
JNI_CreateJavaVM主要负责创建ART虚拟机实例，并且启动ART虚拟机，然后给app_process返回JNIEnv和JavaVM。有了JNIEnv，app_process中才能使用JNI中的FindClass等函数。
创建虚拟机实例中，最主要的是Runtime::init函数，负责创建虚拟机堆空间，绑定Thread，创建和初始化classLinker。
利用gc::Heap创建堆空间时，主要有两件事情，加载boot.ar和boot.oat初始化imgae空间，另外就是与垃圾回收机制相关的东东

#====================================================================
72 Android手势分发和嵌套滚动机制
    https://www.jianshu.com/p/490659fae773
    Android:30分钟弄明白Touch事件分发机制
    https://www.cnblogs.com/linjzong/p/4191891.html
    Android手势处理看这一篇就够了
    https://www.jianshu.com/p/2d7232f3f42e
    View与ViewGroup的概念
    https://www.runoob.com/w3cnote/and处理方法有两种：重写onTouchEvent来自己识别各种手势，也可以直接使用Android提供的各种手势监听器。

    Android手势监听器
    GestureDetector.OnGestureListenerroid-tutorial-view-viewgroup-intro.html
    处理方法有两种：重写onTouchEvent来自己识别各种手势，也可以直接使用Android提供的各种手势监听器。
    Android手势监听器 (GestureDetector.OnGestureListener)
    基础概念：	
    MotionEvent：手势对象，包含有action（事件类型）、坐标等信息。	
    View：安卓的所有视图都是View的子类。为了方便描述，本文用View指代视图单元，是整个视图树的叶子节点，比如TextView、Button等。	
    ViewGroup：视图容器，里面可以包含其他视图，也是View的子类。一般在整个视图树作为非叶节点，比如Scrollview、LinearLayout等。	
    Activity：你就理解为是电影中的一个场景吧，一个安卓APP是由一个或多个Activity组成的。	
    安卓的手势事件类型包括（部分）:	
    ACTION_DOWN：手指按下;	
    ACTION_MOVE：手指移动；	
    ACTION_UP：手指抬起；	
    ACTION_CANCEL：手势终止，比如手势在中途被其他View拦截消费、手势滑出屏幕（非抬起），大部分场景下可视为ACTION_UP；	
    在多指手势中还有：	
    ACTION_PONINTER_DOWN：其他手指按下；	
    ACTION_POINTER_UP：其他手指抬起；	
    关键方法	
    1 Activity中有两个方法dispatchTouchEvent和onTouchEvent，整个手势分发从这个dispatchTouchEvent开始，将手势传递到整个View树的根节点，
       通过深度遍历的方式分发下去，如果没有任何View消费掉的话手势分发将从这个onTouchEvent结束。
    2 View中恰好也有这两个方法dispatchTouchEvent和onTouchEvent，其中dispatchTouchEvent如其名是分发手势的，而onTouchEvent是意味事件传到它这了，
       可以在这里执行一些手势处理的操作。而View默认的dispatchTouchEvent实现非常简单，就是直接交给自己的onTouchEvent
    3 ViewGroup在继承了View的dispatchTouchEvent和onTouchEvent方法外,还加了onInterceptTouchEvent和requestDisallowInterceptTouchEvent方法。
       onInterceptTouchEvent使得ViewGroup有机会直接拦截手势给自己的onTouchEvent，而不必再向下传播。
       requestDisallowInterceptTouchEvent是允许下层的某个View阻止其拦截的,一物降一物。
    
#====================================================================
73 JNI的副作用
一旦使用JNI，JAVA程序就丧失了JAVA平台的两个优点：
1、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。
2、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了JAVA和C之间的耦合性。+

#====================================================================