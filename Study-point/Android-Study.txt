#====================================================================
1.Android广播机制Broadcast详解
  https://www.cnblogs.com/travellife/p/3944363.html
  https://blog.csdn.net/weixin_39460667/article/details/82413819
注: 如果我们设置为静态注册的时候，我们的广播接收器就一个设置为 独立外部类 或者是 静态内部类

#====================================================================
2.AndroidManifest.xml 最全详解
  https://blog.csdn.net/u012486840/article/details/52468931

#====================================================================
3.Java final修饰符：final修饰属性、final修饰方法及final修饰类
  http://c.biancheng.net/view/970.html
1. final 修饰类中的属性
表示该属性一旦被初始化便不可改变，这里不可改变的意思对基本类型来说是其值不可变，而对对象属性来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在 final 属性定义时直接给其赋值；二是在构造函数中。这两个地方只能选其一，要么在定义时给值，要么在构造函数中给值，不能同时既在定义时赋值，又在构造函数中赋予另外的值。
2. final 修饰类中的方法
说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次。
3. final 修饰类
表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。

#====================================================================
4.java关键字abstract(抽象)详解
  https://blog.csdn.net/weixin_40096176/article/details/79094991
  1、从上面的例子中我们可以看到抽象方法跟普通方法是有区别的，它没有自己的主体（没有{}包起来的
业务逻辑），跟接口中的方法有点类似。所以我们没法直接调用抽象方法

2、抽象方法不能用private修饰，因为抽象方法必须被子类实现（覆写），而private权限对于子类来
说是不能访问的，所以就会产生矛盾

3、抽象方法也不能用static修饰，试想一下，如果用static修饰了，那么我们可以直接通过类名调
用，而抽象方法压根就没有主体，没有任何业务逻辑，这样就毫无意义了。

4.抽象类中可以正常使用静态方法

#====================================================================
5.类内创建interface接口,该类可以new对象,但是想调用接口函数则重新new接口类并实现接口

#====================================================================
6.java 不允许多重继承

#====================================================================
7.静态内部类写单例的好处
  https://blog.csdn.net/xiexiaotian11/article/details/88742247

#====================================================================
8.private static与public static的用法及区别（Java）
  https://blog.csdn.net/u013110200/article/details/81331688

#====================================================================
9.Android语音识别（本地+第三方）
  https://blog.csdn.net/liyuanjinglyj/article/details/46127607

#====================================================================
10.android语音识别 android.speech 包分析
   https://blog.csdn.net/almo_omla/article/details/51513779
   https://www.cnblogs.com/androidme/archive/2012/03/07/2384453.html

#====================================================================
11.Android Service设置权限
   http://www.anddle.com/?p=181

#====================================================================
12.java反射机制
   https://www.cnblogs.com/ysocean/p/6516248.html
   https://www.cnblogs.com/yrstudy/p/6500982.html
   一个类在 JVM 中只会有一个 Class 实例,

#====================================================================
13.Android组件系列----Intent详解
   https://www.cnblogs.com/smyhvae/p/3959204.html
通过intent的bundle的源码可以看到它们都是实现了Parcelable，其实就是通过序列化来实现通信的。
介绍Parcelable不得不先提一下Serializable接口,Serializable是Java为我们提供的一个标准化的序列化接口,那什么是序列化呢? —- 简单来说就是将对象转换为可以传输的二进制流(二进制序列)的过程,这样我们就可以通过序列化,转化为可以在网络传输或者保存到本地的流(序列),从而进行传输数据 ,那反序列化就是从二进制流(序列)转化为对象的过程.
   
#====================================================================
14.Android Service、IntentService，Service和组件间通信
   https://blog.csdn.net/qq_34115898/article/details/83347882

#====================================================================
15.Android Binder机制原理（史上最强理解，没有之一）（转）
   https://www.cnblogs.com/qingchen1984/p/5212755.html

#====================================================================
16.Android.VoiceInteractionService类详解
   Demo源代码
   https://github.com/penglu20/RecentTask
   Bigbang项目
   https://github.com/penglu20/Bigbang

#====================================================================
17.ANDROID 中UID与PID的作用与区别
   https://blog.csdn.net/wi__wi/article/details/51078029
   Pid是进程ID，Uid是用户ID，只是Android和计算机不一样，计算机每个用户都具有一个Uid，哪个用户start的程序，这个程序的Uid就是那个用户，而Android中每个程序都有一个Uid，默认情况下，Android   会给每个程序分配一个普通级别互不相同的 Uid，如果用互相调用，只能是Uid相同才行，这就使得共享数据具有了一定安全性，每个软件之间是不能随意获得数据的。而同一个application 只有一个Uid，所以  application下的Activity之间不存在访问权限的问题。

#====================================================================
18.AndroidStudio添加Button点击响应方法
1.通过内部类来实现
eg:
loginButton1 = (Button) findViewById(R.id.login1);
loginButton1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
    }
});
2.通过外部类来实现
loginButton2 = (Button) findViewById(R.id.login1);
loginButton2.setOnClickListener(new MyListener());
class MyListener implements View.OnClickListener {
    @Override
    public void onClick(View v) {
    }
}

#====================================================================
19.MVC设计模式
https://www.cnblogs.com/senior-engineer/p/5562794.html

#====================================================================
20.Listview详解
https://www.cnblogs.com/huangjie123/p/5990737.html
ListView 控件的设计正好遵循MVC 设计模式
ArrayAdapter的使用
ArrayAdapter通常用于显示较为简单的数组和集合数据，界面较为简单，直接向ArrayAdapter添加相关的参数即可。

#====================================================================
21.android自定义静态jar包和动态jar包的编译、使用
https://blog.csdn.net/bukker/article/details/51672506

#====================================================================
22.从Android8.0 广播配置AndroidManifest.xml方式大部分是不允许的
静态广播和动态广播的区别:
1.静态广播在进程没有运行的情况下也会接收广播，假如进程没有启动的话，会优先调用AMS中的startProcessLocked中的方法，拉起进程，然后处理广播onReceive函数。动态广播是在程序中通过代码显示注册的，因此必须要在进程已经运行的时候才能收到广播。
2.静态广播处理的时候，每次都会创建一个广播接收器的对象，动态广播一般都是同一个广播接收器对象。
3.静态广播无法接收隐式广播，在Android 8 以上已经不起作用，个别广播除外。至于为什么要做这一变更，还是为了节省电量，提升续航，增强性能，提高用户体验。
4.发送一个无序广播，动态注册的广播要优先于静态的注册的广播，同一个应用内，先注册的接收器先收到广播
广播处理机制:
静态注册的receivers始终采用串行方式来处理； 动态注册的广播处理方式是串行还是并行方式, 取决于广播的发送方式。
注:只有串行广播才需要考虑超时，因为接收者是串行处理的，前一个receiver处理慢，会影响后一个receiver；

动态注册时假如没有在注册的时候指定那个线程来处理，则默认的指定主线程来处理。
为什么静态注册要跟动态注册有区别呢？
重点在于动态注册的时候可以指定处理receiver的handler，而静态注册无法指定，因此只能用主线程处理
#====================================================================
23.Android APK Crash重启机制

#====================================================================
24.Java 序列化Serializable详解（附详细例子）
https://www.cnblogs.com/gtaxmjld/p/4866931.html
Intent可传递的数据类型
1.简单或基本数据类型
2.传递一个Bundle
3.传递Serializable对象
4.传递Parcelable对象
5.传递Intent
总结:
a）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；
b）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；
c） static,transient后的变量不能被序列化；
#====================================================================
25.android-Service和Thread的区别
1.servie是系统的组件，它由系统进程托管（servicemanager）；它们之间的通信类似于client和server，是一种轻量级的ipc通信，这种通信的载体是binder，它是在linux层交换信息的一种ipc。而thread是由本应用程序托管。
2.Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。
3.怎么将service变成remote service,只需要在AndroidManifest.xml中添加 android:process=":remote" >即可
4.Service的所有生命周期方法和ServiceConnection的回调方法都是运行在主线程的。所以在开发中特别要注意，千万不能在Service的生命周期方法中做非常耗时的操作，否则会引起主线程卡顿，严重时还会引起ANR。

#====================================================================
26.Java弱引用(WeakReference)的理解与使用
https://www.cnblogs.com/zjj1996/p/9140385.html
以如果你希望能够控制一些对象的生命周期，比方说当JVM内存不足时这些对象就可以被回收，或者说只要GC线程扫描到该对象，那么这个对象就会被回收。那怎样控制这些对象的生命周期呢？答案就是通过指定指向对象的引用的类型！不同类型的引用所指向对象的生命周期是不同的。JVM之所以在回收被弱引用指向对象时这么“猖狂”，是因为被回收的对象只有一个弱引用指向它，如果同时还有强引用指向当前对象的话JVM可是没这个胆子的哈。

#====================================================================
27.WeakReference在android中的使用场景
https://blog.csdn.net/firedancer0089/article/details/83023412

#====================================================================
28.Android消息处理机制(Handler 与Message)
https://www.cnblogs.com/cheneasternsun/p/5467115.html
1.在使用Handler处理Message时，需要Looper（通道）来完成。在一个Activity中，系统会自动帮用户启动Looper对象，而在一个用户自定义的类中，则需要用户手工调用Looper类中的方法，然后才可以正常启动Looper对象。Looper的字面意思是“循环者”，它被设计用来使一个普通线程变成Looper线程。所谓Looper线程就是循环工作的线程。在程序开发中（尤其是GUI开发中），我们经常会需要一个线程不断循环，一旦有新任务则执行，执行完继续等待下一个任务，这就是Looper线程
2.Looper有以下几个要点：
1）每个线程有且只能有一个Looper对象，它是一个ThreadLocal
2）Looper内部有一个消息队列，loop()方法调用后线程开始不断从队列中取出消息执行
3）Looper使一个线程变成Looper线程。
3.消息的处理是通过核心方法dispatchMessage(Message msg)与钩子方法handleMessage(Message msg)

#====================================================================
29.ThreadLocal用法详解和原理
一、用法
ThreadLocal用于保存某个线程共享变量：对于同一个static ThreadLocal，不同线程只能从中get，set，remove自己的变量，而不会影响其他线程的变量。
1、ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。
2、ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。
3、ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值

#====================================================================
30.+BUILD_MULTI_PREBUILT将库文件拷贝到系统库路径下面,如果是动态库则需要源文件
在生成apk的moudle中添加LOCAL_STATIC_JAVA_LIBRARIES打包到apk中

#====================================================================
//单例模式
1java
使用内部静态类,保证线程安全
class Test {
    private Test() {};
    private static class GetHandler {
        static Test mTest = new Test();
    }

    public static Test GetInstance() {
        return GetHandler.mTest;
    }
}
2.C++
懒汉模式
非静态变量要加锁
class Test {
private:
    Test() {}
private:
    static Test* mTest = null;
    static std::mutex mtx;
public:
    static Test* GetInstance() {
        if(null == Test) {
            std::lock_guard<std::mutext> lck(mtx);
            if(null == mTest)
                mTest = new Test();
        }
        return mTest;
    }
};
静态变量要加锁
class Test {
private:
    Test(){}
private:
    static std::mutex mtx;
public:
    static Test* GetInstance() {
       {
           std::lock_guard<std::mutex> lck(mtx);
           static Test mTest;
       }
       return &mTest;
    }

};
饿汉模式
class Test {
private:
    Test(){}
private:
    static Test* mTest = new Test();
public:
    static Test* GetInstance() {
        return mTest;
    }
};

#====================================================================
31.java中Runtime类
https://www.cnblogs.com/lixiaolun/p/4320754.html
Runtime类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。
1.一般不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。
2.一旦得到了一个当前的Runtime对象的引用，就可以调用Runtime对象的方法去控制Java虚拟机的状态和行为。 
3.当Applet和其他不被信任的代码调用任何Runtime方法时，常常会引起SecurityException异常。

#====================================================================
32.Android序列化完全解析(三)-拨乱反正，堪比窦娥的Serializable
https://www.jianshu.com/p/287acb9e396f
https://www.cnblogs.com/yezhennan/p/5527506.html
Serializable使用反射机制
Parcelable使用binder机制
3.Parcelable与Serializable的性能比较
首先Parcelable的性能要强于Serializable的原因我需要简单的阐述一下
  1）. 在内存的使用中,前者在性能方面要强于后者
  2）. 后者在序列化操作的时候会产生大量的临时变量,(原因是使用了反射机制)从而导致GC的频繁调用,因此在性能上会稍微逊色
  3）. Parcelable是以Ibinder作为信息载体的.在内存上的开销比较小,因此在内存之间进行数据传递的时候,Android推荐使用Parcelable,既然是内存方面比价有优势,那么自然就要优先选择.
  4）. 在读写数据的时候,Parcelable是在内存中直接进行读写,而Serializable是通过使用IO流的形式将数据读写入在硬盘上.
  但是：虽然Parcelable的性能要强于Serializable,但是仍然有特殊的情况需要使用Serializable,而不去使用Parcelable,因为Parcelable无法将数据进行持久化,因此在将数据保存在磁盘的时候,仍然需要使用后者,因为前者无法很好的将数据进行持久化.(原因是在不同的Android版本当中,Parcelable可能会不同,因此数据的持久化方面仍然是使用Serializable)

#====================================================================
33.java线程(上)Thread和Runnable的区别
https://www.cnblogs.com/yangdy/p/5274455.html
实现Runnable接口比继承Thread类所具有的优势：
1）：适合多个相同的程序代码的线程去处理同一个资源
2）：可以避免java中的单继承的限制
3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

#====================================================================
59.Android消息处理机制(Handler 与Message)
   https://www.cnblogs.com/cheneasternsun/p/5467115.html
Looper是一个ThreadLoacl,ThreadLocal可以在线程间进行传递所以Looper在线程间传递来进行线程间通信
ThreadLocal共享原理
线程共享变量缓存如下：
Thread.ThreadLocalMap<ThreadLocal, Object>;
1、Thread: 当前线程，可以通过Thread.currentThread()获取。
2、ThreadLocal：我们的static ThreadLocal变量。
3、Object: 当前线程共享变量。
我们调用ThreadLocal.get方法时，实际上是从当前线程中获取ThreadLocalMap<ThreadLocal, Object>，然后根据当前ThreadLocal获取当前线程共享变量Object。
ThreadLocal.set，ThreadLocal.remove实际上是同样的道理。
#====================================================================
