#================================================================
面向对象的设计原则
1.单一职责:一个类只负责一个功能领域中的相应职责

2.开闭原则:软件实体应对扩展开放,而对修改关闭,即软件实体应尽量在不修改原有代码的情况下进行扩展(软件实体可以指一个软件模块,一个由多个类组成的局部结构或一个独立类)

3.里氏代换原则:在运用里氏代换原则时,尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者借口,并将其作为基类,在程序中尽量针对基类对象进行编程,由于子类继承基类并覆盖基类的方法,在程序运行时,子类对象可以替换基类对象如果需要对类的行为进行修改,可以通过扩展基类来增加新的子类,而无需修改使用该基类对象的代码

4.依赖倒转原则:抽象不应该依赖于细节,细节应当依赖于抽象,换言之,要针对接口编程,而不是针对实现编程

5.接口隔离原则:是指使用多个专门的接口,而不使用单一的总结口,每一个接口应该承担一种相对独立的角色,不多不少,不干不该干的事

6.合成复用原则:尽量使用对象组合,而不是继承来达到复用的目的.就是在一个新的对象里通过关联关系(包括组合和聚合关系)来使用一些已有的对象,使之成为新对象的一部分人,新对象通过委派调用已有对象的方法达到复用已有功能的目的

7.迪米特法则:又称最少知道原则,是指一个软件实体应当尽可能少地与其他实体发生相互作用,这样,当一个模块修改时,就会尽量少地影响其他的模块.扩展会相对容易,这样对软件实体之间的通信的限制,它要求限制软件实体之间通信的宽度和深度.
#================================================================
https://www.cnblogs.com/jiese/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/
#================================================================
重要的设计模式(具体看网页,只记录重点及注意事项)
1.抽象工厂
当抽象工厂模式退化到只有一个产品等级结构时,即变成了工厂方法模式,当工厂方法模式的工厂类只有一个,切工厂方法为静态方法时,则变成了简单工厂模式

#================================================================
https://www.cnblogs.com/qiaoconglovelife/p/5851163.html
2.单例模式
单线程和多线程单例模式
单例大约有两种实现方法：懒汉与饿汉。
    1.懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，所以上边的经典方法被归为懒汉实现；
    2.饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。
　　特点与选择：
    1.由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。
    2.在访问量较小时，采用懒汉实现。这是以时间换空间。

#================================================================
3.适配器模式
作用：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。分为类适配器模式和对象适配器模式。
类适配器:继承所需适配的类
对象适配器:持有所需适配的对象

#================================================================
4.外观模式
外观模式中外部与一个子系统的通信通过一个同意的外观对象进行,为子系统中的一组接口提供一个一致的入口,外观模式定义了一个高层接口,这个接口使得这一子系统更加容易使用

#================================================================
5.代理模式
作用：为其他对象提供一种代理以控制对这个对象的访问。
代理的种类：
如果按照使用目的来划分，代理有以下几种：
1.远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。 也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
2.虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。  
3.Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。
保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。 用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。
4.Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙（Firewall）代理：保护目标，不让恶意用户接近。 同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。
5.智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。
在所有种类的代理模式中，虚拟（Virtual）代理、远程（Remote）代理、智能引用代理（Smart Reference Proxy）和保护（Protect or Access）代理是最为常见的代理模式。
#================================================================
