#================================================================
面向对象的设计原则
1.单一职责:一个类只负责一个功能领域中的相应职责
优点：
1、降低类的复杂性，类的职责清晰明确。比如数据职责和行为职责清晰明确。
2、提高类的可读性和维护性，
4、变更引起的风险减低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的类有影响，对其他接口无影响，这对系统的扩展性、维护性都有非常大的帮助。
注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否合理，但是“职责”和“变化原因”都是没有具体标准的，一个类到底要负责那些职责？这些职责怎么细化？细化后是否都要有一个接口或类？这些都需从实际的情况考虑。因项目而异，因环境而异。

#================================================================
2.开闭原则:软件实体应对扩展开放,而对修改关闭,即软件实体应尽量在不修改原有代码的情况下进行扩展(软件实体可以指一个软件模块,一个由多个类组成的局部结构或一个独立类)
 定义:一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭.  意思是,在一个系统或者模块中,对于扩展是开放的,对于修改是关闭的,一个 好的系统是在不修改源代码的情况下,可以扩展你的功能. 而实现开闭原则的关键就是抽象化.
原则分析 :
1)当软件实体因需求要变化时, 尽量通过扩展已有软件实体，可以提供新的行为，以满足对软件的新的需求，而不是修改已有的代码，使变化中的软件有一定的适应性和灵活性 。已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性。
2)实现开闭原则的关键就是抽象化 :在"开-闭"原则中,不允许修改的是抽象的类或者接口,允许扩展的是具体的实现类,抽象类和接口在"开-闭"原则中扮演着极其重要的角色..即要预知可能变化的需求.又预见所有可能已知的扩展..所以在这里"抽象化"是关键!
3)可变性的封闭原则:找到系统的可变因素,将它封装起来. 这是对"开-闭"原则最好的实现. 不要把你的可变因素放在多个类中,或者散落在程序的各个角落. 你应该将可变的因素,封套起来..并且切忌不要把所用的可变因素封套在一起. 最好的解决办法是,分块封套你的可变因素!避免超大类,超长类,超长方法的出现!!给你的程序增加艺术气息,将程序艺术化是我们的目标!

#================================================================
3.里氏代换原则:在运用里氏代换原则时,尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者借口,并将其作为基类,在程序中尽量针对基类对象进行编程,由于子类继承基类并覆盖基类的方法,在程序运行时,子类对象可以替换基类对象如果需要对类的行为进行修改,可以通过扩展基类来增加新的子类,而无需修改使用该基类对象的代码
定义：第一种定义方式相对严格：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型S是类型T的子类型。
第二种更容易理解的定义方式：所有引用基类（父类）的地方必须能透明地使用其子类的对象。即子类能够必须能够替换基类能够从出现的地方。子类也能在基类 的基础上新增行为。
（里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士、麻省理工学院教授BarbaraLiskov和卡内基.梅隆大学Jeannette Wing教授于1994年提出。其原文如下：Let q(x) be a property provableabout objects x of type T. Then q(y) should be true for objects y of type Swhere S is a subtype of T.   ）
原则分析：
1）讲的是基类和子类的关系，只有这种关系存在时，里氏代换原则才存在。正方形是长方形是理解里氏代换原则的经典例子。
2）里氏代换原则可以通俗表述为：在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。
3）里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
优缺点：
在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：
1）代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
2）提高代码的重用性；
3）子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
4）提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；
5）提高产品或项目的开放性。
自然界的所有事物都是优点和缺点并存的，即使是鸡蛋，有时候也能挑出骨头来，继承的缺点如下：
1）继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
2）降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
3）增强了耦合性。当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大片的代码需要重构。

#================================================================
4.依赖倒转原则:抽象不应该依赖于细节,细节应当依赖于抽象,换言之,要针对接口编程,而不是针对实现编程
定义：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。简单的说，依赖倒置原则要求客户端依赖于抽象耦合。原则表述：
1）抽象不应当依赖于细节；细节应当依赖于抽象；
2）要针对接口编程，不针对实现编程。
原则分析：
1）如果说开闭原则是面向对象设计的目标,依赖倒转原则是到达面向设计"开闭"原则的手段..如果要达到最好的"开闭"原则,就要尽量的遵守依赖倒转原则. 可以说依赖倒转原则是对"抽象化"的最好规范! 我个人感觉,依赖倒转原则也是里氏代换原则的补充..你理解了里氏代换原则,再来理解依赖倒转原则应该是很容易的。
2）依赖倒转原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。 
3）类之间的耦合：零耦合关系，具体耦合关系，抽象耦合关系。依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是依赖倒转原则的关键。

理解这个依赖倒置，首先我们需要明白依赖在面向对象设计的概念：
依赖关系(Dependency)：是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。（假设A类的变化引起了B类的变化，则说名B类依赖于A类。）大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的虚线表示，由依赖的一方指向被依赖的一方。

#================================================================
5.接口隔离原则:是指使用多个专门的接口,而不使用单一的总结口,每一个接口应该承担一种相对独立的角色,不多不少,不干不该干的事
定义：客户端不应该依赖那些它不需要的接口。
另一种定义方法：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。
注意，在该定义中的接口指的是所定义的方法。例如外面调用某个类的public方法。这个方法对外就是接口。
原则分析：
1）接口隔离原则是指使用多个专门的接口，而不使用单一的总接口。每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干。
     •(1)一个接口就只代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做“角色隔离原则”。 
     •(2)接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。 
2）使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。
3）可以在进行系统设计时采用定制服务的方式，即为不同的客户端提供宽窄不同的接口，只提供用户需要的行为，而隐藏用户不需要的行为。

#================================================================
6.合成复用原则:尽量使用对象组合,而不是继承来达到复用的目的.就是在一个新的对象里通过关联关系(包括组合和聚合关系)来使用一些已有的对象,使之成为新对象的一部分人,新对象通过委派调用已有对象的方法达到复用已有功能的目的
定义：经常又叫做合成复用原则（Composite ReusePrinciple或CRP），尽量使用对象组合，而不是继承来达到复用的目的。
就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。简而言之，要尽量使用合成/聚合，尽量不要使用继承。
原则分析：
1）在面向对象设计中，可以通过两种基本方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承。
继承复用：实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用）
组合/聚合复用：耦合度相对较低，选择性地调用成员对象的操作；可以在运行时动态进行。（“黑箱”复用）
2）组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。
3）此原则和里氏代换原则氏相辅相成的,两者都是具体实现"开-闭"原则的规范。违反这一原则，就无法实现"开-闭"原则，首先我们要明白合成和聚合的概念：
什么是合成?
合成（组合）：表示一个整体与部分的关系，指一个依托整体而存在的关系（整体与部分不可以分开）,例如:一个人对他的房子和家具,其中他的房子和家具是不能被共享的,因为那些东西都是他自己的。并且人没了,这个也关系就没了。这个例子就好像,乌鸡百凤丸这个产品,它是有乌鸡和上等药材合成而来的一样。也比如网络游戏中的武器装备合成一样,多种东西合并为一种超强的东西一样。

7.迪米特法则:又称最少知道原则,是指一个软件实体应当尽可能少地与其他实体发生相互作用,这样,当一个模块修改时,就会尽量少地影响其他的模块.扩展会相对容易,这样对软件实体之间的通信的限制,它要求限制软件实体之间通信的宽度和深度.
定义：又叫最少知识原则（Least Knowledge Principle或简写为LKP）几种形式定义：
(1) 不要和“陌生人”说话
(2) 只与你的直接朋友通信。英文定义为：Talk only to your immediatefriends.
(3) 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
简单地说，也就是，一个对象应当对其它对象有尽可能少的了解。一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。
法则分析：
1）朋友类：
在迪米特法则中，对于一个对象，其朋友包括以下几类：
Ÿ(1) 当前对象本身(this)；
Ÿ(2) 以参数形式传入到当前对象方法中的对象；
Ÿ(3) 当前对象的成员对象；
Ÿ(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；
Ÿ(5) 当前对象所创建的对象。
任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。
2）狭义法则和广义法则：
在狭义的迪米特法则中，如果两个类之间不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。 

#================================================================
https://www.cnblogs.com/jiese/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/
#================================================================
重要的设计模式(具体看网页,只记录重点及注意事项)
1.抽象工厂
当抽象工厂模式退化到只有一个产品等级结构时,即变成了工厂方法模式,当工厂方法模式的工厂类只有一个,切工厂方法为静态方法时,则变成了简单工厂模式

#================================================================
https://www.cnblogs.com/qiaoconglovelife/p/5851163.html
2.单例模式
单线程和多线程单例模式
单例大约有两种实现方法：懒汉与饿汉。
    1.懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，所以上边的经典方法被归为懒汉实现；
    2.饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。
　　特点与选择：
    1.由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。
    2.在访问量较小时，采用懒汉实现。这是以时间换空间。

#================================================================
3.适配器模式
作用：将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。分为类适配器模式和对象适配器模式。
类适配器:继承所需适配的类
对象适配器:持有所需适配的对象

#================================================================
4.外观模式
外观模式中外部与一个子系统的通信通过一个同意的外观对象进行,为子系统中的一组接口提供一个一致的入口,外观模式定义了一个高层接口,这个接口使得这一子系统更加容易使用

#================================================================
5.代理模式
作用：为其他对象提供一种代理以控制对这个对象的访问。
代理的种类：
如果按照使用目的来划分，代理有以下几种：
1.远程（Remote）代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是在本机器中，也可是在另一台机器中。远程代理又叫做大使（Ambassador）。 也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。
2.虚拟（Virtual）代理：根据需要创建一个资源消耗较大的对象，使得此对象只在需要时才会被真正创建。是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。  
3.Copy-on-Write代理：虚拟代理的一种。把复制（克隆）拖延到只有在客户端需要时，才真正采取行动。
保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。 用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。
4.Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 防火墙（Firewall）代理：保护目标，不让恶意用户接近。 同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突。
5.智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来等。 是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。
在所有种类的代理模式中，虚拟（Virtual）代理、远程（Remote）代理、智能引用代理（Smart Reference Proxy）和保护（Protect or Access）代理是最为常见的代理模式。
#================================================================
6.空对象(Null Object)
空对象模式又称哑对象模式,它是一个行为模式,扩展了空指针的含义,给空指针一个默认的,可接受的行为,通常是空操作,可以说是一个"智能空指针".使用空对象模式,程序就可以不必用条件语句专门处理空指针或类似的概念,所有的对象都会有一直的,可理解的行为

#================================================================
