#==================================================================
Android Studio开发实战
#==================================================================
第一章 App的工程结构
#==================================================================
1.1 AndroidStudio的工程创建分两个层级:第一个层级通过菜单File->New->New Project创建,这里的新项目是指新的工作空间,对应Eclipse的workplace;第二个层级通过菜单File->New->New Moudle创建,这里的新模块指一个单独的App工程,对应Eclipse的project.第一次运行AndroidStudio都是选择Newproject,表示先创建一个工作空间;后面还想创建新的App工程时,只需要NewMoudle,表示在当前工作空间下创建一个App工程.
1.2 app目录下有3个子目录,功能说明如下:
    (1)manifests子目录,下面只有一个xml文件,即AndroidManifest.xml,是App的运行配置文件
    (2)java子目录,下面有3个包,其中第一个包存放的是App工程java源代码,后面两个包存放的是测试用的java代码
    (3)res子目录,存放的是App工程的资源文件.res子目录下又有4个子目录:
    drawable目录存放的是图形描述文件与用户图片
    layout目录存放的是App页面的布局文件
    mipmap目录存放的是启动图标
    values目录存放的是一些常量定义文件,比如字符串常量string.xml,像素常量dimens.xml,颜色常量colors.xml,样式风格定义style.xml等
    (4)GradleScripts下面主要是工程的编译配置文件,主要有
    build.gradle,该文件分为项目级与模块级两种,用于描述App工程编译规则
    proguard-rules.pro,该文件用于描述java文件的代码混淆规则
    gradle.properties,该文件用于配置编译工程的命令行参数,一般无需改动
    setting.gradle,配置那些模块在一起编译,初始内容为include ':app',表示只编译App模块
    local.properties,项目的本地配置,一般无需改动.该文件是在工程编译时自动生成的,用于描述开发者本机的环境配置,比如SDK的本地路径,NDK的本地路径等
1.3 编译配置文件build.gradle书P12
1.4 App运行配置AndroidManifest.xml 
    AndroidManifest.xml用于指定App内部的运行配置,是一个XML描述文件,根节点的pacakge指定了该App的包名.manifest下面又有若干子节点,分别说明如下:
    (1)uses-sdk,该节点有两个属性:android:minSdkVersion和android:targetSdkVersion.这两个属性是早期Eclipse开发App时使用的,现在这两个字段改成放在build.gradle文件中,故而AndroidStudio不配置uses-sdk也没有关系
    (2)uses-permission,该节点用于声明App运行过程中需要的权限名称 
    (3)application,该界定啊用于指定App的自身属性(详见P13)

#==================================================================
第二章 初级控件
#==================================================================
2. 视图view的基本属性
   (1)id: 指定该视图的编号
   (2)layout_width: 指定视图的宽度,可以是具体的dp数值;可以是match_parent,表示于上级视图一样宽;也可以是wrap_content,表示与内部内容一样宽(内部内容若超过上级视图的宽度,则该视图保持与上级视图一样宽,超出宽度的内容得进行滚动才能显式出来)
   (3)layout_height: 指定该视图的高度.取值说明同layout_width;
   (4)layout_margin: 指定该视图与周围视图之间的空白距离(包括上,下,左,右).另有layouy_marginTopdeng等.分别表示单独指定视图与上边,下边,左边,右边视图的距离
   (5)minWidth: 指定该视图的最小宽度
   (6)minHeight: 指定该视图的最小高度
   (7)background: 指定该视图的背景,背景可以是颜色,也可以是图片.
   (8)layout_gravity: 指定该视图与上级视图的对齐方式.对齐方式的取值详见P28
   (9)padding: 指定该视图边缘与内部内容之间的空白距离.另有padding Top等分别表示指定视图边缘于内容上边,下边,左边,右边的距离. 
   等(详见P28)

2.1 线性布局LinearLayout
    LinearLayout是最常用的布局,名字叫线性布局.顾名思义,LinearLayout下面的子视图就像用一根线串了起来,所以LinearLayout内部视图的排列是顺序的,要么从上倒下一次垂直排列,要么从左到右依次水平排列.LinearLayout除了继承View/
    ViewGroup类的所有属性和方法外,还有奇特有的XML属性
    (1)orientation: 指定线性布局的方向.horizontal表示水平布局,vertial表示垂直布局.如果不指定该属性,就默认是horizontal.
    (2)gravity: 指定布局内部视图与本线性布局的对齐方式.取值说明同layout_gtavity
    (3)layout_weight: 指定当前视图的宽或搞占上级线性布局的权重,这里要注意,layout_weight属性并非在当前LinearLayout节点中设置,而是在下级视图的节点中设置.另外,如果layout_weight指定的是当前视图在宽度上占的权重,layout_weight就要同时设置为0dp;如果layout_weight指定的是当前视图在高度上占的权重,layout_height就要同时设置为0dp.
2.2 滚动视图ScroLLView
    手机屏幕的显示空间有限,常常需要上下滑动显示出其他页面,这时就要借助ScroLLView滚动视图实现了,与线性布局类似,滚动视图也分为垂直方向和水平方向两类,其中垂直滚动的视图名是ScroLLView,水平滚动的视图名是HorizontalScroLLView.这两个滚动视图的使用并不复杂,主要注意一下3点:
    (1)垂直方向滚动时,layout_width要设置为match_parent,layout_height要设置为wrap_content
    (2)水平方向滚动时,layout_width要设置为wrap_content,layout_height要设置为match_parent.
    (3)滚动视图节点下面必须且只能挂着一个布局节点,否则会运行报错

3. 简单控件
3.1 文本视图TextView
3.2 按钮Button
    Button派生自TextView,二者 在UI上的区别主要是Button控件有个按钮外观,提示用户点击这里
    可以添加点击事件和长按事件回调
3.3 ImageView是图像显式空间
    注:setImageResource会有延迟连续设置只会显式最后一张
3.4 图像按钮ImageButton
    ImageButton其实派生自ImageView,而不是派生自Button,ImageView拥有的属性和方法,ImageButton都拥有,只是ImageButton有个默认的按钮外观
    ImageButton和Button的主要区别在于:
    (1)Button即可显式文本也可显式图形,而ImageButton只能显式图形不能显式文本
    (2)ImageButton上的图像可按比例拉伸,而Button上的大图会拉伸变形(因为背景图无法按比例拉伸)
    (3)Button只能在背景显式一张图形,而ImageButton可分别在前景和背景显式两张图形,实现图片叠加的效果
3.5 图形Drawable
3.5.1 状态列表图形
      可以在点击Button时显式不同的状态图片(详见P46)
3.5.2 形状图形
      形状图形的定义文件shape元素为根节点.根节点下定义了6个节点:corners(圆角),gradient(渐变),padding(间隔),size(尺寸),solid(填充),stroke(描边),各节点的属性值主要是长宽,半径,角度以及颜色
3.5.3 九宫格图片
      为了防止图片因拉伸而边缘变宽变模糊,为了解决这个问题,Android专门设计了点九图片(详见P51)

#==================================================================
第三章 中级控件
#==================================================================
4. 相对布局RelativeLayout
   RelativeLayout下级视图的位置是相对位置,得有具体的参照物才能确定最终位置.如果不设定下级视图的参照物,那么下级视图默认显式在RelativeLayout内部的左上角.用于确定视图位置的参照物分两种,一种是与该视图自身平级的视图,另一种是该视图的上级视图(RelativeLayout)
5. 框架布局FrameLayout
   FrameLayout也是常用的布局,其下级视图无法指定所处的位置,只能统统从上级FrameLayout的左上角开始添加,并且后面添加的子视图会把之前的子视图覆盖掉.框架布局一般用于需要重叠显式的场合,比如绘图,游戏界面等
6. Android还提供了其他几个布局视图,如绝对布局AbsoluteLayout,表格布局TableLayout等,
7. 特殊按钮
7.1 复选框CheckBox
    要更换复选框左侧的勾选图像,可将button属性修改为自定义的勾选图形
7.2 开关switch
    Switch是开关按钮,Android4.0版本开始支持该空间.其实Swtich是一个高级版本的CheckBox,在选中与取消选中时可展现的界面元素比CheckBox丰富.Switch是升级版的CheckBox,实际开发中用的不多.原因之一是大家觉得Switch的默认界面很丑
7.3 单选按钮RadioButton
    单选按钮要在一组按钮中选择其中一项,并且不能多选,这要求有个容器确定这组按钮的范围,这个容器便是RadioGroup.RadioGroup实质上是个布局,同一组RadioButton都要放在同一个RadioGroup节点下
    *button: 主要用于图标大小要求不高,间隔要求也不高的场合
    *background: 主要用于能够以较大空间显示图标的场合
    *drawableLeft: 主要用于对图标与文字之间的间隔有要求的场合
8. 下拉框Sphiner
   Sphiner是下拉框,用于从一串列表中选择某项,功能类似于单选按钮的组合.下拉列表的展示方式有两种,一种是在当前下拉框的正下方展示列表,此时把sphinerMode属性设置为dropdown;另一种是在页面中部以对话框形式展示列表,此时把sphinnerMode属性设置为dialog,另外,Sphinner还可以在代码中调用下列4个方法
   (1)setPrompt: 设置标题文字
   (2)setAdapter: 设置下拉列表的适配器,适配器可选择ArrayAdapter或SimpleAdapter.
   (3)setSelection: 设置当前选中哪项.注意该方法要在setAdapter方法后调用
   (4)setOnItemSelecteListener:设置下拉列表的选择监听器,该监听器要实现接口OnItemSelectListener.
8.1 数组适配器ArrayAdapter
    ArrayAdapter主要用于每行列表只展示文本的情况,有两道工序,第一道工序是构造函数,除了提供一堆原始数据外,还可以指定下拉框当前文本的包装盒即xml配置文件这个布局文件内只有一个TextView,定义了当前选中文本的大小,颜色,对齐方式等属性.第二道工序是定义下拉列表的xml布局文件,定义了对话框列表中每行文本的显式属性
8.2 简单适配器SimpleAdapter
    ArrayAdapter只能显式文本列表,显然不够美观,有时我们还想给列表加上图标
9. 编辑框
9.1 文本编辑框EditText
    EditText是文本编辑框,用户可在次输入文本等信息.EditText的常用属性说明如下:
    (1)inputType: 指定输入的文本类型,代码中对应的方法是setInputType.
    (2)maxLength:指定文本输入的最大长度.该属性无法通过代码设置
    (3)hint:指定提示文本的内容,代码中对应的方法是setHint
    (4)textColorHint:指定提示文本的颜色,代码中对应的方法是setHintTextColor 
    其他功能: (1)更换编辑框的光标
            (2)更换编辑框的边框样式
            (3)自动隐藏输入法(编辑框会默认获得焦点,即默认获得焦点)
            (4)输入回车符自动跳转
10. 自动完成编辑框AutoCompleteTextView
    自动完成编辑框一般用于搜索文本框,如在电商App的搜索框输入商品文字时,下方会自动弹出提示词列表,方便用户快速选择具体商品.AutoCompleteTextView具体实现原理:EditText结合监听器TextWatch与下拉列表Sphinner,一旦监控到EditText的文本发生变化,就自动弹出适配好的文字下拉列表,选中具体的下拉项向EditText填入相应文字
11. 活动Activity基础
11.1 Activity的生命周期
    下面是Activity与生命周期有关的方法说明
    (1)onCreate: 创建页面.把页面上的各个元素加载到内存中
    (2)onStart: 开始页面.把页面显式在屏幕上
    (3)onResume: 恢复页面.让页面在屏幕上活动起来,例如开启动画,开始任务等
    (4)onPause: 暂停页面.让页面在屏幕上的动作停下来
    (5)onStop: 停止页面.把页面从屏幕上撤下来
    (6)onDestroy: 销毁页面.把页面从内存中清除掉
    (7)onRestart: 重启页面.重新加载内存中的页面数据
11.2 页面跳转
     首先进入测试页面ActJumpActivity,接着从该页面跳转到ActNextActivity,然后从ActNextActivity返回ActJumpActivity.
     首先打开ActJumpActivity,调用方法的顺序为:本页面onCreate()->onStart()->onResume;
     从ActJumpActivity跳转到ActNextActivity,调用方法的顺序为:上一个页面onPause()->下一个界面onCreate()->onStart()->onResume()->上一个页面onStop()
     从ActNextActivity回到ActJumpActivity,调用的方法顺序为:下一个页面onPause()->上一个页面onRestart()->onStart()->onResume()->下一个页面onStop()->onDestroy();
11.3 竖屏与横屏的切换
     无论是竖屏切换到横屏,还是横屏切换到竖屏,都是原屏幕的页面从onPause到onStop再到onDestroy一路销毁,然后新屏幕的页面从onCreate到onStart再到onResume一路创建而来
11.4 按Home键与返回App
     首先进入测试页面,接着按Home键,屏幕回到桌面,然后按任务键或长按Home键,屏幕调出进程视图;最后点击测试App,屏幕返回测试页面
     onCreate()->onStart()->onResume()->onPause()->onStop()->onRestart()->onStart()->onResume();
12. 使用Intent传递信息
12.1 显式Intent,直接指定来源类与目标类名,属于精确匹配
12.2 隐式Intent,没有明确指定要跳转的类名,只给出一个动作让系统匹配拥有相同字串定义的目标,属于模糊匹配
12.3 向上一个Activity返回参数(详见P86)
12.4 文本工具TextUtils
     Android专门提供了文本工具类TextUtils,用于简化字符串的一些常用操作,就刚才的字符串非空判断而言,利用TextUtils则只需调用一个isEmpty方法便成
     (1) isEmpty:判断字符换是否为空值
     (2) getTrimmedLenght:获取字符串去除头尾空格之后的长度
     (3) isDigitsOnly:判断字符串是否全部由数字组成
     (4) ellipsize:如果字符串超长,则返回按规则截断并添加省略号的字串

#==================================================================
第四章 数据存储
#==================================================================
13. Android五种主要存储方式的用法,包括共享参数SharedPreferences,数据库SQLite,SD卡文件,App的全局内存,
14. SharedPreferences共享参数
    SharedPreferences是Android的一个轻量级存储工具,采用的存储结构是Key-Value的键值对方式,类似于java的properties类,二者都是把Key-Value的键值对保存在配置文件中.不同的是Properties的文件内容是Key==Value这样的形式,而SharedPreferences的存储介质是符合XML规范的配置文件.保存SharedPreferences键值对信息的文件路径是/data/data应用包名/shared_prefs/文件名.xml
    基于XML格式的特点,SharedPreferences主要适用于如下场合
    (1)简单且孤立的数据.若是复杂且相互间有关,则要保存在数据库中
    (2)文本形式的数据.若是二进制数据,则要保存在文件中
    (3)需要持久化存储的数据.在App退出后再次启动时,之前保存的数据仍然有效
    可以用于记录登录密码及账号(只能记住一个用户的登录信息,并且手机号码跟密码不存在从属关系,如果换个手机号登录,前一个用户的登录信息就被覆盖了.真正意义上的记住密码功能是先输入手机号码,然后根据手机号码匹配保存的密码,一个密码对应一个手机号,从而实现具体手机号码的密码记忆功能)
15. 数据库SQLite
    SQLite是一个小巧的嵌入式数据库,使用方便,开发简单(详见P103)
16. SD卡文件操作
    手机存储空间一般分为两块,一块用于内部存储,另一块用于外部存储(SD)卡
    本来在AndroidManifest.xml里面配置了存储空间的权限,代码就能正常读写SD卡的文件可是Android7.0开始加强了SD卡的权限管理,即使App声明了完整的SD卡操作权限,系统仍然默认禁止该App访问外部存储.不过系统默认关闭存储其实只是关闭外部存储的公共空间,外部存储的私有空间依然可以正常读写.
17. 利用Application操作全局变量
    适合在Application中保存的全局变量主要有下面3类数据:
    (1)会频繁读取的信息,如用户名,手机号等
    (2)从网络上获取的临时数据,为节约流量,减少用户等待时间,想暂时放在内存中供下次使用,如logo,商品图片等
18. 内容提供ContentProvider
    ContentProvider为App存取内部数据提供统一的外部接口,让不同的应用之间得以共享数据.像我们熟知的SQLite操作的是应用自身的内部数据库;文件的上传和下载操作的是后端服务器的文件;而ContentProvider操作的是本设备其他应用的内部数据,是一种中间层次的数据存储形式(详见P121)
#==================================================================
第五章 高级控件
#==================================================================
19. 日期时间控件DatePicker(详见P141)
20. 时间选择器TimePicker(详见P142)
21. 列表类视图
21.1 基本适配器BaseAdapter
     第三章介绍下拉框Sphinner时提到该控件可使用ArrayAdapter和SimpleAdapter两种适配器.其中ArrayAdapter适用于纯文本的列表数据,SimpleAdapter适用于带图标的列表数据.实际应用中常常有更复杂的列表,比如同一项中存在多个控件,这种情况即使使用SimpleAdapter也很吃力,而且不易扩展.基于此,Android提供了一种适应性更强的基本适配器BaseAdapter,该适配器允许开发者在别的代码文件中进行逻辑处理,大大提高了代码的可读性和可维护性
22. 列表视图ListView
    如果想在页面上直接显式全部列表信息,就要引入新的列表视图ListView(详见P148)
23. 网格视图GridView
    除了列表视图,网格视图GridView也是常见的适配器视图,用于分行分列显式表格信息,比listView更适合展示商品清单(详见P154)
24. 翻页类视图ViewPager
    有没有一种空间允许页面在水平方向左右滑动,就像翻书,翻报纸一样呢?对于这种左右滑动的翻页功能,Android提供了已经封装好的控件,就是翻页视图ViewPager.对于ViewPager来说,一个页面就是一个项(相当于ListView的一个列表项),许多页面组成ViewPager的页面项.明确了ViewPager的原理类似ListView和GirdView,翻页视图的用法与它俩类似.ListView和GridView的适配器使用BaseAdapter,ViewPager的适配器使用PagerAdapter;(详见P158)
24.1 翻页标题栏PagerTitleStrip/PagerTabStrip
     为了方便开发者处理ViewPager的页码显式与切换,Android附带提供了两个控件,分别是PagerTitleStrip和PagerTabStrip.二者都是在ViewPager页面上方展示设定的页面标题,不同之处在于PagerTitleStrip只是单纯的文本标题效果,无法点击进行页面切换,PagerTabStrip类似选项卡效果,文本下面有横线,点击左右选项卡即可切换到对应页面(详见P161)
     应用:ViewPager的应用很广,当用户安装一个新的App时,第一次启动大多出现欢迎页面,这个引导页通常要往右翻好几页,才会进入App的主页面.启动引导页的效果大多是ViewPager做的
25. 碎片Fragment
    Fragment是个特别的存在,有点像报纸上的专栏,看起来只占据页面的一小块,但是这一小块有自己的声明周期,可以自行其事;并且这一小块的特性无论在哪个页面,给一个位置就行,添加后不影响宿主页面的其他区域,去除后也不影响宿主页面的其他区域.每个Fragment都有对应的布局文件,依据其使用方式可分为静态注册和动态注册两类.静态注册是布局文件中直接放置Fragment节点,类似于一个普通控件,可被多个布局文件同时引用.静态注册一般用于某个通用的页面部件(如logo条,广告条等),每个活动页面均可直接引用该部件
    使用静态注册需要注意一下两点:
    (1)framment节点必须指定id属性,否则App运行时会报错
    (2)如果页面代码继承自Activity,Fragment类就必须继承自android.app.Fragment,不能使用android.support.v4.app.Fragment,否则App会报错;如果页面代码继承自AppCompatActivity或FragmentActivity,那么无论是android.app.Fragment还是Android.support.v4.app.Fragment都可以使用
    动态注册(详见P170)
26. 广播Broadcast基础
    广播(Broadcast)用于Android组件之间的灵活通信,与Activity的区别在于:
    (1)Activity只能一对一通信:Broadcast可以一对多,一人发送广播,多人接收处理.
    (2)对于发送者来说,广播不需要考虑接收者有没有在工作,接收者在工作就接收广播,不在工作就丢弃广播
    (3)对于接收者来说,会收到各式各样的广播,所以接收者要自行过滤符合条件的广播,才能进行解包处理
27. 定时器AlarmManager
    AlarmManager是Android提供的一个全局定时器,利用系统闹钟定时发送广播.这样做的好处是:如果App提前注册闹钟的广播接收器,即使App退出了,只要定时到达,App就会被唤醒响应广播事件
    注:为了提高安卓系统的安全性,从9.0开始,系统全面禁止刚才静态注册的广播,凡是静态广播在9.0系统中都不在生效.这里定时器能够完美的实现广播功能,就是AlarmManager和PendingIntent相互配合的成果
28. 万年历项目详见(P180)
    小知识:月份选择器MonthPicker详见P181
29. 日程表项目详见P184
    小知识:振动器Vibrator

#==================================================================
第六章 自定义控件
#==================================================================
30. 测量尺寸
    XML中的尺寸类型
    match_parent  说明:与上级视图大小一样
    wrap_parent   说明:按照自身尺寸进行适配
    **dp          说明:具体的尺寸数值
31. 自定义视图(详见P189)
32. 自定义动画
33. 下拉刷新的动画(P205)
34. 圆弧进度动画(P207)
35. 自定义通知栏
    通知推送Notification使用设置方法时要注意4点
    (1)setSmallIcon方法必须调用,否则不会显式通知消息
    (2)setWhen与setUsesChronometer同时只能调用其中一个,即推送时间与计数器无法同时显式,因为他们都位于通知栏右边
    (3)setSubText与setProgress同时只能调用其中一个,因为附加说明与进度条都位于标题文本的下方
    (4)setNumber与setContentInfo同时只能调用其中一个,因为计数值与提示都位于通知栏右下方
    (详见P214)
36. 远程视图RemoteViews
    如果说对话框是一个小型页面,远程视图就是一个小型且简化的页面.简化的意思是功能减少了,限制变多了
37. 服务service基础
    service与生命周期有关的方法说明
    (1) onCreate():创建服务
    (2) onStartCommand(): 开始服务
    (3) onDestroy(): 销毁服务
    (4) onBind(): 绑定服务
    (5) onRebind(): 重新绑定.该方法只有当上次onUnbind返回true的时候才会被调用
    (6) onUnbind(): 解除绑定.返回值为true表示允许再次绑定,再绑定时调用onRebind方法;返回值为false表示只能绑定一次,不能再次绑定,默认为false
37.1 推送服务到前台
     服务没有自己的布局文件,也就意味着无法直接在页面上展示,服务不只能在外部进行启停或绑定,还能在内部模拟启停,当然仅是模拟而已,服务内部的启停方法也有对应的两个函数
     (1)startForeground:把当前服务切换到前台运行.第一个参数表示通知的编号,第二个参数表示Notification对象,意味着切换到前台就是展示到通知栏
     (2)stopForeground:停止前台运行,参数为true表示清楚通知,参数为false表示不清除.
     注:从Android9.0开始,要在服务中正常调用startForeground方法,还需修改AndroidManifest.xml,添加如下所示的前台服务权限配置:
     <use-permission android:name="android.permission.FOREGROUND_SERVICE">
38. 手机安全助手(详见P230)
#==================================================================
第七章 组合空间
#==================================================================
39. 标签栏
    实现底部标签栏的页面切换主要有3种方式:基于TabActivity的标签栏,基于ActivityGroup的标签栏和基于FragmentActivity的标签栏,3种方式各有千秋
    (1)基于TabActivity的标签栏
    TabActivity原本就是设计用来做标签页面的,并提供了TabHost和TabWeight两个空间,只不过他们仅用于标签栏,所以无需深入了解,套用固定的框架就行 
    (2)基于ActivityGroup的标签栏
    AvtivityGroup就是Activity的组合,允许在内部开启活动页面.从这个意义上来说,ActivityGroup与Activity的关系相当于Activity与Fragment的关系.使用ActivityGroup实现标签栏也有固定的模板.
    (3)基于FragmentActivity的标签栏
    前面提到,ActivityGroup方式采用一个ActivityGroup对应多个Activity的做法,那么也可以采取一个Activity对应多个Fragment的做法,基于FragmentActivity的标签栏就是该思路.与前两种凡是一样,FragmentActivity也有固定的使用模板
40. 导航栏
    在Android5.0之前,这个顶部导航栏以ActionBar控件的形式出现,但ActionBar存在不灵活,难以扩展的毛病,所以Android5.0之后退出了ToolBar工具栏控件,意在取代ActionBar,不过为了兼容之前的版本,ActionBar控件仍然保留,想要引入Toolbar就得先关闭ActionBar
41. 溢出菜单OverflowMenu
    导航栏右边往往有个三点图标,点击后会弹出菜单.这个右上角的弹出菜单名叫溢出菜单OverflowMenu,意指导航栏不够放了,溢出来了.溢出菜单其实就是把选项菜单OptionsMenu搬到了页面右上方
42. 搜索框SearchView
    导航栏中间往往有个搜索框,特别是电商App的导航栏,搜索框是标配.在工具栏上添加并使用详见(P250)
43. 标签布局TabLayout(详见P253)
44. 横幅条
    实现横幅轮番Banner:每隔两三秒就轮播下一个广告页.只要结合Handler+Runabel就可以实现轮询播放图片
45. 增强型列表
    
    

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================
