#==================================================================
Android Studio开发实战
#==================================================================
第一章 App的工程结构
#==================================================================
1.1 AndroidStudio的工程创建分两个层级:第一个层级通过菜单File->New->New Project创建,这里的新项目是指新的工作空间,对应Eclipse的workplace;第二个层级通过菜单File->New->New Moudle创建,这里的新模块指一个单独的App工程,对应Eclipse的project.第一次运行AndroidStudio都是选择Newproject,表示先创建一个工作空间;后面还想创建新的App工程时,只需要NewMoudle,表示在当前工作空间下创建一个App工程.
1.2 app目录下有3个子目录,功能说明如下:
    (1)manifests子目录,下面只有一个xml文件,即AndroidManifest.xml,是App的运行配置文件
    (2)java子目录,下面有3个包,其中第一个包存放的是App工程java源代码,后面两个包存放的是测试用的java代码
    (3)res子目录,存放的是App工程的资源文件.res子目录下又有4个子目录:
    drawable目录存放的是图形描述文件与用户图片
    layout目录存放的是App页面的布局文件
    mipmap目录存放的是启动图标
    values目录存放的是一些常量定义文件,比如字符串常量string.xml,像素常量dimens.xml,颜色常量colors.xml,样式风格定义style.xml等
    (4)GradleScripts下面主要是工程的编译配置文件,主要有
    build.gradle,该文件分为项目级与模块级两种,用于描述App工程编译规则
    proguard-rules.pro,该文件用于描述java文件的代码混淆规则
    gradle.properties,该文件用于配置编译工程的命令行参数,一般无需改动
    setting.gradle,配置那些模块在一起编译,初始内容为include ':app',表示只编译App模块
    local.properties,项目的本地配置,一般无需改动.该文件是在工程编译时自动生成的,用于描述开发者本机的环境配置,比如SDK的本地路径,NDK的本地路径等
1.3 编译配置文件build.gradle书P12
1.4 App运行配置AndroidManifest.xml 
    AndroidManifest.xml用于指定App内部的运行配置,是一个XML描述文件,根节点的pacakge指定了该App的包名.manifest下面又有若干子节点,分别说明如下:
    (1)uses-sdk,该节点有两个属性:android:minSdkVersion和android:targetSdkVersion.这两个属性是早期Eclipse开发App时使用的,现在这两个字段改成放在build.gradle文件中,故而AndroidStudio不配置uses-sdk也没有关系
    (2)uses-permission,该节点用于声明App运行过程中需要的权限名称 
    (3)application,该界定啊用于指定App的自身属性(详见P13)

#==================================================================
第二章 初级控件
#==================================================================
2. 视图view的基本属性
   (1)id: 指定该视图的编号
   (2)layout_width: 指定视图的宽度,可以是具体的dp数值;可以是match_parent,表示于上级视图一样宽;也可以是wrap_content,表示与内部内容一样宽(内部内容若超过上级视图的宽度,则该视图保持与上级视图一样宽,超出宽度的内容得进行滚动才能显式出来)
   (3)layout_height: 指定该视图的高度.取值说明同layout_width;
   (4)layout_margin: 指定该视图与周围视图之间的空白距离(包括上,下,左,右).另有layouy_marginTopdeng等.分别表示单独指定视图与上边,下边,左边,右边视图的距离
   (5)minWidth: 指定该视图的最小宽度
   (6)minHeight: 指定该视图的最小高度
   (7)background: 指定该视图的背景,背景可以是颜色,也可以是图片.
   (8)layout_gravity: 指定该视图与上级视图的对齐方式.对齐方式的取值详见P28
   (9)padding: 指定该视图边缘与内部内容之间的空白距离.另有padding Top等分别表示指定视图边缘于内容上边,下边,左边,右边的距离. 
   等(详见P28)

2.1 线性布局LinearLayout
    LinearLayout是最常用的布局,名字叫线性布局.顾名思义,LinearLayout下面的子视图就像用一根线串了起来,所以Li                                                                                                                                                                                                                           nearLayout内部视图的排列是顺序的,要么从上倒下一次垂直排列,要么从左到右依次水平排列.LinearLayout除了继承View/
    ViewGroup类的所有属性和方法外,还有奇特有的XML属性
    (1)orientation: 指定线性布局的方向.horizontal表示水平布局,vertial表示垂直布局.如果不指定该属性,就默认是horizontal.
    (2)gravity: 指定布局内部视图与本线性布局的对齐方式.取值说明同layout_gtavity
    (3)layout_weight: 指定当前视图的宽或搞占上级线性布局的权重,这里要注意,layout_weight属性并非在当前LinearLayout节点中设置,而是在下级视图的节点中设置.另外,如果layout_weight指定的是当前视图在宽度上占的权重,layout_weight就要同时设置为0dp;如果layout_weight指定的是当前视图在高度上占的权重,layout_height就要同时设置为0dp.
2.2 滚动视图ScroLLView
    手机屏幕的显示空间有限,常常需要上下滑动显示出其他页面,这时就要借助ScroLLView滚动视图实现了,与线性布局类似,滚动视图也分为垂直方向和水平方向两类,其中垂直滚动的视图名是ScroLLView,水平滚动的视图名是HorizontalScroLLView.这两个滚动视图的使用并不复杂,主要注意一下3点:
    (1)垂直方向滚动时,layout_width要设置为match_parent,layout_height要设置为wrap_content
    (2)水平方向滚动时,layout_width要设置为wrap_content,layout_height要设置为match_parent.
    (3)滚动视图节点下面必须且只能挂着一个布局节点,否则会运行报错

3. 简单控件
3.1 文本视图TextView
3.2 按钮Button
    Button派生自TextView,二者 在UI上的区别主要是Button控件有个按钮外观,提示用户点击这里
    可以添加点击事件和长按事件回调
3.3 ImageView是图像显式空间
    注:setImageResource会有延迟连续设置只会显式最后一张
3.4 图像按钮ImageButton
    ImageButton其实派生自ImageView,而不是派生自Button,ImageView拥有的属性和方法,ImageButton都拥有,只是ImageButton有个默认的按钮外观
    ImageButton和Button的主要区别在于:
    (1)Button即可显式文本也可显式图形,而ImageButton只能显式图形不能显式文本
    (2)ImageButton上的图像可按比例拉伸,而Button上的大图会拉伸变形(因为背景图无法按比例拉伸)
    (3)Button只能在背景显式一张图形,而ImageButton可分别在前景和背景显式两张图形,实现图片叠加的效果
3.5 图形Drawable
3.5.1 状态列表图形
      可以在点击Button时显式不同的状态图片(详见P46)
3.5.2 形状图形
      形状图形的定义文件shape元素为根节点.根节点下定义了6个节点:corners(圆角),gradient(渐变),padding(间隔),size(尺寸),solid(填充),stroke(描边),各节点的属性值主要是长宽,半径,角度以及颜色
3.5.3 九宫格图片
      为了防止图片因拉伸而边缘变宽变模糊,为了解决这个问题,Android专门设计了点九图片(详见P51)

#==================================================================
第三章 中级控件
#==================================================================
4. 相对布局RelativeLayout
   RelativeLayout下级视图的位置是相对位置,得有具体的参照物才能确定最终位置.如果不设定下级视图的参照物,那么下级视图默认显式在RelativeLayout内部的左上角.用于确定视图位置的参照物分两种,一种是与该视图自身平级的视图,另一种是该视图的上级视图(RelativeLayout)
5. 框架布局FrameLayout
   FrameLayout也是常用的布局,其下级视图无法指定所处的位置,只能统统从上级FrameLayout的左上角开始添加,并且后面添加的子视图会把之前的子视图覆盖掉.框架布局一般用于需要重叠显式的场合,比如绘图,游戏界面等
6. Android还提供了其他几个布局视图,如绝对布局AbsoluteLayout,表格布局TableLayout等,
7. 特殊按钮
7.1 复选框CheckBox
7.2 单选按钮RadioButton
8. 下拉框Sphiner
   Sphiner是下拉框,用于从一串列表中选择某项,功能类似于单选按钮的组合.下拉列表的展示方式有两种,一种是在当前下拉框的正下方展示列表,此时把sphinerMode属性设置为dropdown;另一种是在页面中部以对话框形式展示列表,此时把sphinnerMode属性设置为dialog,另外,Sphinner还可以在代码中调用下列4个方法
   (1)setPrompt: 设置标题文字
   (2)setAdapter: 设置下拉列表的适配器,适配器可选择ArrayAdapter或SimpleAdapter.
   (3)setSelection: 设置当前选中哪项.注意该方法要在setAdapter方法后调用
   (4)setOnItemSelecteListener:设置下拉列表的选择监听器,该监听器要实现接口OnItemSelectListener.
9. 编辑框
9.1 文本编辑框EditText
    EditText是文本编辑框,用户可在次输入文本等信息.EditText的常用属性说明如下:
    (1)inputType: 指定输入的文本类型,代码中对应的方法是setInputType.
    (2)maxLength:指定文本输入的最大长度.该属性无法通过代码设置
    (3)hint:指定提示文本的内容,代码中对应的方法是setHint
    (4)textColorHint:指定提示文本的颜色,代码中对应的方法是setHintTextColor 
    其他功能: (1)更换编辑框的光标
            (2)更换编辑框的边框样式
            (3)自动隐藏输入法(编辑框会默认获得焦点,即默认获得焦点)
            (4)输入回车符自动跳转
10. 自动完成编辑框AutoCompleteTextView
    自动完成编辑框一般用于搜索文本框,如在电商App的搜索框输入商品文字时,下方会自动弹出提示词列表,方便用户快速选择具体商品.AutoCompleteTextView具体实现原理:EditText结合监听器TextWatch与下拉列表Sphinner,一旦监控到EditText的文本发生变化,就自动弹出适配好的文字下拉列表,选中具体的下拉项向EditText填入相应文字
11. 活动Activity基础
11.1 Activity的生命周期
    下面是Activity与生命周期有关的方法说明
    (1)onCreate: 创建页面.把页面上的各个元素加载到内存中
    (2)onStart: 开始页面.把页面显式在屏幕上
    (3)onResume: 恢复页面.让页面在屏幕上活动起来,例如开启动画,开始任务等
    (4)onPause: 暂停页面.让页面在屏幕上的动作停下来
    (5)onStop: 停止页面.把页面从屏幕上撤下来
    (6)onDestroy: 销毁页面.把页面从内存中清除掉
    (7)onRestart: 重启页面.重新加载内存中的页面数据
11.2 页面跳转
     首先进入测试页面ActJumpActivity,接着从该页面跳转到ActNextActivity,然后从ActNextActivity返回ActJumpActivity.
     首先打开ActJumpActivity,调用方法的顺序为:本页面onCreate()->onStart()->onResume;
     从ActJumpActivity跳转到ActNextActivity,调用方法的顺序为:上一个页面onPause()->下一个界面onCreate()->onStart()->onResume()->上一个页面onStop()
     从ActNextActivity回到ActJumpActivity,调用的方法顺序为:下一个页面onPause()->上一个页面onRestart()->onStart()->onResume()->下一个页面onStop()->onDestroy();
11.3 竖屏与横屏的切换
     无论是竖屏切换到横屏,还是横屏切换到竖屏,都是原屏幕的页面从onPause到onStop再到onDestroy一路销毁,然后新屏幕的页面从onCreate到onStart再到onResume一路创建而来
11.4 按Home键与返回App
     首先进入测试页面,接着按Home键,屏幕回到桌面,然后按任务键或长按Home键,屏幕调出进程视图;最后点击测试App,屏幕返回测试页面
     onCreate()->onStart()->onResume()->onPause()->onStop()->onRestart()->onStart()->onResume();
12. 使用Intent传递信息
12.1 显式Intent,直接指定来源类与目标类名,属于精确匹配
12.2 隐式Intent,没有明确指定要跳转的类名,只给出一个动作让系统匹配拥有相同字串定义的目标,属于模糊匹配
12.3 向上一个Activity返回参数(详见P86)

#==================================================================
第四章 数据存储
#==================================================================
13. Android五种主要存储方式的用法,包括共享参数SharedPreferences,数据库SQLite,SD卡文件,App的全局内存,
14. SharedPreferences共享参数
    SharedPreferences是Android的一个轻量级存储工具,采用的存储结构是Key-Value的键值对方式,类似于java的properties类,二者都是把Key-Value的键值对保存在配置文件中.不同的是Properties的文件内容是Key==Value这样的形式,而SharedPreferences的存储介质是符合XML规范的配置文件.保存SharedPreferences键值对信息的文件路径是/data/data应用包名/shared_prefs/文件名.xml
    基于XML格式的特点,SharedPreferences主要适用于如下场合
    (1)简单且孤立的数据.若是复杂且相互间有关,则要保存在数据库中
    (2)文本形式的数据.若是二进制数据,则要保存在文件中
    (3)需要持久化存储的数据.在App退出后再次启动时,之前保存的数据仍然有效
    可以用于记录登录密码及账号(只能记住一个用户的登录信息,并且手机号码跟密码不存在从属关系,如果换个手机号登录,前一个用户的登录信息就被覆盖了.真正意义上的记住密码功能是先输入手机号码,然后根据手机号码匹配保存的密码,一个密码对应一个手机号,从而实现具体手机号码的密码记忆功能)
15. 数据库SQLite
    SQLite是一个小巧的嵌入式数据库,使用方便,开发简单(详见P103)
16. SD卡文件操作
    手机存储空间一般分为两块,一块用于内部存储,另一块用于外部存储(SD)卡
    本来在AndroidManifest.xml里面配置了存储空间的权限,代码就能正常读写SD卡的文件可是Android7.0开始加强了SD卡的权限管理,即使App声明了完整的SD卡操作权限,系统仍然默认禁止该App访问外部存储.不过系统默认关闭存储其实只是关闭外部存储的公共空间,外部存储的私有空间依然可以正常读写.
17. 利用Application操作全局变量
    适合在Application中保存的全局变量主要有下面3类数据:
    (1)会频繁读取的信息,如用户名,手机号等
    (2)从网络上获取的临时数据,为节约流量,减少用户等待时间,想暂时放在内存中供下次使用,如logo,商品图片等
18. 内容提供ContentProvider
    ContentProvider为App存取内部数据提供统一的外部接口,让不同的应用之间得以共享数据.像我们熟知的SQLite操作的是应用自身的内部数据库;文件的上传和下载操作的是后端服务器的文件;而ContentProvider操作的是本设备其他应用的内部数据,是一种中间层次的数据存储形式(详见P121)
#==================================================================
第五章 高级控件
#==================================================================
19. 日期时间控件DatePicker(详见P141)
20. 时间选择器TimePicker(详见P142)
21. 列表类视图
21.1 基本适配器BaseAdapter
     第三章介绍下拉框Sphinner时提到该控件可使用ArrayAdapter和SimpleAdapter两种适配器.其中ArrayAdapter适用于纯文本的列表数据,SimpleAdapter适用于带图标的列表数据.实际应用中常常有更复杂的列表,比如同一项中存在多个控件,这种情况即使使用SimpleAdapter也很吃力,而且不易扩展.基于此,Android提供了一种适应性更强的基本适配器BaseAdapter,该适配器允许开发者在别的代码文件中进行逻辑处理,大大提高了代码的可读性和可维护性
22. 列表视图ListView
    如果想在页面上直接显式全部列表信息,就要引入新的列表视图ListView(详见P148)
23. 网格视图GridView
    除了列表视图,网格视图GridView也是常见的适配器视图,用于分行分列显式表格信息,比listView更适合展示商品清单(详见P154)
24. 翻页类视图ViewPager
    有没有一种空间允许页面在水平方向左右滑动,就像翻书,翻报纸一样呢?对于这种左右滑动的翻页功能,Android提供了已经封装好的控件,就是翻页视图ViewPager.对于ViewPager来说,一个页面就是一个项(相当于ListView的一个列表项),许多页面组成ViewPager的页面项.明确了ViewPager的原理类似ListView和GirdView,翻页视图的用法与它俩类似.ListView和GridView的适配器使用BaseAdapter,ViewPager的适配器使用PagerAdapter;(详见P158)
24.1 翻页标题栏PagerTitleStrip/PagerTabStrip
     为了方便开发者处理ViewPager的页码显式与切换,Android附带提供了两个控件,分别是PagerTitleStrip和PagerTabStrip.二者都是在ViewPager页面上方展示设定的页面标题,不同之处在于PagerTitleStrip只是单纯的文本标题效果,无法点击进行页面切换,PagerTabStrip类似选项卡效果,文本下面有横线,点击左右选项卡即可切换到对应页面(详见P161)
     应用:ViewPager的应用很广,当用户安装一个新的App时,第一次启动大多出现欢迎页面,这个引导页通常要往右翻好几页,才会进入App的主页面.启动引导页的效果大多是ViewPager做的
25. 碎片Fragment
    Fragment是个特别的存在,有点像报纸上的专栏,看起来只占据页面的一小块,但是这一小块有自己的声明周期,可以自行其事;并且这一小块的特性无论在哪个页面,给一个位置就行,添加后不影响宿主页面的其他区域,去除后也不影响宿主页面的其他区域.每个Fragment都有对应的布局文件,依据其使用方式可分为静态注册和动态注册两类.静态注册是布局文件中直接放置Fragment节点,类似于一个普通控件,可被多个布局文件同时引用.静态注册一般用于某个通用的页面部件(如logo条,广告条等)


#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================
#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================
#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================

#==================================================================
