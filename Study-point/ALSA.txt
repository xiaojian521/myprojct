Linux Alsa Study
#=======================================================================
资料文档:
Alsa音频编程【精华】 https://www.cnblogs.com/cslunatic/p/3677729.html
https://blog.csdn.net/zyuanyun/article/details/59180272

#=======================================================================
1.基本概念
(1)样本长度(sample):样本是记录音频数据的最基本的单位,计算机对每个通道采样量化时数字比特位数,常见的有8位和16位.
(2)通道数(channel):该参数1表示单声道,2则是立体声
(3)帧(frame):帧记录了一个声音单元,其长度为样本长度与通道数的乘积,一段音频数据就是由若干帧组成的.
(4)采样率(rate):每秒钟采样次数,该次数是针对帧而言的,常用的采样率如8KHz的人声,44.1KHz的mp3音乐,96KHz的蓝光音频.
(5)周期(period):音频设备一次处理所需要的帧数,对于音频设备的数据访问以及音频数据的存储,都是以此为单位的.如果周期大小设定得较大,则单次处理的数据较多,这意味着单位时间内硬件中断的次数较少,CPU也就有更多时间处理其他任务,功耗也更低,但这样也带来一个显著的弊端--数据处理的时延会增大.
(6)交错模式(interleaved):是一种音频数据的记录方式
    (6.1)在交错模式下,数据以连续帧的形式存放,即首先记录完帧1的左声道样本和右声道样本(假设为立体声格式),再开始帧2的记录
    (6.2)而在非交错模式下,首先记录的是一个周期内所有帧的左声道样本,再记录右声道样本,数据是以连续通道的方式存储.
    不过多数情况下,我们只需要使用交错模式就可以了.
(7)period(周期):硬件中中断间的间隔时间.它表示输入延时.
(8)比特率(Bits Per Second):比特率表示每秒的比特数,比特率=采样率*声道数*样本长度
(9)Buffer Size: 数据缓冲区大小,这里指runtime的buffer size,而不是结构图snd_pcm_hardware中定义的buffer_bytes_max;一般来说buffer_size=period_size*period_count,period_count相当于处理完一个buffer数据所需的中断次数

补充:在说说period bytes,对于dma处理来说,它直接关心的是数据大小,而非period_size(一个周期的帧数),有个转换关系:period_bytes=period_size*samp_bites*channels/8
由于12S总线采样率是稳定的,我们可以计算12S传输一个周期的数据所需的时间:
trasfer_time=1*period_size/sample_rate, in Second
例如period_size=1024,sample_rate=48kHz,那么一个周期数据的传输时间是:1*1024/48000=21.3(ms)


#=======================================================================
2. ALSA基础
ALSA由许多声卡的声卡驱动程序组成,同时它也提供一个称为libasound的API库
应用程序开发者应该使用libasound而不是内核中的ALSA接口,因为libasound提供最高级并且变成方便的编程接口.并且提供一个设备逻辑命名功能,这样开发者甚至不需要知道类似设备文件这样的低层接口.
相反,OSS/Free驱动是在内核系统调用级上变成,它要求开发者提供设备文件名并且利用ioctrl来实现相应的功能.
ALSA包含插件功能,使用插件可以扩展新的声卡驱动,包括完全用软件实现的虚拟声卡

#=======================================================================
3. ALSA体系结构
ALSA API可以分解成以下几个主要的接口:
(1)控制接口:提供管理声卡注册和请求可用设备的通用功能
(2)PCM接口:管理数字音频回放(playback)和录音(capture)的接口.
(3)Raw MIDI接口:支持MIDI(Musical Instrument Digital Interface),标准的电子乐器.这些API提供对声卡上MIDI总线的访问.这个原始接口基于MIDI事件工作,由程序员负责管理协议以及时间处理.
(4)定时器(Timer)接口:为同步音频时间提供对声卡上时间处理硬件的访问.
(5)时序器(Sequencer)接口
(6)混音器(Mixer)接口

#=======================================================================
4. 设备命名
API库使用逻辑设备名而不是设备文件.设备名字可以是真实的硬件名字也可以是插件名字.硬件名字使用hw:i,j这样的格式.其中i是卡号,j是这块声卡上的设备号
第一个声音设备是hw:0,0这个别名默认引用第一块声音设备并且在文本示例中一直会被用到.
插件使用另外的唯一名字,比如plughw:;表示一个插件,这个插件不提供对硬件设备的访问,而是提供像采样率转换这样的软件特性,硬件本身并不支持这样的特性.

#=======================================================================
5. 声音缓存和数据传输
每个声卡都有一个硬件缓存区来保存记录下来的样本.
当缓存区足够满时,声卡将产生一个中断.
内核声卡驱动然后使用直接内存(DMA)访问通道将样本传送到内存中的应用程序缓存区.类似地,对于回放,任何应用程序使用DMA将自己的缓存区数据传送到声卡的硬件缓存区中.
硬件缓存区是环缓存.也就是说当数据到达缓存区末尾时将重新回到缓存区的起始位置.
ALSA维护一个指针来指向硬件缓存以及应用程序缓存区中数据操作的当前位置.
应用程序缓存区的大小可以通过ALSA库函数调用来控制.
缓存区可以很大,一次传输操作可能会导致不可接受的延迟,我们把它称为延时(latency).
为了解决这个问题,ALSA将缓存区拆分成一些列周期(period)(OSS/Free中叫片段fragments).ALSA以period为单元来传送数据.
一个周期(period)存储一些帧(frames).每一帧包含时间上一个点所抓取的样本.对于立体声设备,一个帧会包含两个信道上的样本.
左右信道信息被交替地存储在一个帧内.这称为交错(interleaved)模式.

#=======================================================================
6. Over and Unfer Run
当一个声卡活动时,数据总是连续地在硬件缓存区和应用程序缓存区间传输.
但是也有例外
(1)在录音例子中,如果应用程序读取数据不够快,循环缓存区将会被新的数据覆盖.这种数据的丢失被称为"over run".
(2)在回放例子中,如果应用程序写入数据到缓存区中的速度不够快,缓存区将会"饿死".这样的错误被称为"under run"

当用户空间由于系统繁忙等原因,导致under run时,缓冲区已空,内核这里有两种方案:
(1)停止DMA传输,进入under run状态.这是内核默认的处理方法.继续播放缓冲区的音频数据或静音数据.
用户空间配置stop_threshold可选择方案1或方案2,配置silence_threshold选择继续播放原有的音频数据还是静音数据.

#=======================================================================
7. 音频参数(ALSA用户空间之TinyAlsa)
TinyAlsa是Android默认的alsalib,封装了内核ALSA的接口,用于简化用户空间的ALSA编程.
合理的pcm_config可以做到更好的低时延和功耗,移动设备的开发尤为敏感
struct pcm_config {
    unsigned int channels;
    unsigned int rate;
    unsigned int period_size;
    unsigned int period_count;
    enum pcm_format format;
    unsigned int start_threshold;
    unsigned int stop_threshold;
    unsigned int silence_threshold;
    int avail_min;
};
解释一下结构中的各个参数,每个参数的单位都是frame(1帧=通道*采样位深):
(1)period_size.每次传输的数据长度.值越小,时延越小,cpu占用就越高.
(2)period_count.缓冲区period的个数.缓冲区越大,发生XRUN的机会就越少.
(3)format.定义数据格式,如采样位,大小端.
(4)start_threshold.缓冲区的数据超过该值时,硬件开始启动数据传输.如果太大,从开始播放到声音出来时延太长,甚至可导致太短促的声音根本播不出来;如果太小,又可能容易导致under run/over run
(5)stop_threshold.缓冲区空闲区大于该值时,硬件停止传输.默认情况下,这个数为整个缓冲区的大小,即整个缓冲区空了,就停止传输.但偶尔的原因导致缓冲区空,如cpu忙.增大该值,继续播放缓冲区的历史数据,而不关闭在启动硬件传输,可以达到更好的体验
(6)silence_threshold.这个值本来是配合stop_threshold使用,往缓冲区填充静音数据,这样就不会重播历史数据了.
(7)avail_min.缓冲区空闲区大于该值时,pcm_mmap_write()才往缓冲写数据.这个值越大,往缓冲区写入数据的次数就越少,面临underrun/overrun的机会就越大.Android samsung tuna设备在screen_off时增大该值以减小功耗,在screen_on时减小该值以减小underrun/overrun的机会

#=======================================================================
文档资料
linux-alsa详解1 基本知识 https://www.cnblogs.com/xinghuo123/p/13121108.html
#=======================================================================
1. linux内核中alsa的软件结构如下：
APP1    APP2    APP3
||      ||      ||
\/      \/      \/           USER空间
    alsa-lib
---------------------------------------
    alsa-soc
    alsa-driver
        ||                   Kernel空间
        \/   
---------------------------------------
    Audio hardware           硬件

用户空间的alsa-lib对应用程序提供统一的API接口,这样可以隐藏了驱动层的实现细节,简化了应用程序的实现难度,内核空间中,alsa-soc其实是对alsa-driver的进一步封装,他针对嵌入式设备提供了一系列增强的功能

#=======================================================================
2. alsa的设备文件结构
$ cd /dev/Second
$ ls -l
crw-rw----+ 1 root audio 116, 8 2011-02-23 21:38 controlC0
crw-rw----+ 1 root audio 116, 4 2011-02-23 21:38 midiC0D0
crw-rw----+ 1 root audio 116, 7 2011-02-23 21:39 pcmC0D0c
crw-rw----+ 1 root audio 116, 6 2011-02-23 21:56 pcmC0D0p
crw-rw----+ 1 root audio 116, 5 2011-02-23 21:38 pcmC0D1p
crw-rw----+ 1 root audio 116, 3 2011-02-23 21:38 seq
crw-rw----+ 1 root audio 116, 2 2011-02-23 21:38 timer
可以看到以下设备文件:
(1) controlC0 --> 用于声卡的控制,例如通道选择,混音,麦克控制,音量加减,开关等
(2) midiC0D0  --> 用于播放midi音频
(3) pcmC0D0c  --> 用于录音的pcm设备
(4) pcmC0D0P  --> 用于播放的pcm设备
(5) seq       --> 音序器
(6) timer     --> 定时器

其中,C0D0代表的是声卡0中的设备0,pcmC0D0c最后一个c代表capture,pcmC0D0p最后一个p代表playback,这些都是alsa-driver中的命名规则,从上面的列表可以看出,我的声卡下挂了6个设备,根据声卡的实际能力,驱动实际上可以挂上更多种类的设备,在include/sound/core.h中,定义了以下设备类型，通常更关心的是pcm和control这两种设备.。

#=======================================================================
3. hrtimer 模拟 PCM 周期中断
在 4.2.1. pcm operations 章节中，我们提到：每次 dma 传输完成一个周期的数据传输后，都要调用 snd_pcm_period_elapsed() 告知 pcm native 一个周期的数据已经传送到 FIFO 上了，然后再次调用 dma 传输音频数据…如此循环。

但有些 Platform 可能由于设计如此或设计缺陷，dma 传输完一个周期的数据不会产生硬件中断。这样系统如何知道什么时候传输完一个周期的数据了呢？在上个章节的最后，我们提到 I2S 总线传输一个周期的数据所需的时间，这其实也是 dma 搬运一个周期的数据所需的时间，这很容易理解：I2S FIFO 消耗完一个周期的数据，dma 才接着搬运一个周期的数据到 I2S FIFO。

因此我们可以用定时器来模拟这种硬件中断：

触发dma搬运数据时，启动定时器开始计时；
当定时到 1 * period_size / sample_rate，这时 I2S 已传输完一个周期的音频数据了，进入定时器中断处理：调用 snd_pcm_period_elapsed() 告知 pcm native 一个周期的数据已经处理完毕了，同时准备下一次的数据搬运；
继续执行步骤 1…
为了更好保证数据传输的实时性，建议采用高精度定时器 hrtimer。

作者见过至少两家芯片在传输音频数据时需要用定时器模拟周期中断，一是 MTK 的智能手机处理器，二是 Freescale 的 i.MX 系列处理器。后者已经合入 Linux 内核代码，具体见：sound/soc/imx/imx-pcm-fiq.c，这里简略分析：

#=======================================================================
Android中的PCM设备
https://www.cnblogs.com/chenzhizhong/p/6604405.html

#=======================================================================
1. 查看PCM设备列表
如果手机音频系统正常工作没我们可以通过adb去查看系统中所有音频设备文件
ls /dev/snd
音频设备的命名规则为[device type]C[card index]D[device index][capture/playback],即名字中含有4部分的信息：
1.device type
设备类型，通常只有compr/hw/pcm这3中.从显示中可以看到声卡会管理很多设备,PCM设备只是其中的一种设备
2.card index
声卡的id,代表第几块声卡.通常都是0,代表第一块声卡.手机上通常都只有一块声卡
3.device index
设备的id,代表这个设备是声卡上的第几个设备.设备的ID只和驱动中配置的DAI link的次序有关.如果驱动没有改变,那么这些ID就是固定的.
4.capture/playback
只有PCM设备才有这部分,只有c和p两种,c代表capture,说明这是一个提供录音的设备,p代表playback.说明这是一个提供播放的设备.
系统会在/proc/asound/pcm文件中列出所有的音频设备的信息，如果是肉眼查看，/proc/asound/pcm中的信息会更只管一些

#=======================================================================
2. PCM设备文件的访问
查看PCM设备文件的属性,可看到它们都是字符型设备:
对于普通的字符型设备,我们都是通过系统调用open/read/write/close来访问,有些设备支持随机访问,我们还可以使用lseek调用.PCM设备文件也是类似,不一样的是,我们可以使用open/close来打开/关闭设备,读取/写入文件却不是通过read/write,而都是通过ioctl来操作的.
在Android Audio HAL层中,是通过TinyAlsa来访问PCM设备文件的.TinyAlsa封装了一系列接口用于PCM设备的访问,这些接口被AudioHal调用以后,最终又会被Frameworks调用.接口包括:
1.struct pcm *pcm_open(unsigned int card, unsigned int device, unsinged int flags, struct pcm_config *config)
2.int pcm_close(struct pcm* pcm)
3.int pcm_write(struct pcm pcm, const void data, unsigned int count)
4.int pcm_read(struct pcm* pcm, void* data, unsigned int count)

#=======================================================================
3. PCM设备的管理---PCM ID
使用TinyAlsa接口访问PCM设备的时候,需要直到设备的id,这个id我们称为PCM ID,那么如何直到某一个设备例如speaker的PCM ID呢?另外,在不接耳机的时候,我们希望声音从speaker出来,这时候需要直到的是speaker的PCM ID,如果接了耳机,我们希望声音从耳机出来,这时候需要直到的是耳机的PCM ID
针对这些问题,需求,AudioHal的设计是根据使用场景(USECASE)来决定要使用哪些设备的,即未各个USECASE分别定义好要使用的PCM设备的ID
Frameworks通过USECASE来制定PCM设备,而AudioHAL通过USERCASE来找到PCM设备文件路径
USECASE与PCM ID的映射关系可以通过配置文件来修改,这样的好处就是所有产品可以使用同一套代码,差异的地方可以通过控制配置文件的内容就可以简单的区分开来,AudioHAL会解析这个配置文件,然后更新映射表内容.

#=======================================================================
4. Audio timestamp时间戳分析
https://www.kernel.org/doc/html/v4.10/sound/designs/timestamping.html
4.1 用于音频同步
time stamp最主要的作用还是用来同步:
如下:
媒体内容在播放时,最令人头痛的就是音视频不同步.从技术上来说,解决音视频同步问题的最佳方案就是时间戳:
首先选择一个参考始终(要求参考时钟上的时间是现行递增的);
生成数据流时一句参考时钟上的时间给每个数据块都打上时间戳(一般包括开始时间和结束时间)；
在播放时，读取数据块上的时间戳，同事参考当前参考时钟上的时间来安排播放
(如果数据块的开始时间小鱼当前参考时钟上的时间，则不急于播放该数据块，直到参考时钟达到数据块开始时间;如果数据块的开始时间小鱼当前参考时钟上的时间，则"尽快"播放这块数据"丢弃"，以使播放进度追上参考时钟)
可见，避免音视频不同步现象有两个关键---一是在生成数据流时要打上正确的时间戳。如果数据块上打的时间戳本身就有问题，那么播放时在怎么调整也于事无补

4.2 用于音频中的几个time
--------------------------------------------------------------> time
  ^               ^              ^                ^           ^
  |               |              |                |           |
 analog         link            dma              app       FullBuffer
 time           time           time              time        time
  |               |              |                |           |
  |< codec delay >|<--hw delay-->|<queued samples>|<---avail->|
  |<----------------- delay---------------------->|           |
                                 |<----ring buffer length---->|


#=======================================================================
/proc/asound详细介绍
https://blog.csdn.net/mynameislinduan/article/details/103045234

#=======================================================================
1. 基本信息
ALSA使用/proc/asound目录下的文件保存设备信息并且实现一些控制目的。
这些文件是什么？
由ALSA本身提供的最基本的文件：
/procasound/cardX(这里X是声卡的编号,从0到7)
对于系统中已经是别的每个声卡都存在对应的cardX目录.关于这个目录内容的信息请看下面.
/proc/asound/cards(只读) : 已注册的声卡的列表
/proc/asou/dev : 存放特殊的设备文件,用于针对声音操作进行变成.如果系统使用devfs,就会有这个目录.如果系统没有使用devfs(从2006-06起,大多数都没有使用),就根本不会有这个文件或者仅仅是指向/dev/snd的符号连接
/proc/asound/devices(只读) : 已注册的ALSA设备的列表(主设备号未116)
/proc/asound/hwdep(只读) : hwdep(硬件相关)控制列表.并不会在所有的系统中出现
/proc/asound/mediainfo(只读) : 内存使用信息.该proc文件仅当使用内存调试或所有选项构建ALSA驱动时才会有,该文件显示了单钱在内核空间分配的内存.
/proc/asound/modules(只读) : 已注册声卡驱动的列表,并不是所有为ALSA所加载的内核模块,而是硬件驱动的列表.一行对应一个正在使用的声卡
/proc/asound/oss : 包含关于OSS模拟的信息的目录.关于该目录内容的信息请看下面
/proc/asound/pcm(只读) : 已分配的pcm流的列表:可能并不意味着是激活的流的列表,它是设备的一个列表.这对于断定hw:0,0风格的设备名称非常有用,设备名称往往是命令如aplay所需要的
/proc/asound/seq : 包含关于音序器的信息。关于该目录内容的信息请看下面
/proc/asound/timers(只读) : 类似于/proc/asound/pcm,它是一个ALSA一直的计时器的列表,并且(好像)描述了单钱哪个是实际正在实际使用
/proc/asound/version(只读) : ALSA子系统模块(后内核)构建的版本和日期
请注意:标明只读的设备仅仅用来从内核中提取信息.其他的文件是可读可写的,可以用来向ALSA发送命令

#=======================================================================


#=======================================================================




