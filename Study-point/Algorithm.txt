#====================================================================
1.时间复杂度:(指的是程序执行的次数)
推导大O阶方法
(1).用常数1取代运行时间中的所有加法常数
(2).在修改后的运行次数函数中,只保留最高阶项
(3).如果最高阶项存在且不是1,则去除与这个项相乘的常数+
得到的结果就是大O阶

#====================================================================
2.执行时间恒定的算法,我们称之为具有O(1)的时间复杂度
  线性阶:O(N)
  对数阶:O(logn)
  平方阶:O(n^2)
#====================================================================
3.常见的时间复杂度
执行次数函数     阶  
12             O(1)
2n+3           O(n)
3n^2+2n+1      O(n^2)
5log2n+2O      O(logn)
2n+3nlog2n+19  O(nlogn) 
6n^3+2n^2+4    O(n^3)
2^n            O(2^n)

#====================================================================
4.常用的时间复杂所消耗的时间从小到大依次是:
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

#====================================================================
5.空间复杂度
算法的空间复杂度通过计算算法所需的存储空间实现,算法空间复杂度的计算公式记作:S(n)=O(f(n)),其中,n为问题的规模,f(n)为语句关于n所占存储空间的函数

#====================================================================
6.中缀表达式即最原始的计算公式
https://blog.csdn.net/lcl497049972/article/details/83061274
https://blog.csdn.net/c123_sensing/article/details/81904426
将中缀表达式9+(3-1)*3+10/2”转化为后缀表达式“9 3 1-3*+ 10 2/+”
规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出找并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。

(1)将中缀表达式转化为后缀表达式（栈用来进出运算的符号） 入栈符号优先级高于栈顶符号优先级则入栈,反之出栈到优先级比下一个元素高的元素也就是优先级相等的也出栈
(2)将后缀表达式进行运算得出结果（栈用来进出运算的数字） 入栈元素是数字如果遇到符号则将栈顶的两个元素出栈与符号进行运算
#====================================================================
7.冒泡排序
冒泡排序一种交换排序,它的基本思想是:两两比较相邻记录的关键字,如果反序则交换,直到没有反序的记录为止
时间复杂度:O(n^2)

#====================================================================
8.选择排序
简单选择排序法就是通过n-i次关键字间的比较,从n-i+1个记录中选出关键字最小的记录,并和第i(1<<i<<n)个记录交换
时间复杂度:O(n^2),尽管与冒泡排序同为O(n^2),但简单选择排序的性能上还要略优于冒泡排序

#====================================================================
9.插入排序
插入排序的基本操作是将一个记录插入到已经排好序的有序表中,从而得到一个新的,记录数增1的有序表
就是分成一个有序数组,和一个无序数组,遍历无序数组插入到有序数组中
时间复杂度:O(n^2),直接插入排序法比冒泡和选择排序的性能更好一些

#====================================================================
10.希尔排序
希尔排序将需要排列的序列划分为若干个较小的序列,对这些序列进行插入排序,通过这样的操作可使需要排序的数列基本有序,最后在使用依次插入排序
在希尔排序中首先要解决的是怎样划分序列,对于子序列的构成不是简单地分段,而是采取将相隔某个增量的数据组成一个序列.一般选择增量的规则是:取上一个增量的一般作为此次序列划分的增量
时间复杂度:O(n^3/2)希尔排序并不是一种稳定的算法

#====================================================================
11.堆排序
堆是具有下列性质的完全二叉树:每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆;或者每个节点的值都小于或等于其左右孩子节点的值,称为小顶堆
堆排序分为两个步骤:
(1)创建堆
(2)排序
时间复杂度:O(nlogn).由于堆排序对原始记录的排序状态并不敏感,因此它无论是最好,最坏和平均时间复杂度均为O(nlogn);不过由于记录的比较与交换是跳跃式进行的,因此堆排序也是一种不稳定的的排序方法
#====================================================================
12.归并排序
归并排序就是利用归并的思想实现的排序方法,它的原理是假设初始化序列含有n个记录,则可以看成是n个有序的子序列,每个子序列的长度为1,然后两两归并,得到[n/2]([x]表示不小于x的最小整数)个长度为2或1的有序子序列;在两两归并,如此重复,直到得到一个长度为n的有序序列为止,这中排序方法称为2路归并排序
时间复杂度:O(nlogn),这是归并排序中最好,最坏,平均的时间性能
空间复杂度:O(n) 归并是一种比较占用内存,但效率高且稳定的算法

#====================================================================
13.快速排序
快速排序的基本思想是:通过一趟排序将待排记录分割成独立的两部分,其中一部分记录的关键字均比另一部分记录的关键字小,则可分别对这两部分记录继续进行排序,以达到整个序列有序的目的
时间复杂度:O(nlogn)

#====================================================================
14.基数排序
基数排序的基本思想:先找出数组中的最大值,确定最大值位数(决定循环次数),LSD循环内,先求出基数大小,遍历数组将数组中元素放入到链表的对应位置中,遍历链表将链表中的数据按顺序放回到数组中,遍历链表删除链表中的元素

#====================================================================
------------------------------------------------------------------------------
|排序方法  | 平均情况          | 最好情况   | 最坏情况   | 辅助空间       | 稳定性   |
------------------------------------------------------------------------------
|冒泡排序  | O(n^2)           | O(n)     | O(n^2)    | O(1)          | 稳定    |
------------------------------------------------------------------------------
|选择排序  | O(n^2)           | O(n^2)   | O(n^2)    | O(1)          | 稳定    |
------------------------------------------------------------------------------
|插入排序  | O(n^2)           | O(n)     | O(n^2)    | O(1)          | 稳定    |
------------------------------------------------------------------------------
|希尔排序  | O(nlogn)~O(n^2)  | O(n^13)  | O(n^2)    | O(1)          | 不稳定  |
------------------------------------------------------------------------------
|堆排序    | O(nlogn)         | O(nlogn) | O(nlogn)  | O(1)          | 不稳定  |
------------------------------------------------------------------------------
|归并排序  | O(nlogn)         | O(nlogn) | O(nlogn)  | O(n)          | 稳定    |
------------------------------------------------------------------------------
|快速排序  | O(nlogn)         | O(nlogn) | O(n^2)    | O(logn)~O(n)  | 不稳定   |
------------------------------------------------------------------------------

#====================================================================
15 KMP算法
https://blog.csdn.net/f1033774377/article/details/82556438

#====================================================================
16 双栈转队列
一个栈作为输入,另一个栈作为输出,添加则向输入栈中添加,取出如果输出栈为空则将输入栈中元素全部导入到输出栈中然后取出
#====================================================================
17 双队列转栈
push元素时如果queue1有元素则将元素插入进queue2然后再将队列1的元素全部转移到队列2,再次插入两个队列反过,取出元素时直接获取队列顶元素
#====================================================================
18 菜鸟算法图像理解图
https://www.runoob.com/w3cnote/radix-sort.html
#====================================================================