C++高级编程
第一章
#====================================================================
1. C++17允许方便地使用嵌套的名称空间,即将一个名称空间放在另一个人名称空间中.
eg: namespace MyLibraries::Networking::FTP {
    /** */
    }
可以使用名称空间别名,为另一个人名称空间指定一个更简短的新名称
eg: namespace MyFTP = MyLibraries::Networking::FTP;

#====================================================================
2. 枚举
2.1 枚举使用时相当于一种类型,直接声明变量赋值即可
eg: enum Day {one, two, three} d2;
    Day d1 = one;
    d2 = two; //d2相当于声明一个枚举变量
2.2 不能对枚举变量执行算数运算或将其作为整数对待,编译器会给出警告或错误信息
eg: Day d1;
    d1 = 0; //error
2.3 强类型枚举
eg: enum class Day{one, two, three, four};
    Day d1 = Day::one; //使用时一定要加上Day::作用域
2.4 默认情况下,枚举值的基本类型是整型,但可采用一下方式加以改变
enum class Day : unsined long
{one, two ,three,four};
2.5 枚举类型转换成int类型一定要使用强制类型转换static_cast<int>

#====================================================================
3. C++17-if语句的初始化器
   if(<initializer>; <conditional_expression>) {<body>}
   <initializer>中引入的任何变量只在<conditional_expression>和<body>中可用.此类变量在if语句以外不可用
eg: if(Employee employee = GetEmployee(); employee.salary > 1000) {...}

#====================================================================
4. C++17-switch
   一旦找到与switch条件匹配的case的表达式,就执行其后的所有语句,知道遇到break语句为止.即使遇到另一个case表达式,执行也会继续,这称为fallthrough
   与if语句一样,C++17支持在switch语句中使用初始化器,switch(<initializer>; <expression>) {<body>}
   <initializer>中引入的任何变量只在<expression>和<body>中可用.此类变量在switch语句以外不可用

#====================================================================
5. 获取当前函数名称
每个函数都有一个预定义的局部变量_func_,其中包含当前函数的名称.
5.1 是用于日志的记录
eg: const char* hello() {return __func__;} //返回hello.

5.2 也可作为初始化参数传递如:
eg: struct TestStruct {
    TestStruct (): name(__func__){}  //返回TestStruct结构体类型。
    const char* name; 
    };

#====================================================================
6. 指针
6.1 指针并非总是指向堆内存,可声明一个指向堆栈中变量甚至指向其他指针的指针,为让指针指向某个变量,需要使用"取址"运算符&

#====================================================================
7. make_unique()在C++14中引入
eg: auto anEmployee = make_unique<Employee[]>(10);
7.1 从C++17
    shared_ptr<Employee[]> employee(new Employee[10]);

    C++11:
    std::shared_ptr<int> sp3(new int[10](), std::default_delete<int[]>());

#====================================================================
8. 使用auto会去除引用和const限定符
eg: const std::string message = "Test";
    const std::string& foo() {
        return message;
    }
    auto f1 = foo();
    因为auto去除了引用和const限定符,且f1是string类型,所以建立一个副本,如果希望f1是一个const引用,就可以明确将它建立为一个引用,并标记为const,如下所示
    const auto& f2 = foo();
8.1 关键字decltype把表达式作为实参,计算出该表达式的类型
    int x = 123;
    decltype(x) y = 456;
    auto与decltype的区别在于,decltype未去除引用和const限定符,在来分析返回const string引用的foo()函数,使用decltype定义f2,导致f2的类型为const string&,从而不生成副本
    decltype(foo()) f2 = foo(); 

#====================================================================
9. 直接列表初始化与复制列表初始化
复制列表初始化: T obj = {arg1,arg2,...};
直接列表初始化: T obj {arg1,arg2,...};
9.1 对于复制列表初始化器,放在大括号中的初始化器的所有元素都必须使用相同的类型
eg: auto b = {11, 22.33}  //Compilation error
9.2 在C++17中,与auto类型推断相结合,直接列表初始化与复制列表初始化存在重要区别
eg: auto a = {11};   //initializer_list<int>
    auto b = {11, 22};   //initializer_list<int>

    auto c {11}  //int
    auto d {11, 22}  //error, too many elements
 
#====================================================================
第二章
#====================================================================
10. 字符串字面量
    "hello"是一个字符串字面量,因为这个字符串以值的形式写出,而不是一个变量.与字符串字面量关联的真正内存位于内存的只读部分.也就是说,即使一个程序使用了500次"hello"字符串字面量,编译器也只在内存中创建一个hello实例.这种技术称为字面量池.C++标准真是指出:字符串字面量的类型为"n个const char的数组"
eg: char * ptr = "hello";
    ptr[1] = 'a'; //error是不安全的因为编译器为了兼容老版本所以不需要使用const char* ptr = "hello" 根据编译器不同ptr[1] = 'a'产生的结果也不相同

    char ptr[] = "hello";
    aar[i] = 'a';    //不会报错是正确的
10.1 原始字符串字面量
    10.1.1 原始字符串字面量是可横跨多行代码的字符串字面量,不需要转义嵌入的双引号,像\t和\n这种转义序列不按照转义序列的方式处理,而是按照普通文本的方式处理
           对于普通字符串,必须转义双引号,如下所示
           const char* str = "Hello \"World\"!";
           对于原始字符串字面量,就不需要了转义引号了.原始字符串字面量以R"(开头,以)"结尾
           const char* str = R"(Hello "World"!)"
    10.1.2 如果需要一个包含多行的字符串,就需要在字符串中新行的开始位置嵌入\n转义序列
           const char* str = "Line 1\nLine 2";
           而使用原始字符串字面量,不使用\n转义序列来开始一个新行,只需要在源代码中按下Enter键以开始一个真正的新行
           const char* str = R"(Line 1
           Line 2)"
    10.1.3 原始字符串字面中不能含有括号,如果嵌入右括号,则需要使用扩展的原始字符串字面量语法R"d-char-sequence(r-char-sequence)d-char-sequence",r-char-sequence是原始字符串,d-char-sequence是可选的分隔符序列,分隔符序列最多能有16个字符.应选择未出现在原始字符串字面量中的序列作为分隔符序列
           //const char* str = R"(Embedded)" characters)"; //error
           //const char* str = R"-(Embedded)" characters)-" //right
#====================================================================
11. std::string类
    为达到兼容的目的,还可应用string类的c_str()方法获得一个表示C风格字符串的const字符串指针.
    还有一个data()方法,在C++14及更早的版本中,始终与c_str()一样返回const char*.从C++17开始,在非const字符上调用时,data()返回char*;
11.1 std::string字面量,源代码中的字符串字面量通常解释为const char*.使用用户定义的标准字面量s可以把字符串字面量解释为std::string例如
    auto string1 = "Hello World";  //string1 is a const char*
    auto string2 = "Hello World"s; //string2 is a std::string
11.2.1 高级数值转换,std名称空间包含很多辅助函数,以便完成数值和字符串之间的转换下面的函数可用于将数值转换为字符串.所有这些函数都负责内存分配,它们会创建一个新的string对象并返回
eg: string_to_string(int val);等很多重载函数
11.2.2 低级数值转换,C++17也提供了许多低级数值转换函数,这些都在<charconv>头文件中定义,这些函数不执行内存分配而使用由调用者分配的缓存区
eg: to_chars_result to_chars(char* first, char* last, IntegerT value, int base = 10;)
11.3 std::string_view
11.3.1 C++17中引入std::string_view std::basic_string_view类模板的实例化,在<string_view>头文件中定义.string_view基本上就是const string&的简单替代品,但不会产生开销.它从不复制字符串,string_view支持于std::string类似的接口.一个例外是缺少c_str(),data()是可用的.另外,string_view确实添加了remove_prefix(size_t)和remove_suffix(size_t)方法;前者将起始指针前移给定的偏移量来收缩字符,后者则将结尾指针倒退给定的偏移量来收缩字符.
eg:无法连接一个string和string_view.下面的代码将无法编译:
   string str = "Hello";
   string_view sv = " world";
   auto result = str + sv; //error
   为进行编译,必须将最后一行替代为:
   auto result = str + sv.data();
11.3.2 还有一个string_view构造函数,它接收任意原始缓冲区和长度.这可用于从字符串缓冲区(并非以NULL终止)构建string_view.如果确实有一个一NUL终止的字符串缓冲区,但你已经知道字符串长度,构造        函数不必在统计字符数目,这也是有用的.
11.3.3 无法从string_view隐式构建一个string.要么使用一个显式的string构造函数,要么使用string_view::data()成员,例如,假设有以下接收const string&的函数:
eg: void handleExtension(const string& extension) {/** */}
    不能采用如下方式调用该函数,string_view extractExtension(string_view filename);
    handleExtension(extractExtension("my file.ext"));
    下面连个可供使用的选项:
    handleExtension(extractExtension("my file.ext").data());
    handleExtension(string(extractExtension("my file.ext")));
注意: 在每当函数或方法需要将只读字符串作为一个参数时,可使用std::string_view替代const std::string&或const char*
13.3.4 可使用标准的用户定义的字面量sv,将字符串字面量解释为std::string_view 
eg: auto sv = "My string_view"sv;
#====================================================================
第三章 编码风格  (略)
#====================================================================
第四章 设计专业的C++程序 (略)
#====================================================================
第五章 面向对象设计 (略)
#====================================================================
第六章 设计可重用代码 (略)
#====================================================================
第七章 内存管理
#====================================================================
12  内存的分配和释放
12.1  new和malloc的区别
          (1) new,delete是重载操作符,malloc和free是函数
          (2)new相比malloc()的主要好处在于,new不仅分配内存,还构建对象,delete也相同,释放空间和析构对象两步
12.2 申请多维堆数组
          如果需要在运行时确定多维数组的维数,可以使用堆数组.正如动态分配的一维数组是通过指针方位一样,动态分配的多维数组也通过指针访问.唯一的区别在于,在二维数组中,需要使用指针的指针;在N维数组中,需要使用N级指针
eg : char** board = new char [i][j];   //BUG! Does not complie
        //正确的分配方式
        char** myArray = new char*[xDimension]; //Allocate first dimesion
        for(size_t i = 0; i < xDimension; ++i) {
            myArray[i] = new char[yDimension];
        }
        //对应delete[]
        for(size_t i = 0; i < xDimension; ++i) {
            delete[] myArray[i];
            myArray[i] = nullptr;
        }
        delete[] myArray;
        myArray = nullptr;

#====================================================================
13 智能指针
13.1 unique_ptr适用于存储动态分配的C风格数组,但即使可使用unique_ptr存储动态分配的C风格数组,也建议改变标准库容器,例如std::array和std::vector等
     可以自定义deleter
13.2 shared_ptr从C++17开始,就像unique_ptr一样,shared_ptr可用于存储动态分配的旧式C风格数组的指针,这是C++17之前无法实现的
13.2.1 可用于强制转换shared_ptr的函数是const_pointer_cast(),dynamic_poiner_cast()和static_pointer_cast().C++17又添加了reinterpret_poiner_cast().它们的行为和工作方式类         似于非智能指针转换函数.
13.2.2 双重删除很容易出现,考虑前面引入的Simple类,这个类只是打印出创建或销毁一个对象的消息.如果要创建两个标准的shared_ptr,并使它们都指向同一个Simple对象,如下面的代码所示,在销毁时,两个智能指针将尝试删除同一个对象:
eg: void doubleDelete() {
        Simple* mySimple = new Simple();
        shared_ptr<Simple> smartPtr1(mySimple);
        shared_ptr<Simple> smartPtr2(mySimple);
    }
    会俩次释放空间和调用两次析构函数造成程序崩溃
13.3 移动语句.shared_ptr,unique_ptr,weak_ptr都支持移动语义,使它们非常高效
eg: unique_ptr<Simple> create() {
        auto ptr = make_unique<Simple>();
        //Do something with ptr...
        return ptr;
    }
    int main() {
        unique_ptr<Simple> mySmartPtr1 = create();
        auto mySmartPtr2 = create();
        return 0;
    }

#====================================================================
14 常见的内存陷阱
   (1) 空间分配不足的字符串
   (2) 访问内存越界
   (3) 内存泄露
   (4) 双重删除和无效指针
注: 在linux中通过Valgrind查找并修复内存泄露,Valgrind是一个免费的开源的linux工具,这个工具可在代码中精确地定位分配泄露对象的那行代码

#====================================================================
第八章 熟悉类和对象
#====================================================================
15 类的构造
15.1 显式的默认构造,如果类需要一些接收参数的显式构造函数,还需要一个什么都不做的默认构造函数,就必须显式的编写空的默认构造函数
eg : class SpreadsheetCee() {
     public:
         SpreadsheetCee() = default;
     }
     显式删除构造函数,例如,可定义一个只有静态方法的类,这个类没有任何构造函数,也不想让编译器生成默认构造函数.在此情况下可以显式删除默认构造函数
eg : class MyClass() {
     public: 
         MyClass() = delete;
     }
15.2 复制构造函数(拷贝构造函数)
     默认函数原型: MyClass(const MyClass& src);默认为浅拷贝,如果是深拷贝则需要自己重写
     将复制构造函数定义为显式默认或显式删除
     MyClass(const MyClass& src) = default;
     MyClass(const MyClass& src) = delete; //通过删除复制构造函数,将不在复制对象.这可用于禁止按值传递对象
15.2.1 移动构造
       默认函数原型: MyClass(MyClass&& src)
       注: 移动构造函数的形参也不能是 const。此外，作为移动构造函数获取资源来源 的临时对象必须放置到安全状态，使得其析构函数可以正常运行而不会导致出错。
15.3 赋值操作符
     默认函数原型: MyClass& operator=(const MyClass& src);
     赋值运算符不应该组织自赋值.当类具有动态分配的内存或其他资源时,必须将自赋值考虑在内
eg : MyClass& operator=(const MyClass& src) {
         if(this == &src) {
            return *this;
         }
     }   
15.3.1 默认函数原型: MyClass& operator=(MyClass&& src)
       注: 移动赋值的形参不能是 const，这是因为它需要通过修改对象 "移动" 资源

#====================================================================
第九章 精通类与对象
#====================================================================
16 友元
   C++允许某个类将其他类,其他类成员函数或非成员函数声明为友元(friend),友元可以访问类的protected,private数据成员和方法
#====================================================================
17 使用移动语义处理移动
   对象移动语义需要实现移动构造函数和移动赋值运算符.如果原对象是操作结束后被销毁的临时对象,编译器就会使用这两个方法
17.1 右值引用
eg: (1)void handleMessage(std::string& message){}
    (2)void handleMessage(std::string&& message){}
    std::string a = "Hello";
    std::string b = "World";
    handleMessage(a); //call (1)
    handleMessage(a + b); //call (2)
    handleMessage("Hello"); //call (2)
    如果删除接收左值引用的handlerMessage()函数,使用有名称的变量调用handleMessage()函数(例如handleMessage(b)),会导致编译错误,可以使用std::move()将左值转换为右值,强迫编译器调用handleMessage()函数的右值引用版本
    handleMessage(std::move(b)); //call (2)
    有名称的变量是左值,因此,在handleMessage()函数中,右值引用参数message本身是一个左值,原因是它具有名称,如果希望将这个左值引用参数,作为右值传递给另一个函数,则需要使用std::move(),将左值转换为右值.
    eg: void helper(std::string&& message) {}
        如果按照如下方式调用,则无法编译:
    void handleMessage(std::string&& message) {
        helper(message);
    }
    helper()函数需要右值引用,而handleMessage()函数传递message,message具有名称,因此是左值,导致编译错误.正确的方式是使用std::move():
    void handleMessage(std::string&& message) {
        helper(std::move(message));
    }
17.2 实现移动语义
     移动语义是通过右值引用实现的.为了对类增加移动语义,需要实现移动构造函数和移动赋值运算符.移动构造函数和移动赋值运算符应使用noexcept限定符标记,这告诉编译器,他们不会抛出任何异常.
     示例代码参考P164页,移动构造函数和移动赋值运算符都将mCells的内存所有权从源对象移动到新对象,这两个方法将元对象的mCells指针设置为空指针,以防源对象的析构函数释放这块内存,因为新对象现在拥有了这块内存.很明显,只有你知道将销毁源对象时,移动语义才有用
17.2.1 使用移动语义实现交换函数
       考虑交换两个对象的swap()函数,这是另一个使用移动语义提高性能的示例.下面swapCopy()实现没有使用移动语义:
eg: void swapCopy(T& a, T& b) {
        T temp(a); //一次拷贝构造
        a = b;     //一次赋值操作符
        b = temp;  //一次赋值操作符
    }
    使用移动语义,swap()函数可避免所有复制
    void swapMove(T& a, T& b) {
        T temp(std::move(a));  //将a对象通过std::move转换成右值引用.调用T类型的移动构造
        a = std::move(b);      //将b对象通过std::move转换成右值引用.调用T类型的移动赋值操作符
        b = std::move(temp);   //将temp对象通过std::move转换成右值引用.调用T类型的移动赋值操作符
    }
    /**移动构造函数和移动赋值与拷贝构造函数和赋值构造函数的比较 
     * https://www.cnblogs.com/wuyepeng/p/9787993.html
    */
    这正式标准库的std::swap()的实现方式
17.3 零规则
     "零规则"指出,在设计类时,应当使其不需上述5个特殊成员函数.如何做到这一点?基本上,应当避免拥有任何旧式的,动态分配的内存.而改用现代结构,如标准库容器.
    
#====================================================================
第十一章 理解灵活而奇特的C++
#====================================================================
18 引用
18.1 引用变量.不能创建对未命名值(例如一个整数字面量)的引用,除非这个引用是一个const值,在下例中,unnamedRef1将无法编译,因为这是一个针对常量非const引用.这条语句意味着可改变常量5的值,而这样做没有意义.由于unnamedRef2是一个const引用,因此可以运行,不能编写"unnamedRef2 = 7"
eg: int& unnamedRef1 = 5;         //Does not complie
    const int& unnamedRed2 = 5;   //Works as expected
    临时对象同样如此.不能具有临时对象的非const引用,但可具有const引用.例如,假设以下函数返回一个std::string对象
    std::string getString() {return "Hello";}
    std::string& string = getString();         //Does not complie
    const std::string& string = getString();   //Works as expected
18.1.1 修改引用. 如果将一个引用赋值给另一个引用,会发生什么?
       结果:在初始化引用之后无法改变引用的所指的变量,而只能改变该变量的值
18.1.2 无法声明引用的引用或者指向引用的指针.例如,不允许使用int&& 或into&*
18.2 类的数据成员可以是引用.如果不指向其他变量,引用就无法存在.因此,必须在构造函数初始化器中初始化引用数据成员,而不是在构造函数体内
18.3 引用参数,将指针转换为引用
     某个函数或方法需要以一个引用作为参数,而你拥有一个指向呗传递值的指针,这是一种常见的困境.在此情况下,可对指针解除引用,将指针"转换"为引用.这一行为会给出指针所指的值,随后编译器用这个值初始化引用参数,例如,可以这样调用swap();
eg: int x = 5, y = 6;                                                                                                                              
    int* xp = &x, *yp = &y;
    swap(*xp, *yp);
18.4 将引用作为返回值
　　　如果变量的作用域局限于函数或方法(例如堆栈中自动分配的变量,在函数结束时会被销毁),绝不能返回这个变量的引用,如果从函数返回的类型支持移动语句(智能指针),按值返回就几乎与返回引用一样高效. 返回引用的另一个原因是希望将返回值直接赋为左值.一些重载的运算符通常会返回引用
18.5 使用引用还是指针,要有限使用引用,也就是说,只有在无法使用引用的情况下,才能使用指针

#====================================================================
19 static关键字
19.1 静态链接,在解释用于链接的static关键字之前,首先要理解C++中链接的概念.C++的每个源文件都是单独编译的,编译得到的目标文件会彼此链接.C++源文件中的每个名称,包括函数和全局变量,都又一个内部或外部的链接.外部链接意味着这个名称在其他源文件中也有效,内部链接(也称为静态链接)意味着在其他源文件中无效.默认情况下,函数和全局变量都有拥有外部链接,然后可在声明的前面使用关键字static指定内部(或静态)链接.也就是说添加static关键字就变成了内部链接外部无法使用.示例P233页
注:要获取内部链接,建议使用匿名名称空间,而不要使用static关键字

#====================================================================
20 extern关键字
   extern关键字好像是static的反义词,将它后面的名称指定为外部链接.某些情况下使用这种方法,例如,const和typdef在默认情况下是内部链接,可使用extern使其变为外部链接

#====================================================================
21 类型和类型转换
21.1 类型别名为现有的类型声明提供了新名称.可将类型别名视作为现有类型声明引入同义词的语法(不创建新类型).下面为int*类型声明指定新名称IntPtr;
eg:  using IntPtr = int*;
     IntPtr ptr = new intp[10];
21.2 函数指针的类型别名:类型别名允许将一个类型名指定给具有指定特征的一系列函数
     using MatchFunction = bool (*)(int,int);
注:如果不使用这些旧式的函数指针,还可以使用std::function
21.3 于typedef比较形式更简单,更易于理解
注:始终优先使用类型别名而非typedef

#====================================================================
22 类型转换
22.1 从C++17开始,<unility>中定义了一个辅助方法std::as_const(),该方法返回引用参数的const引用版本.as_const(obj)基本上等同于const_cast<const T&>(obj),其中T类型为obj.
eg: std::string str = "C++";
    const std::string& constStr = std::as_const(str);
    将as_const()与auto一起使用时要保持警惕.,auto将去除引用和const限定符!因此,下面的result变量具有类型std::string而非const std::string&
    auto result = std::as_const(str);  //result type is std::string
    const auto& result = std::as_const(str);  //result type is const std::string&

22.2 static_cast()在继承体系层次结构中执行向下转换中.这种类型转换可以用于指针和引用,而不适用于对象本身
22.3 reinterpret_cast() 
     (1)将某种类型的指针转换为其他无关类型的指针
     (2)将某种类型的引用转换为其他无关类型的引用
     (3)将某个函数指针转换为其他函数指针

#====================================================================
第十二章 利用模板编写泛型代码 (略)没有看,有需求在深度学习 
#====================================================================
第十三章 I/O揭秘
#====================================================================
23 流的含义
   把一些变量丢到流中,这写变量就会被写到用户屏幕上,即控制台.更一般地,所有的流都可以看成数据滑槽.流的方向不同,惯量的来源和目的地也不同
23.1 缓冲流和非缓冲的流的区别在于,前者不是立即将数据发送到目的地,而是缓冲输入的数据,然后以块方式发送;而非缓冲的流则立即将数据发送到目的地.缓冲的目的同城是提高性能,对于某些目的地(如文件)而      言,一次性写入较大的块时速度更快.
注:所有输入流都有一个关联的来源,所有输出流都有一个关联的目的地
23.2 当一个流处于正常的可用状态时,称这个流是"好的".调用流的good()方法可以判断这个流当前是否处于正常状态.
eg: if(count.good()) {
        cout<<"All good"<<endl;
    }
    通过good()方法可方便地获得流的基本验证信息,但不能提供流不可用的原因.还有一个bad()方法提供了稍多信息.如果bad()方法返回true,意味着发生了致命错误(相对于非致命错误,例如到达文件结尾).另一个方法fail()在最近一次操作失败时返回true,但没有说明下一次操作是否也会失败.例如,对输出流调用flush()后,可调用fail()确保流仍然可用
    cout.flush();
    if(cout.fail()) {
        cerr<<"Unable to flush to standard out"<<endl;
    }
    流具有可转换为bool类型的转换运算符.转换运算符与调用!fail()时返回的结果相同.因此,可将前面的代码重写为:
    cout.flush();
    if(!cout) {
        cerr<<"Unable to flush to standard out"<<endl;
    }
注:遇到文件结束标记时,good()和faild()都会返回false.
23.3 输出操作算子
     流的意向独特特性是,放入数据滑槽的内容并非仅限于数据.C++流还能识别操作算子,操作算子是能修改流行为的对象,而不是(或额外提供)流能够操作的数据
eg: endl就是一个操作算子.endl操作算子封装了数据和行为.它要求流输出一个行结束序列
    其他操作算子,大部分定义在<ios>和<iomanip>标准头文件中,例子详见本书P279页

23.4 处理输入错误
     输入流提供了一些方法用于检测异常情形.大部分和输入流有关的错误条件都放生在无数据可读时.还可在输入流上调用good(),bad()和fail()方法,就像输出流那样.还有一个eof()方法,如果流到达尾部,就返回true.与输出流类似,遇到文件结束标记时,good()和faild()都会返回false.关系如下:good() == (!fail()&&!eof())
23.5 输入方法
     与输出流一样,输入流也提供了一些方法,他们可获得相比普通>>运算符更底层的访问功能
eg:  具体示例百度搜索/详见P282页
     get()方法允许从流中读入原始输入数据.get()的最简单版本返回流中的下一个字符,其他版本一次读入多个字符.get()常用语避免>>运算符的自动标识化
     unget()调用unget()会导致流回退一个位置,将读入的前一个字符放回流中.调用fail()方法可查看unget()是否成功
     putback()unget()一样,允许在输入流中反向移动一个字符.区别在于putback()方法将放回流中的字符接收为参数
     peek()通过peek()方法可预览调用get()后返回的下一个值
     getline()从输入六中获得一行数据是一种非常常见的需求
23.5.1 输入操作算子:如输出操作算子
23.6 字符串流详见P286
     相对于标准C++字符串,字符串流的主要优点是除了数据之外,这个对象还知道从哪里进行下一次读或写操作,这个位置也称为当前位置.与字符串相比,字符串流的另一个优势是支持操作算子和本地化,格式化功能更加强大
23.7 文件流
     文件本身非常符合流的抽象,因为读写文件时,除数据外,还涉及读写的位置.在C++中,std::ofstream和std::ifstream类提供了文件的输入输出功能,这两个类在<fstream>头文件中定义
     在处理文件系统时,错误情形的检测和处理非常重要.比如,当前处理的文件
     ios_base::app      //打开文件,在每一次写操作之前,移到文件末尾
     ios_base::ate      //打开文件,打开之后立即移到文件末尾
     ios_base::binary   //以二进制模式执行输入输出操作(相对于文本模式)
     ios_base::in       //打开文件,从开头开始读取
     ios_base::out      //打开文件,从头开始写入,覆盖已有的而数据
     ios_base::trunc    //打开文件,并删除(截断)任何已有数据
23.7.1 通过seek()和tell()在文件中转移
       seek()方法允许在输入流或输出流中移动到任意位置
       tell()方法查询流的当前位置
23.8 将流链接在一起
     任何输入流和输出流之间都可以建立链接,从而实现"访问时刷新"的行为.换句话说,当从输入流请求数据时,链接的输出流会自动刷新,这种行为可用于所有流.
     通过tie()方法完成流的链接.要将输出流链接至输入流,对输入流调用tie()方法,并传入输出流的地址,要接触链接,传入nullptr
23.9 双向IO fstream类

#====================================================================
第十四章 错误处理 (略)大概了解有需求在深入理解
#====================================================================
第十五章 运算符重载
#====================================================================
24 运算符重载的限制
   (1)不能添加新的运算符
   (2)有少数运算符不能重载
   (3)不能修改运算符的优先级和结合性
   (4)不能对内建类型重定义运算符
24.1 运算符重载的选择
     首先要决定运算符应该实现为类的方法还是全局函数(通常是类的友元).如何做出选择?你需要理解这两个选择之间的区别.当运算符是类方法时,运算符表达式的左侧必须是这个类的对象.当编写全局函数时,运算符表达式的左侧可以是不同类型的对象

#====================================================================
第十六站 C++标准库概述 (略)
#====================================================================
第十七章 理解容器于迭代器 (略)
#====================================================================
第十八章 掌握标准库算法 (略)
#====================================================================
第十九章 字符串的本地化与正则表达式 (略)
#====================================================================
第二十章 其他库工具
#====================================================================
25 文件系统支持库
   C++17引入了文件系统支持库,它们全部定义在<filesystem>头文件中,位于std::filesystem名称空间.它允许你编写可移植的用于文件系统的代码.使用它,可以区分是目录还是文件,迭代目录的内容,操作路径,检索文件信息(如大小,扩展名和创建时间等)详见本书P483页

#====================================================================
第二十一章 自定义和扩展标准库 (略)
#====================================================================
第二十二章 高级模板 (略)
#====================================================================
第二十三章 C++多线程编程
#====================================================================
26 线程创建的几种方式
   (1)通过函数指针创建线程
   (2)通过函数对象创建线程(重载等好操作符)
   (3)通过lambda创建线程
   (4)通过成员函数创建线程
26.1 线程本地存储
     通过关键字thread_local,可将任何变量标记为线程本地数据,即每个线程都有这个变量的独立副本,而且这个变量能在线程的整个生命周期中持续存在.对于每个线程,该变量正好初始化一次.
注:如果thread_local变量在函数作用域内声明,那么这个变量的行为和声明为静态变量是一致的

#====================================================================
27 条件变量
   (1)std::condition_variable智能等待unique_lock<mutex>上的条件变量;根据C++标准描述,这个条件变量可在特定平台上达到最高效率
   (2)std::condition_variable_any:可等待任何对象的条件变量,包括自定义的锁类型
27.1 std::condition_variable支持一下方法
     (1)notify_one(): 唤醒等待这个条件变量的线程之一
     (2)notify_all(): 唤醒等待这个条件变量的所有线程
     (3)wait(unique_lock<mutex>& lk): 调用wait()的线程应该已经获得lk上的锁.调用wait()的效果是以原子方式调用lk.lock()并阻塞线程,等待通知.当线程被另一个线程中的notify_one()或notify_all()调用接触阻塞时,也可能在给超时时间到达后接触阻塞
     (4)wait_for(unique_lock<mutex>& lk, const chrono::duration<Clock,Duration>& rel_time): 类似于此前的wait()方法,区别在于这个线程会被notify_one或notify_all()调用接触阻塞,也可能在给定超时时间到达后解除阻塞
     (5)wait_for(unique_lock<mutex>& lk, const chrono::time_point<Clock,Duration>& abs_time): 类似于此前的wait()方法,区别在于这个线程会被notify_one或notify_all()调用接触阻塞,也可能在系统时间超过给定的绝对时间时解除阻塞

#====================================================================
第二十四章 充分利用软件工程方法 (略)
#====================================================================
第二十五章 编写高效的C++程序
#====================================================================
28 语言层次的效率
   (1)通过引用传递
   (2)按引用返回
   (3)使用移动语句
   (5)避免创建临时对象
   (6)返回值优化
28.1 设计层次的效率
   (1)尽可能多的缓存
   (2)使用对象池

#====================================================================
第二十六章 熟练掌握测试技术 (略)
#===================================================================
第二十七章 熟练掌握调试技术 (略)
#===================================================================
第二十八章 使用设计技术和框架 (这里有一些不错的例子值得学习)
#===================================================================
第二十九章 应用设计模式 (略)
#===================================================================


