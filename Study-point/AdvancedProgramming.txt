C++高级编程
第一章
#====================================================================
1. C++17允许方便地使用嵌套的名称空间,即将一个名称空间放在另一个人名称空间中.
eg: namespace MyLibraries::Networking::FTP {
    /** */
}
可以使用名称空间别名,为另一个人名称空间指定一个更简短的新名称
eg: namespace MyFTP = MyLibraries::Networking::FTP;

#====================================================================
2. 枚举
2.1 枚举使用时相当于一种类型,直接声明变量赋值即可
eg: enum Day {one, two , three} d2;
    Day d1 = one;
    d2 = two; //d2相当于声明一个枚举变量
2.2 不能对枚举变量执行算数运算或将其作为整数对待,编译器会给出警告或错误信息
eg: Day d1;
    d1 = 0; //error
2.3 强类型枚举
eg: enum class Day{one, two, three, four};
    Day d1 = Day::one; //使用时一定要加上Day::作用域
2.4 默认情况下,枚举值的基本类型是整型,但可采用一下方式加以改变
enum class Day : unsined long
{one, two ,three,four};
2.5 枚举类型转换成int类型一定要使用强制类型转换static_cast<int>

#====================================================================
3. C++17-if语句的初始化器
   if(<initializer>; <conditional_expression>) {<body>}
   <initializer>中引入的任何变量只在<conditional_expression>和<body>中可用.此类变量在if语句以外不可用
eg: if(Employee employee = GetEmployee(); employee.salary > 1000) {...}

#====================================================================
4. C++17-switch
   一旦找到与switch条件匹配的case的表达式,就执行其后的所有语句,知道遇到break语句为止.即使遇到另一个case表达式,执行也会继续,这称为fallthrough
   与if语句一样,C++17支持在switch语句中使用初始化器,switch(<initializer>; <expression>) {<body>}
   <initializer>中引入的任何变量只在<expression>和<body>中可用.此类变量在switch语句以外不可用

#====================================================================
5. 获取当前函数名称
每个函数都有一个预定义的局部变量_func_,其中包含当前函数的名称.
5.1 是用于日志的记录
eg: const char* hello() {return __func__;} //返回hello.

5.2 也可作为初始化参数传递如:
eg: struct TestStruct {
    TestStruct (): name(__func__){}  //返回TestStruct结构体类型。
    const char* name; 
    };

#====================================================================
6. 指针
6.1 指针并非总是指向堆内存,可生命一个指向堆栈中变量甚至指向其他指针的指针,为让指针指向某个变量,需要使用"取址"运算符&

#====================================================================
7. make_unique()在C++14中引入
eg: auto anEmployee = make_unique<Employee[]>(10);
7.1 从C++17
    shared_ptr<Employee[]> employee(new Employee[10]);

    C++11:
    std::shared_ptr<int> sp3(new int[10](), std::default_delete<int[]>());

#====================================================================
8. 使用auto会去除引用和const限定符
eg: const std::string message = "Test";
    const std::string& foo() {
        return message;
    }
    auto f1 = foo();
    因为auto去除了引用和const限定符,且f1是string类型,所以建立一个副本,如果希望f1是一个const引用,就可以明确将它建立为一个引用,并标记为const,如下所示
    const auto& f2 = foo();
8.1 关键字decltype把表达式作为实参,计算出该表达式的类型
    int x = 123
    decltype(x) y = 456;
    auto与decltype的区别在于,decltype未去除引用和const限定符,在来分析返回const string引用的foo()函数,使用decltype定义f2,导致f2的类型为const string&,从而不生成副本
    decltype(foo()) f2 = foo(); 

#====================================================================
9. 直接列表初始化与复制列表初始化
复制列表初始化: T obj = {arg1,arg2,...};
直接列表初始化: T obj {arg1,arg2,...};
9.1 对于复制列表初始化器,放在大括号中的初始化器的所有元素都必须使用相同的类型
eg: auto b = {11, 22.33}  //Compilation error
9.2 在C++17中,与auto类型推断相结合,直接列表初始化与复制列表初始化存在重要区别
eg: auto a = {11};   //initializer_list<int>
    auto b = {11, 22};   //initializer_list<int>

    auto c {11}  //int
    auto d {11, 22}  //error, too many elements
 
#====================================================================
第二章
#====================================================================
10. 字符串字面量
    "hello"是一个字符串字面量,因为这个字符串以值的形式写出,而不是一个变量.与字符串字面量关联的真正内存位于内存的只读部分.也就是说,即使一个程序使用了500次"hello"字符串字面量,编译器也只在内存中穿件一个hello实例.这种技术称为字面量池.C++标准真是指出:字符串字面量的类型为"n个const char的数组"
eg: char * ptr = "hello";
    ptr[1] = 'a'; //error是不安全的因为编译器为了兼容老版本所以不需要使用const char* ptr = "hello" 根据编译器不同ptr[1] = 'a'产生的结果也不相同

    char ptr[] = "hello";
    aar[i] = 'a';    //不会报错是正确的
10.1 原始字符串字面量
    10.1.1 原始字符串字面量是可横跨多行代码的字符串字面量,不需要转义嵌入的双引号,像\t和\n这种转义序列不按照转义序列的方式处理,而是按照普通文本的方式处理
           对于普通字符串,必须转义双引号,如下所示
           const char* str = "Hello \"World\"!";
           对于原始字符串字面量,就不需要了转义引号了.原始字符串字面量以R"(开头,以)"结尾
           const char* str = R"(Hello "World"!)"
    10.1.2 如果需要一个包含多行的字符串,就需要在字符串中新行的开始位置嵌入\n转义序列
           const char* str = "Line 1\nLine 2";
           而使用原始字符串字面量,不使用\n转义序列来开始一个新行,只需要在源代码中按下Enter键以开始一个真正的新行
           const char* str = R"(Line 1
           Line 2)"
    10.1.3 原始字符串字面中不能含有括号,如果嵌入右括号,则需要使用扩展的原始字符串字面量语法R"d-char-sequence(r-char-sequence)d-char-sequence",r-char-sequence是原始字符串,d-char-sequence是可选的分隔符序列,分隔符序列最多能有16个字符.应选择未出现在原始字符串字面量中的序列作为分隔符序列
           //const char* str = R"(Embedded)" characters)"; //error
           //const char* str = R"-(Embedded)" characters)-" //right
#====================================================================
11. std::string类
    为达到兼容的目的,还可应用string类的c_str()方法获得一个表示C风格字符串的const字符串指针.
    还有一个data()方法,在C++14及更早的版本中,始终与c_str()一样返回const char*.从C++17开始,在非const字符上调用时,data()返回char*;
11.1 std::string字面量,源代码中的字符串字面量通常解释为const char*.使用用户定义的标准字面量s可以把字符串字面量解释为std::string例如
    auto string1 = "Hello World";  //string1 is a const char*
    auto string2 = "Hello World"s; //string2 is a std::string
11.2.1 高级数值转换,std名称空间包含很多辅助函数,以便完成数值和字符串之间的转换下面的函数可用于将数值转换为字符串.所有这些函数都负责内存分配,它们会创建一个新的string对象并返回
eg: string_to_string(int val);等很多重载函数
11.2.2 低级数值转换,C++17也提供了许多低级数值转换函数,这些都在<charconv>头文件中定义,这些函数不执行内存分配而使用由调用者分配的缓存区
eg: to_chars_result to_chars(char* first, char* last, IntegerT value, int base = 10;)


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================


#====================================================================

#====================================================================

#====================================================================

#====================================================================

#====================================================================


#====================================================================


#====================================================================


#====================================================================
