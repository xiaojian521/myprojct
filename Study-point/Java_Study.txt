Java Study
#====================================================================
1.编译java静态库，java共享库
https://blog.csdn.net/lin20044140410/article/details/55519026
静态连接库的特点是会在程序的编译链接阶段就完成函数和变量的地址解析工作，并使之成为可执行程序中不可分割的一部分。这种处理手段在某种程度上可以有效地实现代码的重复利用，使得编写程序不需要每次都从零开始。但是它的缺点也是明显的，即可执行程序的体积会随着静态链接库的增加而不断增大。如果系统中有多个可执行程序都用到了同一个静态库Ａ，按照静态链接的做法需要把Ａ分别打包到所有程序中，这显然是一种资源浪费。

动态链接库有２个特点：
动态链接库不需要在编译时就打包到可执行程序中，而是等到后者在运行时再实现动态的加载和　重定位。
动态链接库在被加载到内存之后，操作系统需要为他执行动态连接操作，这里也可以称为“动态链接”，前面编译阶段的链接叫“静态链接”。静态链接中也会有重定位Ｒｅｌｏｃａｔｉｏｎ，只是跟动态链接中的重定位有差异。只要涉及多个文件之间的链接，通常都需要重定位，只是静态链接发生在编译阶段，而动态链接发生在运行阶段。
动态链接库的核心优势就是代码共享，不单是进程内的代码共享，还包括进程间的代码共享。

#====================================================================
2.使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。

#====================================================================
3.Map<String, ?>只能是只读模式，不能增加，因为增加的时候不知道该写入什么类型的值；Map<String, Object>可以读和写，只要是所有Object类的子类都可以。


#====================================================================
4.JAVA中STATIC{}语句块详解
https://www.cnblogs.com/caolaoshi/p/7824748.html
static{}(即static块)，会在类被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法，下面我们详细的讨论一下该语句块的特性及应用。

类加载:Java命令的作用是启动虚拟机，虚拟机通过输入流，从磁盘上将字节码文件(.class文件)中的内容读入虚拟机，并保存起来的过程就是类加载。

 类加载特性 :
      *在虚拟机的生命周期中一个类只被加载一次。
      *类加载的原则：延迟加载，能少加载就少加载，因为虚拟机的空间是有限的。
      *类加载的时机：
      1）第一次创建对象要加载类.
      2）调用静态方法时要加载类,访问静态属性时会加载类。
      3）加载子类时必定会先加载父类。
      4）创建对象引用不加载类.
      5) 子类调用父类的静态方法时
          (1)当子类没有覆盖父类的静态方法时，只加载父类，不加载子类
          (2)当子类有覆盖父类的静态方法时，既加载父类，又加载子类
      6）访问静态常量，如果编译器可以计算出常量的值，则不会加载类,例如:public static final int a =123;否则会加载类,例如:public static final int a = math.PI。

#====================================================================
5.java库生成的是jar包，对应两种类型的库，一个是通过 那么，BUILD_JAVA_LIBRARY 与BUILD_STATIC_JAVA_LIBRARY的区别是什么？

BUILD_JAVA_LIBRARY编译出来的jar包，里面是DEX格式的文件，如果用户想用这个jar包放到Eclipse来做Android APP的开发，Eclipse是不认识这种格式的文件的，通常会报错：Conversion to Dalvik format failed with error 1；
而BUILD_STATIC_JAVA_LIBRARY编译出来的jar包，里面每个java文件对应的class文件都单独存在，顾名思义，每个java文件里面用到的变量都被静态编译到了class内部，这种格式的jar包可以在Eclipse/AndroidStudio里面导入并正常使用，但是可能存在一定的兼容性隐患。 二者的区别在于静态JAVA库是由.class文件打包而成JAR包，它在任何一个JAVA虚拟机上都可以运行；而共享JAVA库则是在静态库的基础上进一步打包成的.dex文件，众所周知，dex是在android系统上所使用的文件格式。

1. 动态jar包	
(1)生成后可以共享代码	
(2)生成的是class.dex文件,只能运行在Android平台中	
注 : 	Android虚拟机Dalvik支持的字节码文件格式Google在新发布的Android平台上使用了自己的Dalvik虚拟机
	来定义， 这种虚拟机执行的并非Java字节码， 而是另一种字节码： dex格式的字节码
	Class文件------Java编译后的目标文件
	不像J2se，java编译成class就可以直接运行，android平台上class文件不能直接在android上运行。 由于Google
	使用了自己的Dalvik来运行应用， 所以这里的class也肯定不能在AndroidDalvik的java环境中运行， android
	的class文件实际上只是编译过程中的中间目标文件，需要链接成dex文件后才能在dalvik上运行
	
2.静态jar包	
(1)可以打包进apk,也可以运行在Android平台中,某些情况可能出现问题	
(2)生成的是.class文件,可以运行在java虚拟机中

#====================================================================
6.Synchronized 详解
https://www.cnblogs.com/xyabk/p/10901291.html
1.多线程调用同一个对象的方法中同步代码块(synchronized (this)),线程是同步的
2.多线程调用同一个对象中使用synchronized修饰普通方法的情况,锁对象默认为this,当前实例.eg: public synchronized void method(){}
3.synchronized用在静态方法上,默认的锁就是当前所在的Class类,多线程访问多个对象上的静态方法时,都是同步的.eg:public static synchronized void method(){}
4.synchronized指定锁对象为Class对象(synchronized 类名.class),多线程访问多个对象上同步代码块时都是同步的

核心思想:
1.一把锁只能同时被一个线程获取，没有拿到锁的线程只能等待
2.每个实例都对应有自己的一把锁（this）,不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
3.synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

synchronized的性质:
1.可重入性
概念：指同一个线程外层函数获取到锁之后，内层函数可以直接使用该锁
好处：避免死锁，提升封装性（如果不可重入，假设method1拿到锁之后，在method1中又调用了method2,如果method2没办法使用method1拿到的锁，那method2将一直等待，但是method1由于未执行完毕，又无法释放锁，就导致了死锁，可重入正好避免这这种情况)

2.不可中断性
概念：如果这个锁被B线程获取，如果A线程想要获取这把锁，只能选择等待或者阻塞，直到B线程释放这把锁，如果B线程一直不释放这把锁，那么A线程将一直等待
相比之下，未来的Lock类，可以拥有中断的能力（如果一个线程等待锁的时间太长了，有权利中断当前已经获取锁的线程的执行，也可以退出等待）

3.synchronized的缺陷
效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时

不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件（某个对象），相对而言，读写锁更加灵活

无法知道是否成功获得锁，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....

#====================================================================
7.Java四种引用,强引用,弱引用,软引用,虚引用
https://www.cnblogs.com/fengbs/p/7019687.html
(1).强引用
Object o=new Object();   //  强引用
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：
o=null;     // 帮助垃圾收集器回收此对象
显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。
在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。
但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收

(2)软引用
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
String str=new String("abc");                                     // 强引用 
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

(3)弱引用
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象.
String str=new String("abc");    
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
下面的代码会让str再次变为一个强引用：
String  abc = abcWeakRef.get();
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。
这个引用不会在对象的垃圾回收判断中产生任何附加的影响

(4)虚引用
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

#====================================================================
8.当Android.mk引入jar包时报错
Exception in thread "main" java.time.DateTimeException: Invalid value for MonthOfYear (valid values 1 - 12): 0
因为jdk9版本问题,补丁可以参考
https://bugs.openjdk.java.net/browse/JDK-8184940

#====================================================================
9.JavaVM对象和JNIEvn对象
https://www.cnblogs.com/fnlingnzb-learner/p/7366025.html
https://blog.csdn.net/l_215851356/article/details/74497922
1.JavaVM结构体.
在java环境中.定义两个主要的结构体.JavaVM和JavaEvn,在Java环境中.每个进程里可以诞生许多VM实例.每个实例会有一个JavaVM结构体实例和他对应.但是在Android环境中.每个进程只能诞生一个VM实例,所以只有一个JavaVM结构体对实例. 通常在VM加载＊.so程序库时，会先调用JNI_OnLoad()函数,在JNI_OnLoad()函数中会将JavaVM指针对象保存到c层JNI的全局变量中,JavaVM对象是所有线程共享的．

2.JNIEnv结构体
2.1　 JNIEnv对象，当Java线程调用到C层的JNI函数的时候.一定会进入VM,VM会产生一个相应的JNIEnv对象．这JNIEnv对象和线程是一一对应的关系.
2.2   在调用JNIEnv中的函数时．多个线程调用的JNIEnv中的本地函数都是独立的．因为VM会为每个线程产生一个JNIEnv对象实体．
2.3   在调用函数的时候如果不方便传递JNIEnv对象，可以先获取JavaVM对象,再使用GetEnv()函数获取JNIEnv对象．
2.4   如果c/c++层自己创建的线程，就必须向VM替它诞生相应的JNIEnv对象．并且回传该对象的指针的值．
2.5 JNIEnv相当于java端的函数地址表

3.jclass, jmethodID和jfieldID
3.1  功能
jclass,jmethodID和jfieldID三者都指针．通过这个三个指针，能获取到java中的属性和方法．
3.2  生命周期
这个类被载入的时候,这些指针都是有效的.一直到这个类被卸载为止.
3.3  作用域.
jmethodID和jfieldID可以直接存储在c获取C++的全局变量中.它不需要NewGlobalRef()函数进行转换 .
它们是线程和函数之间共享的对象.
但是jobject的所有子类,必须使用NewGlobalRef()方法转化才能生成一个全局对象的引用.它们默认情况下时局部的.不能函数共享,和多线程共享.另外还有两个对象, GetStringUTFChars()和GetBytesArrayElements()函数所回传的数据是不需要使用NewGlobalRef()转换的.

java端调用jni调用,在jni端创建new native对象复制给全局变量,这个native对象的生命周期是和线程相关连的,线程未结束,没有调用delete则这个对象是一直存在的
native层的对象生命周期管理还是按照native层自己的声明周期原则处理


#====================================================================
10.解析Java的JNI编程中的对象引用与内存泄漏问题
https://blog.csdn.net/github_27263697/article/details/79807577
https://www.cnblogs.com/zl1991/p/9449229.html
1. JNI 编程中如下的几点弊端，扬长避短，才可以写出更加完善、高性能的代码：
(1)从 Java 环境到 native code 的上下文切换耗时、低效。
(2)JNI 编程，如果操作不当，可能引起 Java 虚拟机的崩溃。
(3)JNI 编程，如果操作不当，可能引起内存泄漏。
(4)JAVA 中的内存泄漏
(5)JAVA 编程中的内存泄漏，从泄漏的内存位置角度可以分为两种：JVM 中 Java Heap 的内存泄漏；JVM 内存中 native memory 的内存泄漏。

2.JNI中不同种类的引用：
1）JNI 支持3中不透明的引用：局部引用、全局引用和弱全局引用。
2）局部和全局引用，有着各自不同的生命周期。局部引用能够被自动释放，而全局引用和若全局引用在被程序员释放之前，是一直有效的。
3）一个局部或者全局引用，使所提及的对象不能被垃圾回收。而弱全局引用，则允许提及的对象进行垃圾回收。
4）不是所有的引用都可以在所有上下文中使用的。例如：在一个创建返回引用native方法之后，使用一个局部引用，这是非法的。

3.局部引用
多数JNI函数都创建局部引用。例如JNI函数NewObject创建一个实例，并且返回一个指向该实例的局部引用。局部引用只在创建它的native方法的动态上下文中有效，并且只在native方法的一次调用中有效。所有局部引用只在一个native方法的执行期间有效，在该方法返回时，它就被回收。在native方法中使用一个静态变量来保存一个局部引用，以便在随后的调用中使用该局部引用，这种方式是行不通的。例如以下例子，误用了局部引用：
局部引用失效，有两种方式：‘
1）系统会自动释放局部变量。
2）程序员可以显示地管理局部引用的生命周期，例如调用DeleteLocalRef
局部对象只属于创建它们的线程，只在该线程中有效。一个线程想要调用另一个线程创建的局部引用是不被允许的。将一个局部引用保存到全局变量中，然后在其它线程中使用它，这是一种错误的编程。

4.全局引用
在一个native方法被多次调用之间，可以使用一个全局引用跨越它们。一个全局引用可以跨越多个线程，并且在被程序员释放之前，一致有效。和局部引用一样，全局引用保证了所引用的对象不会被垃圾回收。和局部引用不一样（局部变量可以由多数JNI函数创建），全局引用只能由一个JNI函数创建（NewGlobalRef）

5.弱全局引用
弱全局引用是在java 2 SDK1.2才出现的。它由NewGolableWeakRef函数创建，并且被DeleteGloablWeakRef函数摧毁。和全局引用一样，它可以跨native方法调用，也可以跨越不同线程。但是和全局引用不同的是，它不阻止对基础对象的垃圾回收

6.比较引用
可以用JNI函数IsSameObject来检查给定的两个局部引用、全局引用或者弱全局引用，是否指向同一个对象。
(*env)->IsSameObject(env, obj1, obj2)
返回值为：
JNI_TRUE，表示两个对象一致，是同一个对象。
JNI_FALSE，表示两个对象不一致，不是同一个对象。
在java VM中NULL是null的引用
如果一个对象obj是局部引用或者全局引用，则可以这样来检查它是否指向null对象：
(*env)->IsSameObject(env, obj, NULL) 或者 NULL == obj
而对于弱全局引用，以上规则需要改变一下：
我们可以用这个函数来判断一个非0弱全局引用wobj所指向的对象是否仍旧存活着（依旧有效）
(*env)->IsSameObject(env, wobj, NULL)
返回值：
JNI_TRUE，表示对象已经被回收了。
JNI_FALSE，表示wobj指向的对象，依旧有效。

释放引用
释放局部引用
多数情况下，在执行一个native方法时，你不需要担心局部引用的释放，java VM会在native方法返回调用者的时候释放。然而有时候需要JNI程序员显示的释放局部引用，来避免过高的内存使用。那么什么时候需要显示的释放呢，且看一下情景：
1）在单个native方法调用中，创建了大量的局部引用。这可能会导致JNI局部引用表溢出。此时有必要及时地删除那些不再被使用的局部引用。例如以下代码，在该循环中，每次都有可能创建一个巨大的字符串数组。在每个迭代之后，native代码需要显示地释放指向字符串元素的局部引用
2）你可能要创建一个工具函数，它会被未知的上下文调用。例如之前提到到MyNewString这个例子，它在每次返回调用者欠，都及时地将局部引用释放
3）native方法，可能不会返回（例如，一个可能进入无限事件分发的循环中的方法）。此时在循环中释放局部引用，是至关重要的，这样才能不会无限期地累积，进而导致内存泄露。

释放全局引用
在native代码不再需要访问一个全局引用的时候，应该调用DeleteGlobalRef来释放它。如果调用这个函数失败，Java VM将不会回收对应的对象。
在native代码不在需要访问一个弱全局引用的时候，应该调用DeleteWeakGlobalRef来释放它。如果调用这个函数失败了，java VM 仍旧将会回收对应的底层对象，但是，不会回收这个弱引用本身所消耗掉的内存

内存泄漏问题
Java Heap 的内存泄漏
Java 对象存储在 JVM 进程空间中的 Java Heap 中，Java Heap 可以在 JVM 运行过程中动态变化。如果 Java 对象越来越多，占据 Java Heap 的空间也越来越大，JVM 会在运行时扩充 Java Heap 的容量。如果 Java Heap 容量扩充到上限，并且在 GC 后仍然没有足够空间分配新的 Java 对象，便会抛出 out of memory 异常，导致 JVM 进程崩溃。
Java Heap 中 out of memory 异常的出现有两种原因——①程序过于庞大，致使过多 Java 对象的同时存在；②程序编写的错误导致 Java Heap 内存泄漏。
JVM 进程空间中，Java Heap 以外的内存空间称为 JVM 的 native memory。进程的很多资源都是存储在 JVM 的 native memory 中，例如载入的代码映像，线程的堆栈，线程的管理控制块，JVM 的静态数据、全局数据等等。也包括 JNI 程序中 native code 分配到的资源。
JNI 编程实现了 native code 和 Java 程序的交互，因此 JNI 代码编程既遵循 native code 编程语言的编程规则，同时也遵守 JNI 编程的文档规范。在内存管理方面，native code 编程语言本身的内存管理机制依然要遵循，同时也要考虑 JNI 编程的内存管理。

Native Code 本身的内存泄漏
JNI 编程首先是一门具体的编程语言，或者 C 语言，或者 C++，或者汇编，或者其它 native 的编程语言。每门编程语言环境都实现了自身的内存管理机制。因此，JNI 程序开发者要遵循 native 语言本身的内存管理机制，避免造成内存泄漏。以 C 语言为例，当用 malloc() 在进程堆中动态分配内存时，JNI 程序在使用完后，应当调用 free() 将内存释放。总之，所有在 native 语言编程中应当注意的内存泄漏规则，在 JNI 编程中依然适应。
JNI 编程还要同时遵循 JNI 的规范标准，JVM 附加了 JNI 编程特有的内存管理机制。
JNI 中的 Local Reference 只在 native method 执行时存在，当 native method 执行完后自动失效。这种自动失效，使得对 Local Reference 的使用相对简单，native method 执行完后，它们所引用的 Java 对象的 reference count 会相应减 1。不会造成 Java Heap 中 Java 对象的内存泄漏。
而 Global Reference 对 Java 对象的引用一直有效，因此它们引用的 Java 对象会一直存在 Java Heap 中。程序员在使用 Global Reference 时，需要仔细维护对 Global Reference 的使用。如果一定要使用 Global Reference，务必确保在不用的时候删除。就像在 C 语言中，调用 malloc() 动态分配一块内存之后，调用 free() 释放一样。否则，Global Reference 引用的 Java 对象将永远停留在 Java Heap 中，造成 Java Heap 的内存泄漏。

7.JNI局部引用表
https://blog.csdn.net/ifloveelse/article/details/38750335
7.1什么是JNI局部引用表？
在JNI函数中使用Java的对象所产生的局部引用，存放在一张表中，这个表就称为局部引用表。在Android dalvik实现中，每个归属于dalvik管理的线程都有一个局部引用表，表的大小为512.
局部引用表回收的时机：当从Java层调用native函数的时候，当函数结束之后，会回收掉函数调用所产生的局部引用。但是，当从native线程（一个很显著的例子就是binder线程），通过JNI调用Java的函数所产生的局部引用，如果没有显示的delete，那么虚拟机就不会帮助我们清除
由此有两个点需要注意：
a.从java层调用native函数时候避免for循环占用局部引用
b.当从native调用java函数的时候，一定要记得清除局部引用。因为虚拟机不会帮助我们清除


8.局部引用创建及释放对照表
GetBooleanArrayElements	== ReleaseBooleanArrayElements
GetByteArrayElements == ReleaseByteArrayElements
GetCharArrayElements == ReleaseShortArrayElements
GetShortArrayElements == ReleaseBooleanArrayElements
GetIntArrayElements == ReleaseIntArrayElements
GetLongArrayElements == ReleaseLongArrayElements
GetFloatArrayElements == ReleaseFloatArrayElements
GetDoubleArrayElements == ReleaseDoubleArrayElements
GetPrimitiveArrayCritical == ReleasePrimitiveArrayCritical
GetStringUTFChars == ReleaseStringUTFChars
NewGlobalRef == DeleteGlobalRef 
GetStringChars == ReleaseStringChars
NewCharArray == DeleteLocalRef
createJavaParcelObject == DeleteLocalRef
FindClass == DeleteLocalRef
NewObject == DeleteLocalRef
GetObjectClass == DeleteLocalRef
DeleteLocalRef可以删除 localRef所指向的局部引用
局部引用：通过NewLocalRef和各种JNI接口创建（FindClass、NewObject、GetObjectClass和NewCharArray等）。会阻止GC回收所引用的对象，不在本地函数中跨函数使用，不能跨线前使用。函数返回后局部引用所引用的对象会被JVM自动释放，或调用DeleteLocalRef释放。(*env)->DeleteLocalRef(env,local_ref)

#====================================================================
11.Java ByteBuffer 使用实例
https://blog.csdn.net/ly1028826685/article/details/84914484
Java NIO中的缓冲区Buffer（二）创建/复制缓冲区
https://www.cnblogs.com/chenpi/p/6478624.html#_label3
ByteBuffer详解
https://www.cnblogs.com/kivi170806/p/7895294.html

#====================================================================
12.java静态变量生命周期
https://www.cnblogs.com/hf-cherish/p/4970267.html
Static:
(1)加载:java虚拟机在加载类的过程中为静态变量分配内存.
(2)类变量:static变量在内存中只有一个,存放在方法区.static变量的生命周期,取决于类的生命周期

类的初始化顺序:
(1)静态变量,静态代码块初始化
(2)构造函数
(3)自定义构造函数

结论:想要用static存一个变量,使得下次程序运行时还能使用上次的值是不可行的.因为静态变量生命周期虽然长(就是类的生命周期),但是当程序执行完,也就是该类的所有对象已经被回收,或者加载类的ClassLoader已经被回收,那么该类就会从jvm的方法区卸载,即生命终止
更进一步来说,static变量终究是存在jvm的内存中的,jvm下次重新运行时,肯定会清空里边上次运行的内容,包括方法区,常量区的内容
要实现某些变量在程序多次运行时都可以读取,那么必须要将变量存下来,即存到本地文件中.常用的数据存取格式:XML,JSON,Propertities类(类似map的键值对)等
首先来了解一下jvm(java虚拟机)中的几个比较重要的内存区域,这几个区域在java类的声明周期中扮演着比较重要的角色:
(1)方法区:在java的虚拟机中有一块专门用来存放已经加载的类信息,常量,静态变量以及方法代码的内存区域,叫做方法区.
(2)常量池:常量池是方法区的一部分,主要用来存放常量和类中的符号引用等信息
(3)堆区:用于存放类的对象实例
(4)栈区:也叫java虚拟机栈,是由一个一个的栈帧组成的后进先出的栈式结构,栈帧中存放方法运行时产生的局部变量,方法出口等信息.当调用一个方法时,虚拟机栈中就会创建一个栈帧存放这些数据,当方法调用完成时,栈帧消失,如果方法中调用了其他方法,则继续在栈顶创建新的栈帧
除了以上四个内存区域以外,jvm中的运行时内存区域还包括本地方法栈和程序计数器,这两个区域与java类的生命周期关系不是很大,在这里就不花时间说了

类的生命周期
当我们编写一个java的源文件后,经过编译会生成一个后缀名为class的文件,这种文件叫做字节码文件,只有这种字节码文件才能够在java虚拟机中运行,java类的生命周期就是指一个class文件从加载到卸载的全过程,一个java类的完整的生命周期会经历加载,连接,初始化,使用,和卸载五个阶段

(1)加载:在加载阶段,java虚拟机找到需要加载的类并把类的信息加载到jvm的方法区中,然后在堆区中实例化一个java.lang.Class对象,作为方法区中这个类的信息的入口
(2)连接:连接阶段比较复杂,一般会根加载阶段和初始化阶段交叉进行,这个阶段的主要任务就是做一些加载后的验证工作以及一些初始化前的准备工作,可以细分为三个步骤:验证,准备和解析
   (2.1)验证:当一个类被加载之后,必须要验证一下这个类是否合法,比如这个类是不是符合字节码的格式,变量与方法是不是有重复,数据类型是不是有效,集成与实现是否合乎标准等等.总之,这个阶段的目的就是保证加载的类是能够被jvm所运行的
   (2.2)准备:准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值,对于非静态的变量,则不会为他们分配内存.有一点需要注意,这时候,静态变量的初值为jvm默认的初值,而不是我们在程序中设定的初值,jvm默认的初值是这样的
   (2.3)解析:这一阶段的任务就是把常量池中的符号引用转换为直接引用,在接卸阶段,jvm会将所有的类或接口名,字段名,方法名转换为具体的内存地址
       (2.3.1)基本类型(int, long, short, char, byte, boolean, float, double)的默认值为0
       (2.3.2)引用类型的默认值为null
       (2.3.3)常量的默认值为我们程序中设定的值,比如我们在程序中定义final static int a = 100,则准备阶段中a的初值就是100
    (2.4)连接阶段完成之后会根据使用的情况(直接引用还是被动引用)来选择是否对类进行初始化
(3)初始化
如果一个类被直接引用,就会触发类的初始化.在java中,直接引用的情况有:
   (3.1)通过new关键字实例化对象,读取或设置类的静态变量,调用类的静态方法
   (3.2)通过反射方式执行以上三种行为
   (3.3)初始化子类的时候,会触发父类的初始化
   (3.4)作为程序入口直接运行时(也就是直接调用main)方法
除了以上四中情况,其他使用类的方式叫做被动引用,而被动引用不会触发类的初始化    

类的初始化过程是这样的:按照顺序自上而下运行类中的变量赋值语句和静态语句,如果有父类,则首先按照顺序运行父类中的变量赋值语句和静态语句.

在类的初始化阶段,只会初始化与类相关的静态赋值语句和静态语句,也就是有static关键字修饰的信息,而没有static修饰的赋值语句和执行语句在实例化对象时候才会运行

(4)使用
类的使用包括主动引用和被动引用,主动引用在初始化阶段已经说过了,下面我们看一下被动引用:
   (4.1)引用父类的静态字段,只会引起父类的初始化,而不会引起子类的初始化
   (4.2)定义类数组,不会引起类的初始化
   (4.3)引用类的常量,不会引起类的初始化
最后总结一下使用阶段:使用阶段包括主动引用和被动引用,主动引用会引起类的初始化,而被动引用不会引起类的初始化

(5)卸载
在类使用完之后,如果满足下面的情况,类就会被卸载
  (5.1)该类所有的实例都已经被回收,也就是java堆中不存在该类的任何实例
  (5.2)加载该类的ClassLoader已经被回收
  (5.3)该类对应的java.lang.Class对象没有任何地方被引用,无法在任何地方通过反射访问该类的
  如果以上三个条件全部满足,jvm就会在方法区垃圾回收的时候对类进行卸载,类的下载过程其实就是在方法区中清空类信息,java类的整个生命周期就结束了

#====================================================================
13.Java中Class对象详解
https://blog.csdn.net/dufufd/article/details/80537638
在java世界里,一切皆对象,从某种意义上来说,java有两种对象:实例对象和Class对象.每个类的运行时的类型信息就是Class对象表示的.它包含了与类有关的信息.其实我们的实例对象就通过Class对象来创建的.Java使用Class对象执行RTTI(运行时类型识别,Run-Time Type Identification),多态是基于RTTI实现的

每一个类都有一个Class对象,每当编译一个新类就产生一个Class对象,基本类型(boolean,byte,char,short,int,long,float,and double)有Class对象,数组有Class对象,就连关键字void也有Class对象(void.class).Class对象对应着java.lang.Class类,如果说类是对象抽象和集合的话,那么Class类就是对类的抽象和集合

Class类没有公共的构造方法,Class对象实在类加载的时候由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的,因此不能显式地声明一个Class对象.一个类被加载到内存并供我们使用需要经理如下三个阶段:

(1)加载,这是由类加载器(ClassLoader)执行的.通过一个类的全限定名来获取其定义的二进制字节流(Class字节码),将这个字节流所代表的静态存储结构转化为方法的运行时数据接口,根据字节码在java堆中生成一个代表这个类的java.lang.Class对象
(2)链接.在链接阶段将验证Class文件中的字节流包含的信息是否符合当前虚拟机的要求,为静态域分配存储空间并设置类变量的初始值(默认的零值),并且如果必须的话,将常量池中的符号引用转化为直接引用(即内存地址)
(3)初始化.到了此阶段,才真正开始执行类中定义的java程序代码.用于执行该类的静态初始器和静态初始块,如果该类有父类的话,则优先对其父类进行初始化

13.1 如何获得Class对象
有三种获得Class对象的方式:
1.Class.forName("类的全限定名")
Class.forName方法是Class类的一个静态成员.forName在执行的过程中发现如果类还没有被加载,那么JVM就会调用类加载器去加载类,并返回加载后的Class对象.Class对象和其他对象一样,我们可以获取并操作它的引用.
Class.forName的好处就在于,不需要为了获取Class引用而持有该类型的对象,只要通过全限定名就可以返回该类型的一个Class引用.

2.实例对象.getClass()
如果你已经有了该类型的对象,那么我们就可以通过调用getClass()方法来获取Class引用,这个方法属于根类Object的一部分,它返回的是表示该对象的实际类型的Class引用
利用new操作符创建对象后,类已经状态到内存中了,所以执行getClass方法的时候,就不会再去执行类加载的操作了,而是直接从java堆中返回该类型的Class引用

3.类名.class(类字面常量)
java还提供了另一种方法来生成对Class对象的引用,即使用类字面常量,就像这样:A.class,这样做不仅更简单,而且更安全,因为它在编译时就会受到检查(因此不需要置于try语句快中).并且根除了对forName()方法的调用,所以也更高效,类字面量不仅可以应用与普通的类,也可以应用于接口,数组及基本数据类型
用.class来创建对Class对象的引用时,不会自动地初始化该Class对象,(这点和Class.forName方法不同).类对象的初始化阶段被延迟到了对静态方法或者非静态域首次引用时才执行

4.补充:
如果一个字段被static final修饰,我们称为"编译时常量",在调用这个字段的时候是不会对类进行初始化的
一旦类被加载到了内存中,那么不论通过那种方式获得该类的Class对象,它们返回的都是指向同一个java堆地址上的Class引用.jvm不会创建两个相同类型的Class对象.
其实对于任意一个Class对象,都需要由它的类加载器和这个类本身一同确定其就在Java虚拟机中的唯一性,也就是说,即使两个Class对象来源同一个Class文件,只要加载他们类加载器不同,那这两个Class对象就必定不相等.这里的"相等"包括了代表类的Class对象的equals(),isAssignbleFrom().isInstance()等方法的返回结果,也包括了使用instanceof关键字对象所属关系的判定结果.所以在java虚拟机中使用双亲委派模型来组织类加载器之前的关系,来保证Class对象的唯一性

5.泛型Class引用
Class引用表示的就是它所指向的对象的确切类型,而该对象便是Class类的一个对象.在JavaSE5中,语序你对Class引用所指向的Class对象的类型进行限定,也就是说你可以对Class对象使用泛型语法.通过泛型语法,可以让编译器强制指向额外的类型检查
内容详见文章,此处不做整理总结(因为用到的不多)

#====================================================================
14.Netty网路通信框架
https://www.w3cschool.cn/essential_netty_in_action/essential_netty_in_action-un8q288w.html



#====================================================================



#====================================================================



#====================================================================