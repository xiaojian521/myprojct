Java Study
#====================================================================
1.编译java静态库，java共享库
https://blog.csdn.net/lin20044140410/article/details/55519026
静态连接库的特点是会在程序的编译链接阶段就完成函数和变量的地址解析工作，并使之成为可执行程序中不可分割的一部分。这种处理手段在某种程度上可以有效地实现代码的重复利用，使得编写程序不需要每次都从零开始。但是它的缺点也是明显的，即可执行程序的体积会随着静态链接库的增加而不断增大。如果系统中有多个可执行程序都用到了同一个静态库Ａ，按照静态链接的做法需要把Ａ分别打包到所有程序中，这显然是一种资源浪费。

动态链接库有２个特点：
动态链接库不需要在编译时就打包到可执行程序中，而是等到后者在运行时再实现动态的加载和　重定位。
动态链接库在被加载到内存之后，操作系统需要为他执行动态连接操作，这里也可以称为“动态链接”，前面编译阶段的链接叫“静态链接”。静态链接中也会有重定位Ｒｅｌｏｃａｔｉｏｎ，只是跟动态链接中的重定位有差异。只要涉及多个文件之间的链接，通常都需要重定位，只是静态链接发生在编译阶段，而动态链接发生在运行阶段。
动态链接库的核心优势就是代码共享，不单是进程内的代码共享，还包括进程间的代码共享。

#====================================================================
2.使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。

#====================================================================
3.Map<String, ?>只能是只读模式，不能增加，因为增加的时候不知道该写入什么类型的值；Map<String, Object>可以读和写，只要是所有Object类的子类都可以。


#====================================================================
4.JAVA中STATIC{}语句块详解
https://www.cnblogs.com/caolaoshi/p/7824748.html
static{}(即static块)，会在类被加载的时候执行且仅会被执行一次，一般用来初始化静态变量和调用静态方法，下面我们详细的讨论一下该语句块的特性及应用。

类加载:Java命令的作用是启动虚拟机，虚拟机通过输入流，从磁盘上将字节码文件(.class文件)中的内容读入虚拟机，并保存起来的过程就是类加载。

 类加载特性 :
      *在虚拟机的生命周期中一个类只被加载一次。
      *类加载的原则：延迟加载，能少加载就少加载，因为虚拟机的空间是有限的。
      *类加载的时机：
      1）第一次创建对象要加载类.
      2）调用静态方法时要加载类,访问静态属性时会加载类。
      3）加载子类时必定会先加载父类。
      4）创建对象引用不加载类.
      5) 子类调用父类的静态方法时
          (1)当子类没有覆盖父类的静态方法时，只加载父类，不加载子类
          (2)当子类有覆盖父类的静态方法时，既加载父类，又加载子类
      6）访问静态常量，如果编译器可以计算出常量的值，则不会加载类,例如:public static final int a =123;否则会加载类,例如:public static final int a = math.PI。

#====================================================================
5.java库生成的是jar包，对应两种类型的库，一个是通过 那么，BUILD_JAVA_LIBRARY 与BUILD_STATIC_JAVA_LIBRARY的区别是什么？

BUILD_JAVA_LIBRARY编译出来的jar包，里面是DEX格式的文件，如果用户想用这个jar包放到Eclipse来做Android APP的开发，Eclipse是不认识这种格式的文件的，通常会报错：Conversion to Dalvik format failed with error 1；
而BUILD_STATIC_JAVA_LIBRARY编译出来的jar包，里面每个java文件对应的class文件都单独存在，顾名思义，每个java文件里面用到的变量都被静态编译到了class内部，这种格式的jar包可以在Eclipse/AndroidStudio里面导入并正常使用，但是可能存在一定的兼容性隐患。 二者的区别在于静态JAVA库是由.class文件打包而成JAR包，它在任何一个JAVA虚拟机上都可以运行；而共享JAVA库则是在静态库的基础上进一步打包成的.dex文件，众所周知，dex是在android系统上所使用的文件格式。

1. 动态jar包	
(1)生成后可以共享代码	
(2)生成的是class.dex文件,只能运行在Android平台中	
注 : 	Android虚拟机Dalvik支持的字节码文件格式Google在新发布的Android平台上使用了自己的Dalvik虚拟机
	来定义， 这种虚拟机执行的并非Java字节码， 而是另一种字节码： dex格式的字节码
	Class文件------Java编译后的目标文件
	不像J2se，java编译成class就可以直接运行，android平台上class文件不能直接在android上运行。 由于Google
	使用了自己的Dalvik来运行应用， 所以这里的class也肯定不能在AndroidDalvik的java环境中运行， android
	的class文件实际上只是编译过程中的中间目标文件，需要链接成dex文件后才能在dalvik上运行
	
2.静态jar包	
(1)可以打包进apk,也可以运行在Android平台中,某些情况可能出现问题	
(2)生成的是.class文件,可以运行在java虚拟机中

#====================================================================
6.Synchronized 详解
https://www.cnblogs.com/xyabk/p/10901291.html
1.多线程调用同一个对象的方法中同步代码块(synchronized (this)),线程是同步的
2.多线程调用同一个对象中使用synchronized修饰普通方法的情况,锁对象默认为this,当前实例.eg: public synchronized void method(){}
3.synchronized用在静态方法上,默认的锁就是当前所在的Class类,多线程访问多个对象上的静态方法时,都是同步的.eg:public static synchronized void method(){}
4.synchronized指定锁对象为Class对象(synchronized 类名.class),多线程访问多个对象上同步代码块时都是同步的

核心思想:
1.一把锁只能同时被一个线程获取，没有拿到锁的线程只能等待
2.每个实例都对应有自己的一把锁（this）,不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁
3.synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁

synchronized的性质:
1.可重入性
概念：指同一个线程外层函数获取到锁之后，内层函数可以直接使用该锁
好处：避免死锁，提升封装性（如果不可重入，假设method1拿到锁之后，在method1中又调用了method2,如果method2没办法使用method1拿到的锁，那method2将一直等待，但是method1由于未执行完毕，又无法释放锁，就导致了死锁，可重入正好避免这这种情况)

2.不可中断性
概念：如果这个锁被B线程获取，如果A线程想要获取这把锁，只能选择等待或者阻塞，直到B线程释放这把锁，如果B线程一直不释放这把锁，那么A线程将一直等待
相比之下，未来的Lock类，可以拥有中断的能力（如果一个线程等待锁的时间太长了，有权利中断当前已经获取锁的线程的执行，也可以退出等待）

3.synchronized的缺陷
效率低：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时

不够灵活：加锁和释放的时机单一，每个锁仅有一个单一的条件（某个对象），相对而言，读写锁更加灵活

无法知道是否成功获得锁，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....

#====================================================================
7.Java四种引用,强引用,弱引用,软引用,虚引用
https://www.cnblogs.com/fengbs/p/7019687.html
(1).强引用
Object o=new Object();   //  强引用
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，要通过如下方式来弱化引用，如下：
o=null;     // 帮助垃圾收集器回收此对象
显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。
在一个方法的内部有一个强引用，这个引用保存在栈中，而真正的引用内容（Object）保存在堆中。当这个方法运行完成后就会退出方法栈，则引用内容的引用不存在，这个Object会被回收。
但是如果这个o是全局的变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收

(2)软引用
如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
String str=new String("abc");                                     // 强引用 
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

(3)弱引用
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
 如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象.
String str=new String("abc");    
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
下面的代码会让str再次变为一个强引用：
String  abc = abcWeakRef.get();
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。
这个引用不会在对象的垃圾回收判断中产生任何附加的影响

(4)虚引用
“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。

虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

#====================================================================
8.当Android.mk引入jar包时报错
Exception in thread "main" java.time.DateTimeException: Invalid value for MonthOfYear (valid values 1 - 12): 0
因为jdk9版本问题,补丁可以参考
https://bugs.openjdk.java.net/browse/JDK-8184940

#====================================================================
9.JavaVM对象和JNIEvn对象
https://www.cnblogs.com/fnlingnzb-learner/p/7366025.html
https://blog.csdn.net/l_215851356/article/details/74497922
1.JavaVM结构体.
在java环境中.定义两个主要的结构体.JavaVM和JavaEvn,在Java环境中.每个进程里可以诞生许多VM实例.每个实例会有一个JavaVM结构体实例和他对应.但是在Android环境中.每个进程只能诞生一个VM实例,所以只有一个JavaVM结构体对实例. 通常在VM加载＊.so程序库时，会先调用JNI_OnLoad()函数,在JNI_OnLoad()函数中会将JavaVM指针对象保存到c层JNI的全局变量中,JavaVM对象是所有线程共享的．

2.JNIEnv结构体
2.1　 JNIEnv对象，当Java线程调用到C层的JNI函数的时候.一定会进入VM,VM会产生一个相应的JNIEnv对象．这JNIEnv对象和线程是一一对应的关系.
2.2   在调用JNIEnv中的函数时．多个线程调用的JNIEnv中的本地函数都是独立的．因为VM会为每个线程产生一个JNIEnv对象实体．
2.3   在调用函数的时候如果不方便传递JNIEnv对象，可以先获取JavaVM对象,再使用GetEnv()函数获取JNIEnv对象．
2.4   如果c/c++层自己创建的线程，就必须向VM替它诞生相应的JNIEnv对象．并且回传该对象的指针的值．
2.5 JNIEnv相当于java端的函数地址表

3.jclass, jmethodID和jfieldID
3.1  功能
jclass,jmethodID和jfieldID三者都指针．通过这个三个指针，能获取到java中的属性和方法．
3.2  生命周期
这个类被载入的时候,这些指针都是有效的.一直到这个类被卸载为止.
3.3  作用域.
jmethodID和jfieldID可以直接存储在c获取C++的全局变量中.它不需要NewGlobalRef()函数进行转换 .
它们是线程和函数之间共享的对象.
但是jobject的所有子类,必须使用NewGlobalRef()方法转化才能生成一个全局对象的引用.它们默认情况下时局部的.不能函数共享,和多线程共享.另外还有两个对象, GetStringUTFChars()和GetBytesArrayElements()函数所回传的数据是不需要使用NewGlobalRef()转换的.

java端调用jni调用,在jni端创建new native对象复制给全局变量,这个native对象的生命周期是和线程相关连的,线程未结束,没有调用delete则这个对象是一直存在的
native层的对象生命周期管理还是按照native层自己的声明周期原则处理


#====================================================================
10.解析Java的JNI编程中的对象引用与内存泄漏问题
https://blog.csdn.net/github_27263697/article/details/79807577
需要后期在多复习在细看


#====================================================================



#====================================================================



#====================================================================



#====================================================================




#====================================================================



#====================================================================



#====================================================================