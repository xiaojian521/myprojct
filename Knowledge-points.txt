//==================================================================
1.c++ 添加map
eg:
static const std::map<VR_CSPott::VR_CSPott_Cmd_Type, std::string>::value_type CMD_INIT_DATA[] = {
    std::map<VR_CSPott::VR_CSPott_Cmd_Type, std::string>::value_type(VR_CSPott::VR_CSPott_Cmd_Type_Music, "MusicCommand_SP_Adapt_190104"),
    std::map<VR_CSPott::VR_CSPott_Cmd_Type, std::string>::value_type(VR_CSPott::VR_CSPott_Cmd_Type_Navi, "NaviCommand_SP_Adapt_190104")
};

static const std::map<VR_CSPott::VR_CSPott_Cmd_Type, std::string> s_cmdFiles(CMD_INIT_DATA, CMD_INIT_DATA + 2);
//==================================================================
2.jvm之对象在内存中的布局
https://blog.csdn.net/u014229215/article/details/78584371
https://blog.csdn.net/qingguiyu/article/details/79237129 //深入理解Java虚拟机 &GC分代年龄

3.Java中Synchronized的用法
https://blog.csdn.net/javazejian/article/details/72828483 //深入理解Java并发之synchronized实现原理
https://blog.csdn.net/luoweifu/article/details/46613015
synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 
(1). 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
(2). 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
(3). 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
(4). 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。
总结:
A. 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 
B. 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 
C. 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制
//==================================================================
4.Linux环境使用g++编译C++方法总结
https://www.jb51.net/article/102210.htm
https://www.jb51.net/article/137075.htm

//==================================================================
5.编译的整个过程：预编译、编译、汇编、链接
https://blog.csdn.net/w_y_x_y/article/details/80309416
//==================================================================
6.c++类大小问题
https://www.cnblogs.com/sz-leez/p/7119232.html
https://www.cnblogs.com/heyonggang/p/3255155.html
//==================================================================
7.C++构造函数以protected声明
如果你不想让外面的用户直接构造一个类（假设这个类的名字为A）的对象，而希望用户只能构造这个类A的子类，那你就可以将类A的构造函数/析构函数声明为protected，而将类A的子类的构造函数/析构函数声明为public
//==================================================================
8.为什么要把父类的析构函数设置为virtual
如果我们想通过基类的指针去释放子类的对象（这里必须是new出来的对象），就需要基类将基类的虚函数设置为virtual
C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数
原因是基类指针指向了派生类对象，而基类中的析构函数却是非virtual的，之前讲过，虚函数是动态绑定的基础。现在析构函数不是virtual的，因此不会发生动态绑定，而是静态绑定，指针的静态类型为基类指针，因此在delete时候只会调用基类的析构函数，而不会调用派生类的析构函数
https://blog.csdn.net/qq_36946274/article/details/81294006
//==================================================================
9.  介绍预定义宏"__cplusplus"
    (1)__cplusplus的值是为了表示C++的版本
    (2)一.3 __cplusplus的类型是"long int"
    (3)目前标准中规定的值只有一个——199711L
//==================================================================
10. extern C 知识点
https://www.cnblogs.com/yuxingli/p/7821102.html
C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名
//==================================================================